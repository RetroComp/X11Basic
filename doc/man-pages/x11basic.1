.TH X11BASIC 1 19-Sep-2002 "Version 1.08" "Linux Basic Interpreter"
.SH NAME
xbasic (X11-Basic) \- Basic interpreter and shell
.SH SYNOPSIS
.B xbasic
[--eval <Ausdruck>] [-e <kommando>] [-l] [<filename>]

.SH DESCRIPTION

X11-Basic is a comprehensive non-standard Basic interpreter with full X 
capability that integrates fratures like shell scripting, cgi-Programming and 
full graphical visualisation into the easy to learn basic language on moden 
computers.

The syntax is most similar to the old GFA-Basic ATARI ST
implementation. Old gfa-programs should run with only few changes. 


.IR xbasic 
is a script interpreter. It interpretes basic command-Files.
It can run in interactive and batch-mode.
A psydocompiler can be used to make stand-alone-binaries.

The X11-Basic environment contains a library of GEM GUI functions.  This makes
writing GUI programs in X11-Basic faster and easier than programming with
native GUI tools.

.SH COMMANDLINE OPTIONS
.P
.SS \ <file>
load and run script <file>
.br
.SS \-l <file>
only load script, do not execute
.br
.SS \--eval <expression>
evaluate expression
.br
.SS \-e <command>
execute command
.br
.SS \-version
shows version, program and other information and exits
.SS -h --help
print a short help
.SS --help <topic>
print help on topic
.SS --daemon
daemon mode

For detailed help and description of the implemented basic commands take a 
look at the README file. 
.SH INTERACTIVE USE
If no options are given on the command line, 
.B xbasic
will run interactivly.

A Prompt will be displayed and any command can be typed in. It will be
excecuted immediately after pressing return or enter. The interpreter uses the 
.B readline(3) 
library. So the input is buffered and can be edited using the up and down 
arrows on the keyboard.
Readline  offers  editing  capabilities  while the user is
entering the line.  By default, the line editing  commands
are  similar  to  those of emacs. 
 
.B To quit program
simply enter quit or press CTRL-C.
.SH EXAMPLES
.nf
xbasic testme.bas
xbasic -e 'alert 1,"Hello world !",1," OK ",b'
xbasic --eval 1+3-4*3
xbasic --help "*nl*"
.fi

You can find many sample programs in 
.I /usr/share/doc/packages/X11Basic/examples.
.SH X11-Basic as daemon:
The commandline option --daemon forces the interpreter to run in daemon-mode.
No prompt is given and the input in not echoed back. 

To run the X11-Basic interpreter on a tcp-socket on port 1371 create a new user 
called xbasic and insert
.nf
--- in /etc/inetd.conf: --- 
xbasic stream tcp nowait xbasic /usr/sbin/tcpd /bin/xbasic --daemon
--- in /etc/services: ---
xbasic          1371/tcp
---
.if
Please note that this is not recommended since xbasic would open
several security holes on your system.
.SH X11-Basic as shell:
X11-Basic programs can be excecuted like shell scripts .
If the xbasic interpreter was installed in 
.I /bin/ 
any X11-Basic program with
.nf
 #!/bin/xbasic
.fi
in the first command line can be excecuted directly.
.SH The pseudo compiler
The X11-Basic package is shipped with a pseudo compiler, which makes 
stand-alone binaries out of Basic source code. Actually this "compiler" is not
a real compiler, since the source code is still interpreted on runtime. But the
source code is linked to the X11-Basic library so there results one 
independant executable. Another advantage is that it is quite hard to extract a
full running *.bas File from this binary since the code is compressd in a way. 
You will find the compiler in 
.I /usr/share/doc/packages/X11Basic/examples/compiler/compiler.bas.
Yes, the compiler compiles itself. 
Just make sure you have built the shared library 
.I libx11basic.so 
and the library for static linking before.
.SH The X11-Basic Language
.SS Variables
At the moment, X11-Basic only recognizes 2 kind of vars; Strings and Doubles.
.nf
!!! The integers are not yet fully implemented. So please
!!! do not use them at the moment.
.fi

Variable names and commands are case insensitive. Names of variables are
limited of a number of characters or digits specified in defs.h (default 64)
and have to begin with a character. Each name is bound to only one kind of
variable; A$ is a whole different variable(value) than A which is different
from A(1,1) or A$(1,1).

.B String variables

String variables are sequences of characters. Strings generally contain
ASCII text, but can hold arbitrary byte sequences. Strings are automatically
elastic, meaning they automatically resize to contain whatever number of bytes
are put into them. When a string resizes, its location in memory may change,
as when a longer string is assigned and there is insufficient room after the
string to store the extra bytes. X11-Basic string variables automatically 
resize to hold whatever length string
is assigned to them.  A wealth of intrinsics and functions are provided to
support efficient string processing.  
 

.B Arrays

X11-Basic arrays can contain variables of any type, including strings.  
All arrays, even multi-dimensional arrays, can be redimensioned without
altering the contents.


.B Spaces

Space between commands will be ignored, but note that no space is allowed 
between the name of a variable or command and the '(' of its parameter list. 
So, ASC("A") is good, ASC(     "A"     ) also,
but ASC ("A") isn't.

.B reserved variable names

There are some reserved variables. Some Keywords may not work as varable names
as well. Although there is no checking done, parsing errors could occure.
Please try the command LET in such cases. In general, as long as an ending of
an variable name is different then any command or keyword, it's usable as
name.

Reserved and system variables are:

.nf
TRUE          -1
FALSE         0
PI            3.141592...
TIMER         unix system timer, float, seconts 
STIMER        integer system timer
CTIMER        system timer in units of CPU-time
PC            line number of next line to be processed
SP            internal stack pointer
ERR           error number of last error

MOUSEX        x coordinate of mouse position relative to window 
MOUSEY        y coordinate of mouse position 
MOUSEK        mouse button state
              Button 1=Bit 0,Button 2=Bit 1 usw.
MOUSES        state of the shift,alt,ctrl,caps keys 

INKEY$        content of the keyboard-buffer
TERMINALNAME$ device name of the standard terminal
TIME$         current time 
DATE$         current date
.fi

.SS Conditions

Conditions and expression are the same, FALSE is defined as 0 and TRUE as -1.
Those definitions are defined in defs.h and could be changed, but that
is not recommended. Because BASIC doesn't have a seperate boolean operators for
conditions and expressions, using an boolean operator (AND,OR,XOR,NOT) may give
spurious results. When on each site a value of an 0 or -1 is used, it's assumed
as an condition, if it's not, it considered an expression. Problems could
occure if you use boolean operators with negative numbers, but that is also
unrecommended because the outcome of such an expression is highly platform
depended.

.SS Numbers

Numbers may preceed 0x to represent hex values.

.SS Operators

Precedence is defined as follows (highest first):
.nf
0. ()                 (brackets)
1. ^                  (power)
2. * /
3. \
4. - +                ()
5. MOD DIV            (modulus, ...)
6. < > = <> <= >=      (comparison operators)
7. AND OR XOR NOT EQV IMP (logical operators)
.fi

.SS Shortcuts
.nf
'    -- REM
?    -- PRINT
@    -- GOSUB
~    -- VOID
!    -- comment at the end of a line
&    -- indirect command
.fi

.SS commands
.nf
AFTER n,procedure       -- execute procedure after n seconds
ARRAYFILL a(),b         -- fills array with value
ARRAYCOPY dest(),souce() -- copies array including Dimensionierung

BEEP			-- Warnton auf der Console Auslösen
BELL			-- dasselbe wie BEEP
BGET #f,a%,n%		-- Liest n% Bytes aus File #f nach Adresse a%
BLOAD f$,a%[,l%]	-- Lädt File an Adresse
BMOVE q%,z%,n%          -- Kopiert n% Bytes großen Speicherbereich
BPUT
BREAK                   -- entspricht EXIT IF true
BSAVE f$,a%,l%		-- Speichert l% Bytes ab Adresse a% in File f$

CALL adr%[,par,...]     -- see EXEC
CASE const              -- see SELECT * CASE * DEFAULT * ENDSELECT
CHAIN
CLEAR                   -- clear and remove all variables
CLOSE  [[#]n%]          -- I/O-Kanal schließen
CLR a,b%,c(),f$		-- clears variables
CLS                     -- clear (text)screen
CONT                    -- continue (after STOP)


DATA 1,"Hallo",...	-- Definiert Konstanten im Programmcode
DEFAULT                 -- see SELECT * CASE * DEFAULT * ENDSELECT

DIM                     -- Dimensionierung von Arrays
DO * LOOP		-- Endlosschleife
DPOKE adr%,word%        -- Schreibt den 2-Byte-Wert an Adresse adr%
DUMP			-- lists all used variable names
DUMP "@"                -- list of Funktionen und Prozeduren
DUMP ":"                -- list of all labels
DUMP "#"                -- list of open Files
DUMP "K"                -- list of implementierten Kommandos
DUMP "F"                -- list of internal functions

ECHO {ON|OFF}           -- Programmzeilenechomodus ein-/ausschalten
EDIT             -- set edit-mode and perform the following actions
                 - SAVE "name.~~~"   writes the BASIC-program 
                   into a temporary file,                     
                 - calls the editor '$EDITOR'                      
                 - NEW  clears internal values                
                 - LOAD "name.~~~"   reads the BASIC-program  
                   from the temporary file.                   
ELSE                    -- see IF * ELSE * ENDIF
END			-- Programmende, kehrt zurück in den Direktmodus
ENDFUNCTION             -- see FUNCTION * ENDFUNCTION
ENDIF                   -- see IF * ELSE * ENDIF
ENDSELECT               -- see SELECT * CASE * DEFAULT * ENDSELECT 
ERASE a()[,b$(),...]    -- Löscht felder
ERROR n%                -- löst Fehler Nr. n% aus
EVERY n,procedure	-- invokes procedure every n seconds
EXEC adr%[,var%[,...]]	-- Ruft Unterroutine an Adresse adr% auf. Die Parameter 
                           aus der Parameterliste werden auf dem Stack
			   übergeben. Typen werden mit D: (double)
			   oder L: (integer) festgelegt. 
			   Die Adresse adr% kann Adresse eines Symbols
			   sein, welches sich in einem zugelinkten
			   shared-object-File befindet. (siehe sym_adr()) 
EXIT IF a		-- Verlässt Schleife wenn Bedingung a erfüllt ist

FLUSH [#n]              -- Output flushen

FOR * NEXT		-- For Next Schleife
FORM_INPUT t$           -- Stringeingabe mit Editierm"oglichkeit
FUNCTION * ENDFUNC      -- Funktionen mit Rueckgabe (s. RETURN)

GOSUB procedure(varliste) -- Unterroutine aufrufen
GOTO label              -- An stelle label springen

HELP <expr>             -- prints short help on expr              
HOME                    -- Textcursor home


IF * ELSE IF * ELSE * ENDIF 
INC a%                  -- increments a%
INPUT [#unit,] ["text";] varlist
                read values for variables separated by comma   
                    #unit  logical device number (OPEN)            
                    "text"  is printed before reading the values   
                    varlist:   list of variables separated by comma

LET a=b                 -- Erzwingt Zuweisung
LINEINPUT [#unit,]t$ 
                    read values for variables separated by newline 
LINK #n,t$              -- Lädt shared object file t$
LIST [s,e]		-- Listet Programmcode von Zeile s bis e
LLIST [s,e]             -- writes the BASIC-program-listing from line s to 
                           line e with linenumbers into the file 
			   "<programname>.prme" and prints it on demand            
LOAD a$			-- Lädt Programm (Dateiname in a$), parses the 
                           BASIC-program text and generates the internal data 
			   structures 
LOCAL var[,var2,...]    -- specifies a list of vars to be local in Procedure
LOCATE column,row 	-- Place cursor on column and row (counting from 0,0 upper left)
LOOP                    -- see DO * LOOP
LPOKE adr%,long%        -- Schreibt den 4-Byte-Wert an Adresse adr%
LSET t$=a$

MENUDEF array$(),proc   read text for menu-header from array$() 
                    the string-array contains the text      
                    for menu-line and menu-rows             
                    - end of row: empty string ""           
                    - end of menu-text: empty string ""
		    proc is a procedure with one parameter
		    which is the number of the selected item
		    to call when item was selected     
ON MENU GOSUB p1    define PROCEDURE p1 to handle an action   
                    if a menue-point was selected             

MERGE f$                -- Merges bas-file to actual program code
MID$(t$,i,j)=b$
MUL a,b			-- same as a=a*b

NEW			-- Löscht alle Variablen und hält Programmausführung an.
NEXT                    -- see FOR * NEXT
NOP                     -- do nothing
NOOP                    -- do nothing

ON * GOSUB proc1[,proc2,...]
ON BREAK GOSUB proc
ON ERROR GOSUB proc
OPEN mode$,#n,filename$	-- open a file or socket for input and/or output
OUT #n,a		-- out byte a to channel n

PAUSE sec		-- pauses sec seconds
PLIST                   -- formatted listing
POKE adr%,byte%         -- Schreibt byte an Adresse adr%
PRINT a;b$              -- Ausgewachsener BASIC-Standard-Befehl
PRINT USING             -- mit Formatierung
PROCEDURE procname [(p1 [,p2] ... )]  * RETURN
PSAVE a$                -- writes the reformatted BASIC-program into file with the name a$      
PUTBACK [#n,]a%         -- Zeichen mit ASCII-Code a% an inputkanal zurückgeben
QUIT                    -- quits the X11-BASIC-Interpreter

RANDOMIZE [seed%]	-- Sets seed for random generator, normally TIMER is used for this
READ var                -- reads constant from DATA statement
RELSEEK #n,d		-- Place filepointer on new relative position d
REM comment             -- comment 
REPEAT                  -- see REPEAT * UNTIL
RESTORE [label]         -- (re)sets pointer for READ-statement to "label" 
RESUME
RETURN                  -- define the end of a PROCEDURE          
RETURN expr             -- return value from FUNCTION          
RSRC_LOAD filename$     -- loads GEM rsc-File (ATARI ST)
RSRC_FREE               -- frees GEM rsc-File (ATARI ST)
RUN                     -- Startet die Programmausführung

SAVE [a$]        -- writes the BASIC-program into file with the name a$      
SEEK #n,d	-- Place filepointer on new absolute position d
SETENV t$=a$    -- Sets environmentvar t$ using value a$
SORT a(),n[,b()] -- Sort array
SWAP
SYSTEM t$      -- Führt Shell-Kommando aus
TROFF          -- Trace mode off
TRON           -- Trace mode on  (for debugging)
UNLINK #n      -- unlinks shared object #n
UNTIL exp      -- if exp is false goto REPEAT
VERSION        -- shows X11-Basic version number and date
VOID a         -- Berechnet Ausdruck a und vergisst Ergebnis

WORT_SEP t$,d$,mode,a$,b$ -- separates string t$ by deliminator d$ in a$ and b$
.fi

.SS Graphic commands
.nf
ALERT a,b$,c,d$,var[,ret$] -- Infobox                    
BOX x1,y1,x2,y2	    -- draw a frame
CIRCLE x,y,r        -- draw a circle
CLEARW [[#]n%]      -- clear graphic window
CLOSEW [[#]n%]      -- close graphic window
COLOR f[,b]	    -- Set foreground color (and background color)
DEFFILL c,a,b	    -- set fill style and pattern 
DEFLINE a,b	    -- set line width and type
DEFMARK c,a,g       -- define: colour, size, type (POLYMARK)        
DEFMOUSE i	    -- set mouse cursor type
DEFTEXT c,s,r,g		-- set text properties for ltext
DRAW [[x1,y1] TO] x2,y2 -- draw line 
ELLIPSE x,y,a,b[,a1,a2] -- draw an ellipse
FILESELECT titel$,pfad$,default$,f$  --     display a fileselector-box            
GET x,y,w,h,g$          -- Grafik-Ausschnitt in g$ speichern
GPRINT                  -- like PRINT, but the output goes to the graphic window
GRAPHMODE mode      	-- set graphic-mode                 
KEYEVENT a,b            -- Waits until Key is Pressed
LINE x1,y1,x2,y2    -- draw a line
LTEXT x,y,t$        -- Linegraphic-Text

MENUDEF array$(),proc   -- read text for menu-header from array$() 
MENUSET n,x         -- change menu-point #n with value x       
MENU STOP           -- switch off the menu                     
ON MENU GOSUB p1    -- define PROCEDURE p1 to handle an action   
ONMENU              -- execute the menu and                      
MENU                -- wait for menue-events  

MOUSE x,y,k         -- gets position and state of mouse
MOUSEEVENT
MOTIONEVENT

MOVEW n,x,y         -- move window
OPENW n		    -- open window
PBOX  x1,y1,x2,y2   -- draw filled box
PCIRCLE x,y,r[,a1,a2] -- draw filled cirle
PELLIPSE x,y,a,b[,a1,a2]-- draw filled ellipse
PLOT x,y            -- draw point
POLYLINE n,x(),y()  -- draw polygon in (x(),y())        
POLYFILL n,x(),y()  -- draw filled polygon
POLYMARK n,x(),y()  -- draw polygon points                
PRBOX x1,y1,x2,y2   -- draw filled rounded box
PUT x,y,g$          -- map graphic at position
PUT_BITMAP t$,i,i,i,i -- map bitmap
RBOX x1,y1,x2,y2    -- draws a rounded box
SCOPE a(),typ,yscale,yoffset   -- fast plot a()
SCOPE y(),x(),typ,yscale,yoffset,xscale,xoffset   -- fast 2D plot
SGET screen$   -- capture graphic and store it in screen$
SHOWPAGE       -- maps all graphic to window
SPUT screen$   -- maps (xwd-)graphic to window 
TEXT x,y,t$    -- draw text
TITLEW n,t$    -- set window title
VSYNC          -- same as SHOWPAGE
XLOAD          -- load a program, with FILESELECTOR
XRUN           -- load and run a program, with FILESELECTOR
.fi

.SS Math commands
.nf
ADD a,b		 -- same as a=a+b but faster
DEC var          -- same as var=var-1 but faster
DIV a,b          -- same as a=a/b but faster
FFT a(),i	 -- fast fourier transformation on 1D array. 
			   if i=-1 backward transformation
FIT x(),y()[,yerr()],n,func(x,a,b,c,...) -- fits function to data
FIT_LINEAR x(),y()[,[xerr(),]yerr()],n,a,b[,siga,sigb,chi2,q]
		 -- linear regression with errors
INC var          -- same as var=var+1 but faster
MUL a,b		 -- same as a=a*b but faster
SORT a(),n[,b()] -- sorts n values of a() to incrementing order 
SUB a,b          -- same as a=a-b but faster
.fi

.SS Math functions
.nf
b=ABS(a)         -- absolut value 
c=ADD(a,b)       -- add
a=RND(dummy)	 -- random number between 0 and 1
i=SGN(a)	 -- get sign of a (-1,0,1)
b=SQR(a)	 -- square root
b=SQRT(a)	 -- square root
b=TRUNC(a)
b=INT(a)

.fi

.B Angles

Angles are always radians, for both arguments and return values.
To convert degrees to radians, use RAD().
To convert radians to degrees, use DEG().

.nf
SIN()     sine
COS()     cosine
TAN()     tangent
COT()     cotangent
SEC()     secant
CSC()     cosecant

ASIN()    arc-sine
ACOS()    arc-cosine
ATAN()    arc-tangent
b=ATAN2(a,c) -- extended arc-tangent
ACOT()    arc-cotangent
ASEC()    arc-secant
ACSC()    arc-cosecant

SINH()    hyperbolic sine
COSH()    hyperbolic cosine
TANH()    hyperbolic tangent
COTH()    hyperbolic cotangent
SECH()    hyperbolic secant
CSCH()    hyperbolic cosecant

ASINH()   hyperbolic arc-sine
ACOSH()   hyperbolic arc-cosine
ATANH()   hyperbolic arc-tangent
ACOTH()   hyperbolic arc-cotangent
ASECH()   hyperbolic arc-secant
ACSCH()   hyperbolic arc-cosecant

LOG()     base e logarithm (natural log)
LOG10()   base 10 logarithm
EXP()     base e "anti-log"  (e to the x)
EXP10()   base 10 "anti-log"  (10 to the x)
SQRT()    square root
POWER()   power  (x to the y)
.fi

.SS general functions
.nf
a%=ARRPTR(b())         -- Adresse des Array-Descriptors
a%=ASC(t$)             -- ASCII-Wert des ersten Zeichens von t$
                          ASCII code of first letter of string

b$=BIN$(a%[,n%])       -- Stellt a% als Binärzahl mit n% Stellen

t$=CHR$(a%)            -- Zeichen mit ASCII-Code a%
a%=CINT(b)             -- Truncated number (NOTE: differs from INT ! )
b=COS(a)               -- Cosinus
b%=CVI(a$)             -- Wandelt Zeichenkette in 2-Byte-Integer
b%=CVL(a$)             -- Wandelt Zeichenkette in 4-Byte-Integer
b=CVS(a$)              -- identisch mit CVF
b=CVF(a$)              -- Wandelt Zeichenkette in 4-Byte-Float
b=CVD(a$)              -- Wandelt Zeichenkette in 8-Byte-Double

DFREE
y=DEG(x)               -- entspricht y=180*x/pi 
DIM?(a())              -- Ruckgabe ist Anzahl der Elemente von a()
i%=DPEEK(adr%)

t$=ENV$(n$)             -- Inhalt der Environmentvariable mit Namen n$

EOF(#n)                 -- -1 wenn Ende des Files #n erreicht, sonst 0
b=EVEN(a%)		-- TRUE wenn a% gerade
EXIST(fname$)           -- -1 wenn File fname$ existiert, sonst 0
ret%=EXEC(adr%[,var%])  -- siehe Befehl EXEC mit int-Rückgabeparameter
b=EXP(a)		-- Exponentialfuntion

a%=FORM_ALERT(n%,t$)
a%=FORM_DIAL(i%,i%,i%,i%,i%,i%,i%,i%,i%)
a%=FORM_DO(i%)
b=FRAC(a)		-- Liefert den nichtganzzahligen Anteil an a
FRE(n)			-- Keine Funtion, nur aus Kompatibilitätsgründen da.
a=FREEFILE()            -- Returns first free filenumber or -1

a=GASDEV(dummy)         -- Zufallszahl Gaussverteilt
c%=GET_COLOR(r%,g%,b%) -- Alloziert eine Farbe in der Farbtabelle und gibt die
                          Nummer zurück. Ist in der Farbtabelle kein Platz
			  mehr, so wird die Nummer derjenigen Farbe
			  zurückgegeben, die der angeforderten am nächsten
			  kommt.
f%=GLOB(a$,b$[,flags%])     -- Testet, ob a$ in das Pattern b$ passt

b=GRAY(a)		-- Gibt Graycode zurueck. wenn a<0: inverser Graycode

t$=HEX$(a%[,n%])        -- a% als Hexadezimalzahl
HYPOT(num,num)

t$=INLINE$(a$)          -- 7Bit-ASCII to Binary conversion, can be used to include
                           Binary data in the source code.
c%=INP(#n)		-- Liest ein Zeichen (Byte) vom Kanal. Kanal -2 ist stdin
c%=INP?(#n)		-- Gibt die Anzahl von Zeichen, die vom Kanal gelesen werden 
			   k"onnen. Kanal -2 ist stdin
INP&(#n)
i%=INP%(#n)


t$=INPUT$(#n,anz%)
a%=INSTR(s1$,s2$[,n])   -- tests if s2$ is contained in s1$, then      
                           returns start-position of s2$, else 0.
                           start comparison at pos. n (default=1)
i=INT(a)		-- Schneidet die Nachkommastellen ab, liefert ganze Zahl

a=julian(date$)         -- Julianischer Tag
d$=juldate$(a)          -- Umkehrfunktion


LEFT$(a$[,n%])          -- extraxts from string a$ the first (left) n characters
l%=LEN(t$)              -- length of string
b=LN(a)			-- Natürlicher Logarithmus
p%=LOC(#n)		-- Position des Filepointers (--> SEEK/RELSEEK)
			   Returns value of file position indicator
l%=LOF(#n)		-- Länge des files
a=LOG(b)                -- Natuerlicher Logarithmus
a=LOG10(b)              -- 10er Logarithmus
b%=LPEEK(adr%)          -- reads long (4 Bytes) from adress
LPOS

m=MAX(a,b,c,...)
m=MAX(f())
m$=MID$(t$,s[,l])       -- extraxts from string t$ a string from position s 
                           with l characters
m=MIN(a,b,c,...)
m=MIN(f())

t$=MKI$(i%)             -- Wandelt Integer in 2-Byte String
t$=MKL$(i%)             -- Wandelt integer in 4-Byte String
t$=MKF$(a)              -- Wandelt Realzahl in 4 Byte String
t$=MKD$(a)              -- Wandelt Realzahl in 8 Byte String

OBJC_DRAW(i%,i%,i%,i%,i%)
OBJC_FIND(tree%,x%,y%)
o$=OCT$(d%,n%)
a=ODD(d%)               -- liefert TRUE wenn d% ungerade

d%=PEEK(a%)             -- reads Byte from adress
c%=POINT(x%,y%)         -- Liefert Farbwert des Punkts der Grafik im aktuellen Fenster
POS
t$=PRG$(i)              -- Programmzeile i (Quelltext)


RAND(dummy)             -- Ganze Zufallszahl zwischen 0 und einer Systemabhaengigen
				groessten Zahl
RANDOM(n%)              -- Zufallszahl zwischen [0 und n%[

RIGHT$(a$,n%)
a%=RINSTR(s1$,s2$[,n])  -- tests if s2$ is contained in s1$, then      
                           returns start-position of s2$, else 0.
                           start comparison at pos. n (default=1)
                           start comparison at right
RND(dummy)		-- Zufallszahl zwischen 0 und 1, gleichverteilt
RSRC_GADDR(typ%,nr%)

b=SIN(a)		-- Sinus
i%=SGN(a)		-- Vorzeichen (-1,0,1)
			-- Returns -1 if value is negative, 0 if zero and 1 if positive
t$=SPACE$(i%)		-- gibt einen String mit lauter Blanks
SPC(i%)
b=SQR(a)		-- Wurzel
b=SQRT(a)		-- Wurzel
t$=STR$(a[,b%,c%])      -- Wandelt Zahl in String der Laenge b% 
                           mit c% signifikanten Stellen
t$=STRING$(w$,i%)       -- Vervielfaeltigt w$ i% mal
adr%=SYM_ADR(#n,s$)     -- liefert Adresse des Symbols mit Namen s$ aus shared
                           Object File #n
t$=SYSTEM$(n$)          -- Ausgabe des Shell-Kommandos n$

TAB(i%)
b=TAN(a)		-- Tangens
t$=TERMINALNAME$(#n)    -- Devicename des Terminals an Kanal n
b=TRUNC(a)

u$=UCASE$(t$)		-- identisch mit UPPER$()
t$=unixtime$(i%)        -- Zu einem Zeitstempel gehoerende Zeit
d$=unixdate$(i%)        -- zugehoeriges Datum

u$=UPPER$(t$)		-- liefert t$ in Großbuchstaben

a=VAL(t$)		-- Wandelt String in Zahl, falls der String eine
			   Zahlendarstellung enthält.
i%=VAL?(t$)		-- Liefert die Anzahl der umwandelbaren Zeichen
a%=VARPTR(v)		-- Adresse der Variablen v
.fi

.SS SUBROUTINES
Subroutines are blocks of code that can be called from elsewhere in a
function.  Subroutines can take arguments but return no results. They can
access all variables available but also may have local variables (--> LOCAL).
Subroutines are defined with 
.nf
PROCEDURE name(argumentlist)
  ...  many commands
RETURN
.fi

.SS FUNCTIONS
X11-Basic functions are blocks of code that can be called from elsewhere within an
expression (e.g a=3*@myfunction(b)). Functions can take arguments 
and must return a result.
Variables are global unless declared local. For local variables changes outside a
function have no effect within the function except as explicitly specified
within the function.  Functions arguments can be variables and arrays of any
types.  Functions can return variables of any type. By default,
arguments are passed by value. Functions can be executed recursively.
A function will be defined by:
.nf
FUNCTION name(argumentlist)
  .. many more calculations
  RETURN returnvalue
ENDFUNCTION
.fi

.SH VERSION
Page was created for V.1.08
.SH BUG REPORTS       

If you find a bug in the X11-Basic interpreter, you should
report it. But first,  you  should make sure that it really is
a bug, and that it appears in the latest version of the
X11-Basic package that you have.

Once  you have determined that a bug actually exists, mail a
bug report to m.hoffmann@uni-bonn.de.  If you have a  fix,
you  are  welcome  to  mail that as well!  Suggestions  may 
be  mailed  to the x11-basic mailing list on 
www.sourceforge.net/projects/x11-basic  or posted to the bug
tracking system.

Comments and  bug  reports  concerning  this  manual  page
should be directed to m.hoffmann@uni-bonn.de.
.SH BUGS
Still some bugs
.SH AUTHOR
Markus Hoffmann <m.hoffmann@uni-bonn.de>
.SH COPYRIGHT
Copyright (C) 1997-2003 Markus Hoffmann <m.hoffmann@uni-bonn.de>

This program is free software;  you  can  redistribute  it
and/or modify it under the terms of the GNU General Public
License as published  by  the  Free  Software  Foundation;
either  version  2 of the License, or (at your option) any
later version.

This program is distributed in the hope that  it  will  be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS  FOR  A  PARTICULAR
PURPOSE.   See  the  GNU  General  Public License for more
details.
.SH SEE ALSO
tcsh(1), sh(1), readline(3)
