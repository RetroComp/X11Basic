 This file is part of X11BASIC, the basic interpreter for Unix/X
 ===============================================================
 X11BASIC is free software and comes with NO WARRANTY - read the file
 COPYING for details

***************************************************************
*               X11-Basic              V. 1.03                *
*                   von Markus Hoffmann 1997-2001 (c)         *
*                                                             *
* Programmversion vom Sun Apr  1 02:38:18 CEST 2001           *
*                                                             *
***************************************************************

 Author: Markus Hoffmann                              
 Structured-BASIC-Interpreter with X11 graphic capabilities                          
 - using the functionality of GFA-BASIC on AtariST     
   with GEM/TOS (GFA-BASIC ported to UNIX-environment) 
 - can be used as a shell
 - can be used to write cgi-Scripts

 FEATURES 
 ======== 
 Structured-BASIC-Interpreter                     
 - without line-numbers                           
 - GOTO / GOSUB-labels are symbolic names         
 - Structure elements:                            
     WHILE - EXIT IF - WEND                        
     REPEAT - EXIT IF - UNTIL                      
     DO - EXIT IF - LOOP                           
     IF - ELSE IF - ELSE - ENDIF                   
     FOR - EXIT IF - NEXT                          
     PROCEDURE() - EXITIF - RETURN                  
     FUNCTION() - RETURN - ENDFUNCTION                   
 - Variable types indicated by appendix to name:  
     varname     REAL (double)                    
     varname%    INTEGER (long)                   
     varname!    BOOLEAN          (*)              
     varname$    STRING                   
 - PROCEDURE and FUNCTION can have formal parameters 
             and local variables                  
 - DEFFN defines an inline-function (*)               
 - integrated graphic instructions                

(*) not implemented yet

##########################
## Bedienungsanleitung: ## 
##########################

Das Programm kann mit folgenden Parametern aufgerufen werden:  

xbasic <filename>   --- Basic-Programm ausfuehren  [input.bas]

-l                  --- Programm nur laden 
-e <kommando>       --- Basic Kommando ausfuehren 
--eval <ausdruck>   --- Num. Ausdruck auswerten  

Beispiel:

xbasic testme.bas
xbasic -e 'alert 1,"Hallo !",1," OK ",b'
xbasic --eval 1+3-4*3

X11-Basic als Daemon:
=====================
wird X11-Basic mit
xbasic --daemon
gestartet, so erscheint bei der Kommandoeingabe kein Prompt und es erfolgt kein 
Echo der Tastatureingabe.

X11-Basic als Shell:
====================
X11-Basic Programme koennen auch wie Shell-Scripts gestartet werden.
Hierzu installiert man xbasic in /bin/. Mit der Anweisung
#!/bin/xbasic
in der ersten Zeile des Scipts wird es als X11-Basic-Programm ausgefuehrt.



Kurzanleitung zu X11BASIC:
===========================

Variablenkonzept:
-----------------

Der interpreter kennt 64-Bit Floatingpoint Variablen, 32-Bit Integervariablen,
Zeichenketten und beliebigdimensionale Felder obengenannter Typen.
Eine Deklaration der Variablen ist nicht noetig (Ausser bei Feldern --> DIM),
da der Interpreter den Typ an der Endung der Variable erkennt:
Integervariablen tragen die Endung %, Zeichenketten ein $, felder ein ().
Variablen ohne Endung werden als float interpretiert.
Pointer sind Integer, Funktionsergebnisse werden durch @ gekennzeichnet
Logische Ausdruecke soind ebenfalls vom Typ Interger.
Typenumwandlungen werden bei Bedarf automatisch vorgenommen, wo dies moeglich
ist. 

Die Variablen werden dynamisch verwaltet, so sind beliebig grosse Zeichenketten
und Felder moeglich. Die Grenze ist hier nur der maximal allozierbare Speicher
und max. 31 Bit fuer die Indizierung. Das sollte vorerst ausreichen.


Beispiele:

Integer-Variablen:      i%=25
			a%=varptr(b$)
			b%=malloc(100000)
Float-Variablen:        a=1.2443e17
			b=@f(x)
Zeichenkettenvariablen: t$="Das ist ein Text"
Felder/Arrays:          i%(),a(),t$()

Logische Ausdruecke:    (a=2 AND b=5) sind vom Typ Integer (TRUE=-1, FALSE=0)


OPERATOREN
##########

Man unterscheidet zwischen numerischen, Zeichenketten- und Feld- bzw.
Matritzenoperatoren, je nachdem, ob das ergebnis der Operation eine Zahl oder
eine Zeichenkette ist.
 
-- Zeichenkettenoperatoren ---

+	Dier Verkettung von Zeichenketten.
	Dabei werden die durch + verbundenen Strings lückenlos
	aneinandergefügt.

	Beispiel: a$="X11", b$="-" und c$="BASIC", dann ergibt sich 
        d$=a$+b$+c$ die Zeichenkette "X11-BASIC" 

$()     Zeichenkettenfunktionen:
	z.B. LEFT$, RIGHT$, MID$, SPACE$, STRING$, STR$ ...

-- Numerische Operatoren --

Die numerischen Operatoen können in vier Kategorien gegliedert werden:

*	Arithmetische Operatoren

*	Vergleichsoperatoren

*	Logische Operatoren

*	Numerische Funktionen

-- Matritzenoperatoren --

Matritzenoperatoren oder allgemein Feld-Operatoren operieren auf Feldern.
Je nach Feldtyp und Dimension koennen sie unterschiedliche Bedeuting haben.

        $    F   I   D2 D3 Dn Sonstige Bemerkungen
+       *    *   *    *  *  *
-       -    *   *    *  *  *
*       -    *   *    *  -  -  M1=N2 , auch skalar
INV()   -    *   *    *  -  -  M=N
TRANS() *    *   *    *  -  -  M=N

Weiterhin gibt es Operatorn/Funktionen, die zwischen verschiedenen
Variablenklassen Operieren: z.B.
a%=INT(b), c=DET(d()), s=SMUL(a(),b()), a()=NULL(2,4,5), ...

Insbesondere sei auf den Reduktionsoperator hingewiesen:
b()=a(:,3) ist ein eindimensionaler Vektor, naemlich die Spalte Nr. 3 der
        Matrix a. 


-- Integer und Float-Variablen ---
()           Klammerung
+ - * /      Grundrechenarten
^            Potenz

MOD          Modulo
DIV          Ganzzahliger Teiler


Vergleichsoperatoren: = <> < > <= >=
====================================

Vergleichsoperatoren können zwischen zwei Ausdrüchen gleichen Typs stehen, also
zwischen Zeichenkettenausdruecken, numerischen Ausdruecken oder Feld-Ausdruecken.
Abhängig vom Wahrheitswert (wahr oder falsch) wird ein dem Vergleich entweder der
Wert -1 (wahr) oder 0 (falsch) zugeordnet.
(Da sich in jedem Fall eine Zahl ergibt, zählt auch der Vergleich von
Zeichenketten zu den numerischen Operatoren.)

Folgende Vergleichsoperatoren sind verfügbar:

	=	gleich
	>	größer als
	<	kleiner als
	<>	ungleich
	>=	größer oder gleich
	<=	kleiner oder gleich

Zum Vergleich von numerischen Ausdrücken sollen hier nur einige Beispiele
aufgeführt werden:

PRINT 3=1.5*2  übergibt den Wert  -1   (wahr)
PRINT 5>5      übergibt den Wert   0   (falsch)

Der Vergleich von Zeichenketten vollzieht sich nach folgenden Regeln: 

*	Zwei Zeichenketten sind gleich, wenn sie vollständig übereinstimmen.
	(Dabei werden alle Zeichen der Strings, auch Leerzeichen und Satzzeichen,
	verglichen. So gilt z.B. " 123 v fdh.-," = " 123 v fdh.-,")

*	Bein Größenvergleich zweier Strings wird folgendermaßen verfahren:
	Die Zeichenketten werden Zeichenweise verglichen, solange, bis der
	ASCII-Code des Zeichens des einen Strings kleiner ist als der des
	Zeichens  des anderen Strings, oder das Zeichenkettenende eines Strings
	erreicht wird. Dieser Ist dann kleiner als der andere.

	Beispiele:
	"X11">"X11"     ergibt  0
        "X11"<"x11"     ergibt -1
        "123"<"abc"     ergibt -1
        "123">"1234"    ergibt  0

Logische Operatoren: AND OR NAND OR NOT XOR EQV IMP 
====================================================

Mit Hilfe der logischen Operatoren können Ausdrücke oder Beziehungen zwischen
Ausdrücken miteinander verbunden werden.

In der Regel werden mit logischen Operatoren Wahrheitswerte verknüpft und als
Ergebnis wiederum Wahrheitswerte ausgegeben.
Dabei wird jedem numerischen Ausdruck ungleich 0 der Wahrheitswert 0 und jedem
Ausdruck, dessen Wert gleich 0 ist, der Wahrheitswert falsch zugeordnet.
Die von den Logischen Operatoren erzeugten Wahrheitswerte ergeben sich aus
der Bit-weisen Operation, wenn die Operanden als 32-Bit Integerwerte
angesehen werden. Deshalb gehoert zum Wahrheitswert 0 (falsch) der
Wahrheitswert -1 (wahr). Hierfür gibt es auch die Systemvariablen TRUE=-1
und FALSE=0. Dies kann man auch in numerischen Ausdrücken Verwenden, z.B.:
a=ABS(x=0)*100+ABS(x=1)*200   je nach dem Wert von x erhaelt die Variable a die
Werte 100 oder 200.

AND   Konjunktion
      Das Ergebnis von AND ist nur dann w, wenn beide Argumente w sind:

      A  |  B  |  A AND B
    -----+-----+-----------
      w  |  w  |    w
      w  |  f  |    f
      f  |  w  |    f
      f  |  f  |    f

      Beispiele:
      Print 3=3 AND 4>2        ergibt  -1 (w)
      Print 3>3 AND 5>3        ergibt   0 (f)

OR   Disjunktion
     Das Ergebnis von OR ist nur dann f, wenn beide Argumente f sind:

      A  |  B  |  A OR B
    -----+-----+-----------
      w  |  w  |    w  
      w  |  f  |    w
      f  |  w  |    w
      f  |  f  |    f
      
      Beispiele:
      Print "A"<"a" OR 3=5     ergibt  -1 (w)
      Print 2>7 OR 10=20       ergibt   0 (f)

XOR  Exclusives (oder ausschließendes) Oder
     Das Ergebnis von XOR ist  f, wenn die Argumente gleiche Wahrheitswerte
     haben:
      
      A  |  B  |  A XOR B   
    -----+-----+-----------
      w  |  w  |    f
      w  |  f  |    w
      f  |  w  |    w
      f  |  f  |    f

      Beispiele:
      Print 3=3 XOR 6=6     ergibt   0 (f)
      Print 3>5 XOR 3<5     ergibt  -1 (w)

NOT   Die Negation vertauscht Wahrheitswerte in ihr Gegenteil.

      A  |  NOT A
    -----+----------
      w  |   f 
      f  |   w  

      Beispiel:
      Print NOT 3=3      ergibt   0 (f)

IMP  Implikation
     Das Resultat der Operation ist dann falsch, wenn falsch auf wahr folgt. 
      
      A  |  B  |  A IMP B
    -----+-----+-----------
      w  |  w  |    w
      w  |  f  |    f
      f  |  w  |    w
      f  |  f  |    w

EQV  Äquivalenz 
     Dier Operation ist identisch mit (A IMP B) AND (B IMP A)
                                                                           
      A  |  B  |  A EQV B
    -----+-----+-----------
      w  |  w  |    w
      w  |  f  |    f
      f  |  w  |    f
      f  |  f  |    w

Die logischen Operatoren werden hauptsächlich dazu benutzt, um abhängig vom
Wahrheitswert verbundener Ausdrücke verschiedene Programmabläufe zu ermöglichen
(z.B. über die Befehle IF, WHILE, EXIT IF ...)
Logische Operatoren können aber auch dazu benutzt werden, um Bitfolgen zu
verknüpfen.

Strukturiertes Programmieren
============================

Der Interpreter nennt sich zwar Basic, jedoch gibt es gegenueber den 
Uralt-Basic-Dialekten Einschr"ankungen und Erweiterungen, die Strukturiertes
Programmieren erlaubt. Die Programme sind dann "ubersichtlicher.
Zeilennummern gibt es nicht und in jeder Zeile kann hoechstens eine Anweisung
stehen.
Spr"unge mit GOTO sind zwar m"oglich, aber nicht n"otig, da alle g"angigen
Schleifentypen zur Verf"ugung stehen, einschliesslich einem Befehl fuer weitere
Abbruchbedingungen (--> EXIT IF).
Selbstdefinierte Prozeduren und Funktionen mit Parameterliste und 
R"uckgabewerten jeden Typs sind m"oglich.
Die Programmstruktur eines Programms erlaubt also "ublicherweise ein Hauptteil,
z.B. eine Schleife, von der aus Unterprogramme aufgerufen werden.
Mit einem Kommando (--> MERGE) lassen sich so auch ganze Bibliotheken 
hinzuzubinden.


------ Anweisungen -------------
Allgemeines:

Nach Befehlen sind Kommentare erlaubt, die mit einem "!" vom Befehl abzusetzen
sind.
DO    ! Endlosschleife
LOOP  ! und nix drin

Diese Kommentare sind natuerlich nicht erlaubt nach DATA (und REM).

Der &-Operator gefolgt von einem Zeichenkettenausdruck evaluiert deren inhalt 
als Programm-Code.

Beispiel:

clr i
a$="print a$"
label1:
inc i
if i>10 
  b$="label2"
else
  b$="label1"
endif
&a$
goto &b$
label2:
end

erzeugt 10x die Ausgabe "print a$".
Dies fuehrt leicht zu unuebersichtlichem Code, aber schliesslich schmpft sich
der Interpreter ja Basic.



'                     -- Abkuerzung fuer REM
?                     -- Abkuerzung fuer PRINT
@                     -- Abkuerzung fuer GOSUB, bzw Funktionsaufruf
~                     -- Abkuerzung fuer VOID
!                     -- Kommentar hinter einer Zeile
&                     -- Indirektes Kommando


------ Systemvariablen ----------

TRUE                  -1
FALSE                 0
CRSCOL			n.n.
CRSLIN			n.n.
PI                    3.141592...
TIMER                 Systemtimer, float, erhoet sich mehr oder weniger 
                      kontinuierlich mit der Zeit, pro Sekunde um eins
STIMER                Dasselbe nur ganzzahlig
CTIMER                Dasselbe nur in Einheiten der CPU-Zeit
PC                    Zeilennr der naechsten auszufuehrenden Zeile
SP                    interner Stackpointer (Verschachtelungstiefe)
ERR                   Fehlernr des letzten Fehlers


MOUSEX                X-Koordinate der Mausposition relativ zum Fensterursprung
MOUSEY                Y-Koordinate der Mausposition
MOUSEK                Bitrepresentation der gedrueckten Maustasten, 
                      Button 1=Bit 0,Button 2=Bit 1 usw.
MOUSES                Status der Umschalttasten 

ENV$(n$)              Inhalt der Environmentvariable mit Namen n$
INKEY$                Inhalt des Tastaturpuffers
PRG$(i)               Programmzeile i
TERMINALNAME$         Devicename des Terminals
TIME$                 Aktuelle Zeit 
DATE$                 Aktuelles Datum

==================== Befehle ==============================

ADD a,b			-- gleiche Wirkung wie a=a+b
AFTER n,procedure       -- Nach n Sekunden wird die Procedure einmal ausgefuehrt
ALERT a%,b$,c%,d$,var	-- Warn- und Infobox                    
                    a%     sign: 1=! 2=? 3=STOP        
                    b$     textstring lines separated by | 
                    c%     default button
                    d$     string for buttons  separated by |    
                    var    return # of button selected 

ARRAYFILL a(),b         -- F"ullt ganzes Array mit Wert
ARRAYCOPY ziel(),b()    -- Kopiert ganzes Array inclusive Dimensionierung

BEEP			-- Warnton auf der Console Ausl"osen
BELL			-- dasselbe wie BEEP
BGET #f,a%,n%		-- Liest n% Bytes aus File #f nach Adresse a%
BLOAD f$,a%[,l%]	-- Laed File an Adresse
BMOVE q%,z%,n%          -- Kopiert n% Bytes grossen Speicherbereich
BOX x1%,y1%,x2%,y2%	-- Rechteck zeichenen
BPUT
BREAK                   -- entspricht EXIT IF true
BSAVE f$,a%,l%		-- Speichert l% Bytes ab Adresse a% in File f$

CASE
CHAIN
CIRCLE x%,y%,r%
CLEAR
CLEARW
CLOSE  [[#]n%]          -- I/O-Kanal schliessen
CLOSEW [[#]n%]          -- Fenster schliessen
CLR a,b%,c(),f$		-- Löscht Variableninhalte
CLS                     -- Loescht Textscreen/Console
color n%		-- Farbe auswählen
CONT                    -- Programmausfuehrung fortfahren


DATA 1,"Hallo",...	-- Definiert Konstanten im Programmcode
DEC var                 -- Decrementiere var
DEFAULT                 -- siehe SELECT * CASE * DEFAULT * ENDSELECT
DEFFILL c,a,b
DEFLINE
DEFMARK c,a,g      -+- define: colour, size, type (POLYMARK)        
                    |  c     colour                         
                    |  a     type of marker                 
                    |        (1=. 2=+ 3=* 4=[] 5=+ 6=#)     
                    +- g     size of marker (0,20,40,60,80,100)                        

DEFMOUSE i%		-- aendert das Erscheinungsbild des Mauscursors.
DEFTEXT c,s,r,g
DIM
DIV 
DO * LOOP		-- Endlosschleife
DPOKE adr%,word%        -- Schreibt den 2-Byte-Wert an Adresse adr%
DRAW [[x1,y1] TO] x2,y2
DUMP			-- Variablenliste
DUMP "@"                -- Liste der Funktionen und Prozeduren
DUMP ":"                -- Liste der Labels
DUMP "#"                -- Liste der Offenen Files
DUMP "K"                -- Liste der implementierten Kommandos
DUMP "F"                -- Liste der internen Funktionen

ECHO {ON|OFF}           -- Programmzeilenechomodus ein-/ausschalten
EDIT             set edit-mode and perform the following actions
                 - SAVE "name.~~~"   writes the BASIC-program 
                   into a temporary file,                     
                 - calls the editor 'vi'                      
                 - NEW  clears internal values                
                 - LOAD "name.~~~"   reads the BASIC-program  
                   from the temporary file.                   
ELLIPSE
ELSE
END			-- Programmende, kehrt zurueck in den Direktmodus
ENDFUNCTION
ENDIF
ENDSELECT
ERASE
ERROR n%                -- loest Fehler Nr. n% aus
EVENT
EVERY
EXEC adr%[,var%]	-- Ruft unterroutine an Adresse adr% mit int-Parameter
                           var% auf. Die Adresse adr% kann Adresse eines Symbols
			   sein, welches sich in einem zugelinkten
			   shared-object-File befindet. 
EXIT IF a		-- Verlaesst Schleife wenn Bedingung a erfuellt ist

FFT a(),i		-- Fouriertransformation. i=-1 Ruecktransformation
			   Dim?(a()) muss Zweierpotenz sein.
FILESELECT titel$,pfad$,default$,f$  --     display a fileselector-box            
                    titel$   Titel
		    pfad$    search-path + selector  
                    default$ filename                
                    f$   return selected filename with path or ""
FLUSH [#n]              -- Output flushen

FOR * NEXT		-- For Next Schleife
FORM_INPUT t$
FUNCTION * ENDFUNC

GET x,y,w,h,g$          -- Grafik-Ausschnitt in g$ speichern
GOSUB
GOTO
GRAPHMODE mode      set graphic-mode                 
                    mode: 1=replace 2=transparent    
                          3=xor 4=reverse transparent

HELP <expr>             -- prints short help on expr              
HOME                    -- Textcursor home


IF * ELSE IF * ELSE * ENDIF 
INC
INFOW
INPUT [#unit,] ["text";] varlist
                read values for variables separated by comma   
                    #unit  logical device number (OPEN)            
                    "text"  is printed before reading the values   
                    varlist:   list of variables separated by comma

KEYEVENT

LET
LINE
LINEINPUT [#unit,] ["text";] varlist 
                    read values for variables separated by newline 
LINK #n,t$              -- Laed shared object file
LIST [s,e]		-- Listet Programmcode von Zeile s bis e
LLIST [s,e]             -- writes the BASIC-program-listing from line s to 
                           line e with linenumbers into the file 
			   "<programname>.prme" and prints it on demand            
LOAD a$			-- Laed Programm (Dateiname in a$), parses the 
                           BASIC-program text and generates the internal data 
			   structures 
LOCAL
LOOP
LPOKE adr%,long%        -- Schreibt den 4-Byte-Wert an Adresse adr%
LTEXT x%,y%,t$          -- Line-Text

MENUDEF array$(),proc   read text for menu-header from array$() 
                    the string-array contains the text      
                    for menu-line and menu-rows             
                    - end of row: empty string ""           
                    - end of menu-text: empty string ""
		    proc is a procedure with one parameter
		    which is the number of the selected item
		    to call when item was selected     
MENUSET n,x         change menu-point #n with value x       
                    x=0  ' '  normal, reset marker '^'      
                    x=1  '^'  set marker                    
                    x=2  '='  set menu-point non selectable 
                    x=3  ' '  set menue-point selectable    
                         '-'  permanent non selectable      
MENU STOP           switch off the menu                     
ON MENU GOSUB p1    define PROCEDURE p1 to handle an action   
                    if a menue-point was selected             
ONMENU              execute the menu and                      
MENU                wait for menue-events  

MERGE
MOUSE
MOUSEEVENT
MOTIONEVENT
MOVEW
MUL a,b			-- a=a*b

NEW			-- Loescht alle Variablen und haelt Programmausfuehrung an.
NEXT
NOP
NOOP

ON * GOSUB     
ON BREAK GOSUB
ON ERROR GOSUB
OPEN mode$,#n,filename$	-- Oeffnet ein file
                    mode$="I"   for input                  
                    mode$="O"   for output                  
                    mode$="A"   append                  
                    mode$="S"   socket                  

OPENW n
OUT #n,a

PAUSE sec		-- Haelt Programmausfuehrung fuer sec Sekunden an
PBOX  x1,y1,x2,y2
PCIRCLE x,y,r
PELLIPSE 
PLIST                   -- Formatiertes Listing
PLOT x,y                -- Punkt an Bildschirmkoordinate x,y zeichnen 
POKE adr%,byte%         -- Schreibt byte an Adresse adr%
POLYLINE n,x(),y()  draw polygon in (x(),y())        
                    the first point = last point to draw
                      a closed polygon
POLYFILL n,x(),y()  draw filled polygon                
                    connects first point with last point
                      and fills the resulting polygon with
                      pattern defined in DEFFILL
POLYMARK n,x(),y()  draw polygon points                
                    type of points defined in DEFMARK
                    n        # of points
                    x(),y()  arrays with (x,y)-values of points
PRINT a;b$              -- Ausgewachsener BASIC-Standard-Befehl
PROCEDURE procname [(p1 [,p2] ... )]  * RETURN



PSAVE a$                -- writes the reformatted BASIC-program into file with 
                           the name a$      
PUT x,y,g$              -- Grafik in g$ an x,y Ausgeben
PUTBACK [#n,]a%         -- Zeichen mit ASCII-Code a% an inputkanal zurueckgeben

QUIT                    -- Verlaesst den X11-BASIC-Interpreter

RANDOMIZE
READ
RELSEEK #n,d
REM Kommentar  -- Kommentarzeile
REPEAT * UNTIL
RESTORE [label]-- (re)sets pointer for READ-statement to "label" 
RESUME
RETURN         --   define the end of a PROCEDURE          
RETURN expr    --   define the end of a FUNCTION          
RUN            -- Startet die Programmausfuehrung

SAVE a$        -- writes the BASIC-program into file with the name a$      
SCOPE a(),typ,yscale,yoffset   -- Schnelles Plotten des Feldes a()
SCOPE y(),x(),typ,yscale,yoffset,xscale,xoffset   -- 2D Plot
SEEK
SGET screen$   -- Fensterinhalt in screen$ speichern
SHOWPAGE       -- Aktualisiert die Grafikausgabe
SPUT screen$   -- (xwd) Grafik in screen$ auf Window
SUB
SWAP
SYSTEM t$      -- Führt Shell-Kommando aus
                  e.g. SYSTEM "ls"  prints current directory 
TEXT x,y,t$
TROFF
TRON

UNLINK #n      -- Entfernt shared object #n

VERSION        -- Gibt xbasic Versionsinformationen aus
VOID a         -- Berechnet Ausdruck a und vergisst Ergebnis
VSYNC          -- Aktualisiert die Grafikausgabe

WORT_SEP t$,d$,mode,var1$,var2$

XLOAD          -- wie load, mit FILESELECTOR
XRUN           -- load und run, mit FILESELECTOR

=============== Funktionen  =========================

DEFFN fname(parlist)=expression                 
DEFFN fname$(parlist)=$-expression                 
                    define an inline-function     
              e.g.: DEFFN av(x,y)=SQR(x^2+y^2)  
              e.g.: a=@av(b,c)   ! call av       
              e.g.: DEFFN add$(a$,b$)=a$+b$
FUNCTION fname(parlist)    !  define a function     
FUNCTION fname$(parlist)    !  define a $-function     
              e.g.: FUNCTION av(x,y)               
                      LOCAL z                        
                      z = SQR(x^2+y^2)             
                      RETURN 2*z                     
                    ENDFUNCTION

b=ABS(a)               -- Absolutbetrag
c=ADD(a,b)             -- Addiere, binaer
a%=ARRPTR(b())         -- Adresse des Array-Descriptors
a%=ASC(t$)             -- ASCII-Wert des ersten Zeichens von t$
b=ATN(a)               -- Arcustangens
b=ATAN(a)              -- Arcustangens
b=ATAN2(a,c)           -- Arcustangens alle 4 Sektoren

b$=BIN$(a%[,n%])       -- Stellt a% als Binaerzahl mit n% Stellen

t$=CHR$(a%)            -- Zeichen mit ASCII-Code a%
b=COS(a)               -- Cosinus
b%=CVI(a$)             -- Wandelt Zeichenkette in 2-Byte-Integer
b%=CVL(a$)             -- Wandelt Zeichenkette in 4-Byte-Integer
b=CVS(a$)              -- identisch mit CVF
b=CVF(a$)              -- Wandelt Zeichenkette in 4-Byte-Float
b=CVD(a$)              -- Wandelt Zeichenkette in 8-Byte-Double

DFREE
DEG
DIM?
i%=DPEEK(adr%)

EOF(#n)                 -- -1 wenn Ende des Files #n erreicht, sonst 0
b=EVEN(a%)		-- TRUE wenn a% gerade
EXIST(fname$)           -- -1 wenn File fname$ existiert, sonst 0
ret%=EXEC(adr%[,var%])  -- siehe Befehl EXEC mit int-Rueckgabeparameter
b=EXP(a)		-- Exponentialfuntion

b=FRAC(a)		-- Liefert den nichtganzzahligen Anteil an a
FRE(n)			-- Keine Funtion, nur aus Kompatibilitaetsgruenden da.
a%=FORM_ALERT(n%,t$)

c%=GET_COLOR(r%,g%,b%) -- Alloziert eine Farbe in der Farbtabelle und gibt die
                          Nummer zurueck. Ist in der Farbtabelle kein Platz
			  mehr, so wird die Nummer derjenigen Farbe
			  zurueckgegeben, die der angeforderten am naechsten
			  kommt.

t$=HEX$(a%[,n%])        -- a% als Hexadezimalzahl

c%=INP(#n)		-- Liest ein Zeichen (Byte) vom Kanal. Kanal -2 ist stdin
i%=INP%(#n)
t$=INPUT$(#n,anz%)
a%=INSTR(s1$,s2$[,n])   -- tests if s2$ is contained in s1$, then      
                           returns start-position of s2$, else 0.
                           start comparison at pos. n (default=1)
i=INT(a)		-- Schneidet die Nachkommastellen ab, liefert ganze Zahl

LEFT$(a$[,n%])          -- extraxts from string a$ the first (left) n characters
l%=LEN(t$)
b=LN(a)			-- Natuerlicher Logarithmus
p%=LOC(#n)		-- Position des Filepointers (--> SEEK/RELSEEK)
l%=LOF(#n)		-- Laenge des files
a=LOG(b)
a=LOG10(b)
b%=LPEEK(adr%)
LPOS

m=MAX(a,b,c,...)
m=MAX(f())
m$=MID$(t$,s[,l])       -- extraxts from string t$ a string from position s 
                           with l characters
m=MIN(a,b,c,...)
m=MIN(f())

t$=MKI$(i%)             -- Wandelt Integer in 2-Byte String
t$=MKL$(i%)             -- Wandelt integer in 4-Byte String
t$=MKF$(a)              -- Wandelt Realzahl in 4 Byte String
t$=MKD$(a)              -- Wandelt Realzahl in 8 Byte String

o$=OCT$(d%,n%)
a=ODD(d%)               -- liefert TRUE wenn d% ungerade

d%=PEEK(a%)
c%=POINT(x%,y%)         -- Liefert Farbwert des Punkts der Grafik im aktuellen Fenster
POS


RANDOM(n%)              -- Zufallszahl zwischen [0 und n%[
RIGHT$(a$,n%)
a%=RINSTR(s1$,s2$[,n])  -- tests if s2$ is contained in s1$, then      
                           returns start-position of s2$, else 0.
                           start comparison at pos. n (default=1)
                           start comarison at right

b=SIN(a)		-- Sinus
i%=SGN(a)		-- Vorzeichen (-1,0,1)
t$=SPACE$(i%)		-- gibt einen String
SPC(i%)
b=SQR(a)		-- Wurzel
b=SQRT(a)		-- Wurzel
t$=STR$(a[,b%,c%])
t$=STRING$(w$,i%)
adr%=SYM_ADR(#n,s$)     -- liefert Adresse des Symbols mit Namen s$ aus shared
                           Object File #n

TAB(i%)
b=TAN(a)		-- Tangens
b=TRUNC(a)

u$=UPPER$(t$)		-- liefert t$ in Grossbuchstaben

a=VAL(t$)		-- Wandelt String in Zahl, falls der String eine
			   Zahlndarstellung enthaelt.
i%=VAL?(t$)		-- Liefert die Anzahl der umwandelbaren Zeichen
a%=VARPTR(v)		-- Adresse der Variablen v



##############################################################################

Befehl: OPEN
============
Syntax:  OPEN mode$,[#]n%,f$[,port%]

Beschreibung:

Mit diesem Befehl werden Dateien (streams) geoeffnet. Es kann sich hierbei nicht
nur um regulaere Files handeln, sondern eskoennen auch spezielle Files und
Sockets geoeffnet werden. 

mode$  "O" = output (write only), "I" = input (read only), "U" = read and write
       "A" = append
       Der Zweite Buchstabe spezifiziert den Typ:
       ""   default ist regulaeres File
       "C"  Socket connect
       "S"  Socket listen
       "A"  Socket accept connection
       
f$     Filename oder Hostname
n%     Kanalnummer
port%  gibt den Port fuer die Verbindung (Socket) an.


Beispiele:
  OPEN "I",#1,"data.dat"    ---- Oeffnet File "data.dat" zum Lesen

  OPEN "UC",#1,"localhost",80 ---- Oeffnet Port 80 zum Lesen und Schreiben


#############################################################################


Befehl: CLOSE
=============
Syntax:  CLOSE [[#]n%]

Beschreibung:

Mit diesem Befehl wird ein zuvor geoeffneter Kanal geschlossen.

n%     Kanalnummer

Wird keine Kanal angegeben, werden alle offenen Kanaele geschlossen


#############################################################################

Funktion: ROUND
===============
Syntax: a=ROUND(b[,n])

Beschreibung:

Liefert auf n Nachkommastellen gerundeten Wert von b.
n<0: Es wird vor dem Komma gerundet

#############################################################################

Funktion: SWAP
===============
Syntax: a%=SWAP(b%)

Beschreibung:

Liefert Wert durch Vertauschen der High und Low-Words von b%.

Siehe auch: BYTE(), CARD(), WORD()
#############################################################################

Funktion: BYTE
===============
Syntax: a%=BYTE(b%)

Beschreibung:

Liefert untere 8 Bits von von b%. (identisch mit a%=b% AND 255)

Siehe auch: CARD(), WORD(), SWAP()
#############################################################################

Funktion: CARD
===============
Syntax: a%=CARD(b%)

Beschreibung:

Liefert untere 16 Bits von von b%. (identisch mit a%=b% AND (2^16-1))

Siehe auch: BYTE(), WORD(), SWAP()
#############################################################################

Funktion: WORD
===============
Syntax: a%=WORD(b%)

Beschreibung:

Liefert untere 16 Bits von von b% und erweitert Vorzeichenrichtig.

Siehe auch: BYTE(), CARD(), SWAP()
#############################################################################





BUGS:
=====

- Exponentialdarstellungen von Zahlen mit negativem Exponent (z.B. 2e-5) werden 
  vom Parser nicht verdaut. (Abhilfe: 2/1e5)

noch nicht alles implementiert.  Syntax nicht idiotensicher.

