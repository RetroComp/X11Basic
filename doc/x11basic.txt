***************************************************************
*             x11basic                 V. 1.01                *
*                   von Markus Hoffmann 1997                  *
*                                                             *
*                                                             *
* Programmversion vom 01.02.1999                              *
*                                                             *
***************************************************************

#########################
 Bedienungsanleitung: 
######################### 

Das Programm kann mit folgenden Parametern aufgerufen werden:  

xbasic <filename>   --- Basic-Programm ausfuehren  [input.bas]

-l                  --- Programm nur laden 
-e <kommando>       --- Basic Kommando ausfuehren 
--eval <ausdruck>   --- Num. Ausdruck auswerten  

Beispiel:

xbasic testme.bas
xbasic -e 'alert 1,"Hallo !",1," OK ",b'
xbasic --eval 1+3-4*3

X11-Basic als Daemon:
=====================
wird X11-Basic mit
xbasic --daemon
gestartet, so erscheint bei der Kommandoeingabe kein Prompt und es erfolgt kein 
Echo der Tastatureingabe.

X11-Basic als Shell:
====================
X11-Basic Programme koennen auch wie Shell-Scripts gestartet werden.
Hierzu installiert man xbasic in /bin/. Mit der Anweisung
#!/bin/xbasic
in der ersten Zeile des Scipts wird es als X11-Basic-Programm ausgefuehrt.



Kurzanleitung zu X11BASIC:
===========================

Variablenkonzept:
-----------------

Der interpreter kennt 64-Bit Floatingpoint Variablen, 32-Bit Integervariablen,
Zeichenketten und beliebigdimensionale Felder obengenannter Typen.
Eine Deklaration der Variablen ist nicht noetig (Ausser bei Feldern --> DIM),
da der Interpreter den Typ an der Endung der Variable erkennt:
Integervariablen tragen die Endung %, Zeichenketten ein $, felder ein ().
Variablen ohne Endung werden als float interpretiert.
Pointer sind Integer, Funktionsergebnisse werden durch @ gekennzeichnet
Logische Ausdruecke soind ebenfalls vom Typ Interger.
Typenumwandlungen werden bei Bedarf automatisch vorgenommen, wo dies moeglich
ist. 

Die Variablen werden dynamisch verwaltet, so sind beliebig grosse Zeichenketten
und Felder moeglich. Die Grenze ist hier nur der maximal allozierbare Speicher
und max. 31 Bit fuer die Indizierung. Das sollte vorerst ausreichen.


Beispiele:

Integer-Variablen:      i%=25
			a%=varptr(b$)
			b%=malloc(100000)
Float-Variablen:        a=1.2443e17
			b=@f(x)
Zeichenkettenvariablen: t$="Das ist ein Text"
Felder/Arrays:          i%(),a(),t$()

Logische Ausdruecke:    (a=2 AND b=5) sind vom Typ Integer (TRUE=-1, FALSE=0)


OPERATOREN
##########

Man unterscheidet zwischen numerischen, Zeichenketten- und Feld- bzw.
Matritzenoperatoren, je nachdem, ob das ergebnis der Operation eine Zahl oder
eine Zeichenkette ist.
 
-- Zeichenkettenoperatoren ---

+	Dier Verkettung von Zeichenketten.
	Dabei werden die durch + verbundenen Strings lückenlos
	aneinandergefügt.

	Beispiel: a$="X11", b$="-" und c$="BASIC", dann ergibt sich 
        d$=a$+b$+c$ die Zeichenkette "X11-BASIC" 

$()     Zeichenkettenfunktionen:
	z.B. LEFT$, RIGHT$, MID$, SPACE$, STRING$, STR$ ...

-- Numerische Operatoren --

Die numerischen Operatoen können in vier Kategorien gegliedert werden:

*	Arithmetische Operatoren

*	Vergleichsoperatoren

*	Logische Operatoren

*	Numerische Funktionen

-- Matritzenoperatoren --

Matritzenoperatoren oder allgemein Feld-Operatoren operieren auf Feldern.
Je nach Feldtyp und Dimension koennen sie unterschiedliche Bedeuting haben.

        $    F   I   D2 D3 Dn Sonstige Bemerkungen
+       *    *   *    *  *  *
-       -    *   *    *  *  *
*       -    *   *    *  -  -  M1=N2 , auch skalar
INV()   -    *   *    *  -  -  M=N
TRANS() *    *   *    *  -  -  M=N

Weiterhin gibt es Operatorn/Funktionen, die zwischen verschiedenen
Variablenklassen Operieren: z.B.
a%=INT(b), c=DET(d()), s=SMUL(a(),b()), a=NULL(2,4,5), ...

Insbesondere sei auf den Reduktionsoperator hingewiesen:
a(:,3) ist ein eindimensionaler Vektor, naemlich die Spalte Nr. 3 der
        Matrix a. 


-- Integer und Float-Variablen ---
()           Klammerung
+ - * /      Grundrechenarten
^            Potenz

MOD          Modulo
DIV          Ganzzahliger Teiler


Vergleichsoperatoren: = <> < > <= >=
====================================

Vergleichsoperatoren können zwischen zwei Ausdrüchen gleichen Typs stehen, also
zwischen Zeichenkettenausdruecken, numerischen Ausdruecken oder Feld-Ausdruecken.
Abhängig vom Wahrheitswert (wahr oder falsch) wird ein dem Vergleich entweder der
Wert -1 (wahr) oder 0 (falsch) zugeordnet.
(Da sich in jedem Fall eine Zahl ergibt, zählt auch der Vergleich von
Zeichenketten zu den numerischen Operatoren.)

Folgende Vergleichsoperatoren sind verfügbar:

	=	gleich
	>	größer als
	<	kleiner als
	<>	ungleich
	>=	größer oder gleich
	<=	kleiner oder gleich

Zum Vergleich von numerischen Ausdrücken sollen hier nur einige Beispiele
aufgeführt werden:

PRINT 3=1.5*2  übergibt den Wert  -1   (wahr)
PRINT 5>5      übergibt den Wert   0   (falsch)

Der Vergleich von Zeichenketten vollzieht sich nach folgenden Regeln: 

*	Zwei Zeichenketten sind gleich, wenn sie vollständig übereinstimmen.
	(Dabei werden alle Zeichen der Strings, auch Leerzeichen und Satzzeichen,
	verglichen. So gilt z.B. " 123 v fdh.-," = " 123 v fdh.-,")

*	Bein Größenvergleich zweier Strings wird folgendermaßen verfahren:
	Die Zeichenketten werden Zeichenweise verglichen, solange, bis der
	ASCII-Code des Zeichens des einen Strings kleiner ist als der des
	Zeichens  des anderen Strings, oder das Zeichenkettenende eines Strings
	erreicht wird. Dieser Ist dann kleiner als der andere.

	Beispiele:
	"X11">"X11"     ergibt  0
        "X11"<"x11"     ergibt -1
        "123"<"abc"     ergibt -1
        "123">"1234"    ergibt  0

Logische Operatoren: AND OR NAND OR NOT XOR EQV IMP 
====================================================

Mit Hilfe der logischen Operatoren können Ausdrücke oder Beziehungen zwischen
Ausdrücken miteinander verbunden werden.

In der Regel werden mit logischen Operatoren Wahrheitswerte verknüpft und als
Ergebnis wiederum Wahrheitswerte ausgegeben.
Dabei wird jedem numerischen Ausdruck ungleich 0 der Wahrheitswert 0 und jedem
Ausdruck, dessen Wert gleich 0 ist, der Wahrheitswert falsch zugeordnet.
Die von den Logischen Operatoren erzeugten Wahrheitswerte ergeben sich aus
der Bit-weisen Operation, wenn die Operanden als 32-Bit Integerwerte
angesehen werden. Deshalb gehoert zum Wahrheitswert 0 (falsch) der
Wahrheitswert -1 (wahr). Hierfür gibt es auch die Systemvariablen TRUE=-1
und FALSE=0. Dies kann man auch in numerischen Ausdrücken Verwenden, z.B.:
a=ABS(x=0)*100+ABS(x=1)*200   je nach dem Wert von x erhaelt die Variable a die
Werte 100 oder 200.

AND   Konjunktion
      Das Ergebnis von AND ist nur dann w, wenn beide Argumente w sind:

      A  |  B  |  A AND B
    -----+-----+-----------
      w  |  w  |    w
      w  |  f  |    f
      f  |  w  |    f
      f  |  f  |    f

      Beispiele:
      Print 3=3 AND 4>2        ergibt  -1 (w)
      Print 3>3 AND 5>3        ergibt   0 (f)

OR   Disjunktion
     Das Ergebnis von OR ist nur dann f, wenn beide Argumente f sind:

      A  |  B  |  A OR B
    -----+-----+-----------
      w  |  w  |    w  
      w  |  f  |    w
      f  |  w  |    w
      f  |  f  |    f
      
      Beispiele:
      Print "A"<"a" OR 3=5     ergibt  -1 (w)
      Print 2>7 OR 10=20       ergibt   0 (f)

XOR  Exclusives (oder ausschließendes) Oder
     Das Ergebnis von XOR ist  f, wenn die Argumente gleiche Wahrheitswerte
     haben:
      
      A  |  B  |  A XOR B   
    -----+-----+-----------
      w  |  w  |    f
      w  |  f  |    w
      f  |  w  |    w
      f  |  f  |    f

      Beispiele:
      Print 3=3 XOR 6=6     ergibt   0 (f)
      Print 3>5 XOR 3<5     ergibt  -1 (w)

NOT   Die Negation vertauscht Wahrheitswerte in ihr Gegenteil.

      A  |  NOT A
    -----+----------
      w  |   f 
      f  |   w  

      Beispiel:
      Print NOT 3=3      ergibt   0 (f)

IMP  Implikation
     Das Resultat der Operation ist dann falsch, wenn falsch auf wahr folgt. 
      
      A  |  B  |  A IMP B
    -----+-----+-----------
      w  |  w  |    w
      w  |  f  |    f
      f  |  w  |    w
      f  |  f  |    w

EQV  Äquivalenz 
     Dier Operation ist identisch mit (A IMP B) AND (B IMP A)
                                                                           
      A  |  B  |  A EQV B
    -----+-----+-----------
      w  |  w  |    w
      w  |  f  |    f
      f  |  w  |    f
      f  |  f  |    w

Die logischen Operatoren werden hauptsächlich dazu benutzt, um abhängig vom
Wahrheitswert verbundener Ausdrücke verschiedene Programmabläufe zu ermöglichen
(z.B. über die Befehle IF, WHILE, EXIT IF ...)
Logische Operatoren können aber auch dazu benutzt werden, um Bitfolgen zu
verknüpfen.

Strukturiertes Programmieren
============================

Der Interpreter nennt sich zwar Basic, jedoch gibt es gegenueber den 
Uralt-Basic-Dialekten Einschr"ankungen und Erweiterungen, die Strukturiertes
Programmieren erlaubt. Die Programme sind dann "ubersichtlicher.
Zeilennummern gibt es nicht und in jeder Zeile kann hoechstens eine Anweisung
stehen.
Spr"unge mit GOTO sind zwar m"oglich, aber nicht n"otig, da alle g"angigen
Schleifentypen zur Verf"ugung stehen, einschliesslich einem Befehl fuer weitere
Abbruchbedingungen (--> EXIT IF).
Selbstdefinierte Prozeduren und Funktionen mit Parameterliste und 
R"uckgabewerten jeden Typs sind m"oglich.
Die Programmstruktur eines Programms erlaubt also "ublicherweise ein Hauptteil,
z.B. eine Schleife, von der aus Unterprogramme aufgerufen werden.
Mit einem Kommando (--> MERGE) lassen sich so auch ganze Bibliotheken 
hinzuzubinden.


------ Anweisungen -------------
Allgemeines:

Nach Befehlen sind Kommentare erlaubt, die mit einem "!" vom Befehl abzusetzen
sind.
DO    ! Endlosschleife
LOOP  ! und nix drin

Diese Kommentare sind natuerlich nicht erlaubt nach DATA (und REM).

Der &-Operator gefolgt von einem Zeichenkettenausdruck evaluiert deren inhalt 
als Programm-Code.

Beispiel:

clr i
a$="print a$"
label1:
inc i
if i>10 
  b$="label2"
else
  b$="label1"
endif
&a$
goto &b$
label2:
end

erzeugt 10x die Ausgabe "print a$".
Dies fuehrt leicht zu unuebersichtlichem Code, aber schliesslich schmpft sich
der Interpreter ja Basic.



'                     -- Abkuerzung fuer REM
?                     -- Abkuerzung fuer PRINT
@                     -- Abkuerzung fuer GOSUB, bzw Funktionsaufruf
~                     -- Abkuerzung fuer VOID
!                     -- Kommentar hinter einer Zeile
&                     -- Indirektes Kommando


------ Systemvariablen ----------

TRUE                  -1
FALSE                 0
CRSCOL			n.n.
CRSLIN			n.n.
PI                    3.141592...
TIMER                 Systemtimer, float, erhoet sich mehr oder weniger 
                      kontinuierlich mit der Zeit, pro Sekunde um eins
STIMER                Dasselbe nur ganzzahlig
CTIMER                Dasselbe nur in Einheiten der CPU-Zeit
PC                    Zeilennr der naechsten auszufuehrenden Zeile
SP                    interner Stackpointer (Verschachtelungstiefe)
ERR                   Fehlernr des letzten Fehlers


MOUSEX                X-Koordinate der Mausposition relativ zum Fensterursprung
MOUSEY                Y-Koordinate der Mausposition
MOUSEK                Bitrepresentation der gedrueckten Maustasten, 
                      Button 1=Bit 0,Button 2=Bit 1 usw.
MOUSES                Status der Umschalttasten 

ENV$(n$)              Inhalt der Environmentvariable mit Namen n$
INKEY$                Inhalt des Tastaturpuffers
PRG$(i)               Programmzeile i
TERMINALNAME$         Devicename des Terminals
TIME$                 Aktuelle Zeit 
DATE$                 Aktuelles Datum

==================== Befehle ==============================

ADD a,b			-- gleiche Wirkung wie a=a+b
AFTER n,procedure       -- Nach n Sekunden wird die Procedure einmal ausgefuehrt
ALERT a%,b$,c%,d$,e%	-- Warn- und Infobox
ARRAYFILL a(),b         -- F"ullt ganzes Array mit Wert
ARRAYCOPY ziel(),b()    -- Kopiert ganzes Array inclusive Dimensionierung

BEEP			-- Warnton auf der Console Ausl"osen
BELL			-- dasselbe wie BEEP
BGET #f,a%,n%		-- Liest n% Bytes aus File #f nach Adresse a%
BLOAD f$,a%[,l%]	-- Laed File an Adresse
BMOVE q%,z%,n%          -- Kopiert n% Bytes grossen Speicherbereich
BOX x1%,y1%,x2%,y2%	-- Rechteck zeichenen
BPUT
BREAK                   -- entspricht EXIT IF true
BSAVE f$,a%,l%		-- Speichert l% Bytes ab Adresse a% in File f$

CASE
CHAIN
CIRCLE x%,y%,r%
CLEAR
CLEARW
CLOSE  [[#]n%]          -- I/O-Kanal schliessen
CLOSEW [[#]n%]          -- Fenster schliessen
CLR a,b%,c(),f$		-- Löscht Variableninhalte
CLS                     -- Loescht Textscreen/Console
color n%		-- Farbe auswählen
CONT                    -- Programmausfuehrung fortfahren

DATA 1,"Hallo",...	-- Definiert Konstanten im Programmcode
DEC var                 -- Decrementiere var
DEFAULT                 -- siehe SELECT * CASE * DEFAULT * ENDSELECT
DEFFILL
DEFLINE
DEFMOUSE i%		-- aendert das Erscheinungsbild des Mauscursors.
DEFTEXT
DIM
DIV 
DO * LOOP		-- Endlosschleife
DRAW [[x1,y1] TO] x2,y2
DUMP			-- Variablenliste
DUMP "@"                -- Liste der Funktionen und Prozeduren
DUMP ":"                -- Liste der Labels

ECHO {ON|OFF}           -- Programmzeilenechomodus ein-/ausschalten
ELLIPSE
ELSE
END			-- Programmende, kehrt zurueck in den Direktmodus
ENDFUNCTION
ENDIF
ENDSELECT
ERASE
ERROR n%                -- loest Fehler Nr. n% aus
EVENT
EVERY
EXIT IF a		-- Verlaesst Schleife wenn Bedingung a erfuellt ist

FFT a(),i		-- Fouriertransformation. i=-1 Ruecktransformation
			   Dim?(a()) muss Zweierpotenz sein.
FILESELECT titel$,pfad$,default$,f$  --
FLUSH [#n]              -- Output flushen

FOR * NEXT		-- For Next Schleife
FORM_INPUT t$
FUNCTION * ENDFUNC

GOSUB
GOTO
GRAPHMODE

HOME                    -- Textcursor home


IF * ELSE IF * ELSE * ENDIF 
INC
INFOW
INPUT

KEYEVENT

LET
LINE
LINEINPUT
LIST			-- Listet Programmcode
LOAD a$			-- Laed Programm (Dateiname in a$)
LOCAL
LOOP
LTEXT x%,y%,t$          -- Line-Text

MERGE
MOUSE
MOUSEEVENT
MOTIONEVENT
MOVEW
MUL a,b			-- a=a*b

NEW			-- Loescht alle Variablen und haelt Programmausfuehrung an.
NEXT
NOP
NOOP

ON * GOSUB     
ON BREAK GOSUB
ON ERROR GOSUB
OPEN mode$,#n,filename$	-- Oeffnet ein file
OPENW n
OUT #n,a

PAUSE sec		-- Haelt Programmausfuehrung fuer sec Sekunden an
PBOX  x1,y1,x2,y2
PCIRCLE x,y,r
PELLIPSE 
PLIST                   -- Formatiertes Listing
PLOT x,y                -- Punkt an Bildschirmkoordinate x,y zeichnen 
POKE a%,d
PRINT a;b$     -- Ausgewachsener BASIC-Standard-Befehl
PROCEDURE * RETURN
PUTBACK [#n,]a%   -- Zeichen mit ASCII-Code a% an inputkanal zurueckgeben

QUIT           -- Verlaesst den XBASIC-Interpreter

RANDOMIZE
READ
RELSEEK #n,d
REM Kommentar  -- Kommentarzeile
REPEAT * UNTIL
RESTORE
RESUME
RUN            -- Startet die Programmausfuehrung

SCOPE a(),typ,yscale,yoffset   -- Schnelles Plotten des Feldes a()
SCOPE y(),x(),typ,yscale,yoffset,xscale,xoffset   -- 2D Plot
SEEK
SHOWPAGE       -- Aktualisiert die Grafikausgabe
SUB
SWAP
SYSTEM t$      -- Führt Shell-Kommando aus

TEXT x,y,t$
TROFF
TRON

VERSION        -- Gibt xbasic Versionsinformationen aus
VOID a         -- Berechnet Ausdruck a und vergisst Ergebnis
VSYNC          -- Aktualisiert die Grafikausgabe

WORT_SEP t$,d$,mode,var1$,var2$

XLOAD          -- wie load, mit FILESELECTOR
XRUN           -- load und run, mit FILESELECTOR

=============== Funktionen  =========================
b=ABS(a)               -- Absolutbetrag
c=ADD(a,b)             -- Addiere, binaer
a%=ARRPTR(b())         -- Adresse des Array-Descriptors
a%=ASC(t$)             -- ASCII-Wert des ersten Zeichens von t$
b=ATN(a)               -- Arcustangens
b=ATAN(a)              -- Arcustangens
b=ATAN2(a,c)           -- Arcustangens alle 4 Sektoren

b$=BIN$(a%[,n%])       -- Stellt a% als Binaerzahl mit n% Stellen

t$=CHR$(a%)            -- Zeichen mit ASCII-Code a%
b=COS(a)               -- Cosinus
CVI * CVL * CVS * CVF * CVD

DFREE
DEG
DIM?
DPEEK

EOF(#n)                 -- -1 wenn Ende des Files #n erreicht, sonst 0
EXIST(fname$)           -- -1 wenn File fname$ existiert, sonst 0
b=EXP(a)		-- Exponentialfuntion

b=FRAC(a)		-- Liefert den nichtganzzahligen Anteil an a
FRE(n)			-- Keine Funtion, nur aus Kompatibilitaetsgruenden da.
a%=FORM_ALERT(n%,t$)

c%=GET_COLOR(r%,g%,b%) -- Alloziert eine Farbe in der Farbtabelle und gibt die
                          Nummer zurueck. Ist in der Farbtabelle kein Platz
			  mehr, so wird die Nummer derjenigen Farbe
			  zurueckgegeben, die der angeforderten am naechsten
			  kommt.

t$=HEX$(a%[,n%])        -- a% als Hexadezimalzahl

c%=INP(#n)		-- Liest ein Zeichen (Byte) vom Kanal. Kanal -2 ist stdin
i%=INP%(#n)
t$=INPUT$(#n,anz%)
INSTR
i=INT(a)		-- Schneidet die Nachkommastellen ab, liefert ganze Zahl

LEFT$(a$[,n%])
l%=LEN(t$)
b=LN(a)			-- Natuerlicher Logarithmus
p%=LOC(#n)		-- Position des Filepointers (--> SEEK/RELSEEK)
l%=LOF(#n)		-- Laenge des files
a=LOG(b)
a=LOG10(b)
LPEEK
LPOS

m=MAX(a,b,c,...)
m=MAX(f())
MID$
m=MIN(a,b,c,...)
m=MIN(f())

MKI$ * MKL$ * MKS$ * MKF$ * MKD$ 

o$=OCT$(d%,n%)

d%=PEEK(a%)
c%=POINT(x%,y%)         -- Liefert Farbwert des Punkts der Grafik im aktuellen Fenster
POS


RANDOM(n%)              -- Zufallszahl zwischen [0 und n%[
RIGHT$(a$,n%)


b=SIN(a)		-- Sinus
i%=SGN(a)		-- Vorzeichen (-1,0,1)
t$=SPACE$(i%)		-- gibt einen String
SPC(i%)
b=SQR(a)		-- Wurzel
b=SQRT(a)		-- Wurzel
t$=STR$(a[,b%,c%])
t$=STRING$(w$,i%)


TAB(i%)
b=TAN(a)		-- Tangens
b=TRUNC(a)

u$=UPPER$(t$)		-- liefert t$ in Grossbuchstaben

a=VAL(t$)		-- Wandelt String in Zahl, falls der String eine
			   Zahlndarstellung enthaelt.
i%=VAL?(t$)		-- Liefert die Anzahl der Umwandelbaren Zeichen
a%=VARPTR(v)		-- Adresse der Variablen v



##############################################################################

Befehl: OPEN
============
Syntax:  OPEN mode$,[#]n%,f$[,port%]

Beschreibung:

Mit diesem Befehl werden Dateien (streams) geoeffnet. Es kann sich hierbei nicht
nur um regulaere Files handeln, sondern eskoennen auch spezielle Files und
Sockets geoeffnet werden. 

mode$  "O" = output (write only), "I" = input (read only), "U" = read and write
       "A" = append
       Der Zweite Buchstabe spezifiziert den Typ:
       ""   default ist regulaeres File
       "C"  Socket connect
       "S"  Socket listen
       "A"  Socket accept connection
       
f$     Filename oder Hostname
n%     Kanalnummer
port%  gibt den Port fuer die Verbindung (Socket) an.


Beispiele:
  OPEN "I",#1,"data.dat"    ---- Oeffnet File "data.dat" zum Lesen

  OPEN "UC",#1,"localhost",80 ---- Oeffnet Port 80 zum Lesen und Schreiben


#############################################################################


Befehl: CLOSE
=============
Syntax:  CLOSE [[#]n%]

Beschreibung:

Mit diesem Befehl wird ein zuvor geoeffneter Kanal geschlossen.

n%     Kanalnummer

Wird keine Kanal angegeben, werden alle offenen Kanaele geschlossen


#############################################################################

Funktion: ROUND
===============
Syntax: a=ROUND(b[,n])

Beschreibung:

Liefert auf n Nachkommastellen gerundeten Wert von b.
n<0: Es wird vor dem Komma gerundet

#############################################################################

Funktion: SWAP
===============
Syntax: a%=SWAP(b%)

Beschreibung:

Liefert Wert durch Vertauschen der High und Low-Words von b%.

Siehe auch: BYTE(), CARD(), WORD()
#############################################################################

Funktion: BYTE
===============
Syntax: a%=BYTE(b%)

Beschreibung:

Liefert untere 8 Bits von von b%. (identisch mit a%=b% AND 255)

Siehe auch: CARD(), WORD(), SWAP()
#############################################################################

Funktion: CARD
===============
Syntax: a%=CARD(b%)

Beschreibung:

Liefert untere 16 Bits von von b%. (identisch mit a%=b% AND (2^16-1))

Siehe auch: BYTE(), WORD(), SWAP()
#############################################################################

Funktion: WORD
===============
Syntax: a%=WORD(b%)

Beschreibung:

Liefert untere 16 Bits von von b% und erweitert Vorzeichenrichtig.

Siehe auch: BYTE(), CARD(), SWAP()
#############################################################################





BUGS:
=====

- Exponentialdarstellungen von Zahlen mit negativem Exponent (z.B. 2e-5) werden 
  vom Parser nicht verdaut. (Abhilfe: 2/1e5)

noch nicht alles implementiert.  Syntax nicht idiotensicher.

