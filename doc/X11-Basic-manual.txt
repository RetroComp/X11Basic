
        ##     ##   #	#	 ######
         ##   ##   ##  ##	 ##   ##		    ##
          ## ##   ### ###	 ##   ##
           ###     ##  ## #####  #####     #####    #####  ####   ####
          ## ##    ##  ##	 ##   ##       ##  ##	    ##   ##  ##
         ##   ##   ##  ##	 ##   ##   ######   ####    ##   ##
        ##     ##  ##  ##	 ##   ##  ##   ##      ##   ##   ##  ##
        ##     ##  ##  ##	 ######    ######  #####   ####   ####
 
        ###############################################################
  
 
 		    		  VERSION 1.10

 		       (C) 1997-2004 by Markus Hoffmann
 		    	 (kollo@users.sourceforge.net)
 		    (see http://x11-basic.sourceforge.net/)

			      ALL RIGHTS RESERVED
 	THIS PROGRAM IS PROVIDED "AS IS" WITHOUT A WARRANTY OF ANY KIND


             See the file `COPYING' for licensing information

          Last change to this file:  Sa Feb 28 01:13:18 CET 2004

       ==>							    <==
          X11-Basic is a  comprehensive  non-standard  Basic  inter­
          preter  with  full  X  capability that integrates fratures
          like shell scripting, cgi-Programming and  full  graphical
          visualisation  into  the  easy  to learn basic language on
          moden computers.

          The syntax is most similar to the old GFA-Basic  ATARI  ST
          implementation.  Old gfa-programs should run with only few
          changes.
       ==>							    <==


About this document

      This   document	describes  the  features of X11-Basic. You will
      find information about the  X11-Basic  interpreter  (the  program
      xbasic  under  Unix  or  xbasic.exe under Windows) as well as the
      language itself. For a more compact description you may  want  to
      read  the  x11basic(1)  man-page or the man-page of the X11-Basic
      pseudo compiler xbc(1).

      The latest information and updates and new versions of  X11-Basic
      can be found at http://x11-basic.sourceforge.net/.

       



 FEATURES 
 ======== 
 Structured-BASIC-Interpreter 
 - with X11 graphic capabilities                   
 - without line-numbers                           
 - GOTO / GOSUB-labels are symbolic names         
 - Structure elements:           - A self compiling Pseudo-compiler is available
     WHILE - EXIT IF - WEND      - Many sample programs are available
     REPEAT - EXIT IF - UNTIL    - can be used as a shell
     DO - EXIT IF - LOOP         - can be used to write cgi-Scripts
     IF - ELSE IF - ELSE - ENDIF                   
     FOR - EXIT IF - NEXT                          
     PROCEDURE() - RETURN                  
     FUNCTION() - RETURN - ENDFUNCTION                   
 - Variable types indicated by appendix to name:  
     varname     REAL (double)                    
     varname%    INTEGER (long)                   
     varname$    STRING                   
 - PROCEDURE and FUNCTION can have formal parameters 
             and local variables                  
 - DEFFN defines an inline-function (*)               
 - integrated graphic instructions
					      (*) not implemented yet


1. ABOUT X11-Basic

1.1 Copyright information

    X11-Basic is free software and distributed under the GNU License.
    Read the file COPYING for details.

1.2 Abstract

    X11-Basic is a comprehensive non-standard Basic interpreter  with
    full  X capability that integrates features like shell scripting,
    cgi-Programming and full graphical visualisation into the easy to
    learn basic language on modern computers.

    The  actual implementation runs on Unix workstations (like HP/UX,
    DEC alpha and maybe others) and Linux-PCs with the X-Window  sys­
    tem.  A  MS-Windows  version  has been started. Also Hand-held PC
    Versions or adaptations to VxWorks are actually been thought  of.

    X11-Basic  is  as  well suited to novices as programming wizards,
    and is appropriate for virtually all programming tasks. For  sci­
    ence and engineering X11-Basic has already prooved its capability
    of handling complex simulation and control problems.  For  system
    programs,  X11-Basic has high level language replacements for low
    level programming features that are much easier to  read,  under­
    stand,  and maintain. For all applications, X11-Basic designed to
    support rapid development of compact, efficient, reliable,  read­
    able, portable, well structured programs.

    The  X11-Basic  environment  contains  a library of GEM GUI func­
    tions. This makes writing GUI programs in  X11-Basic  faster  and
    easier than programming with native GUI tools.

1.3 Structured Programming

    X11-Basic  is  a  structured programming language. Structure is a
    form of visual and functional encapsulation  in  which  multiple-
    line  sections of program look and act like single units. The be­
    ginning and end of blocks are marked by descriptive  keyword  de­
    limiters.  Lines within blocks are generally indented to make the
    block visible.

1.4 Usage

    command line parameters are as follows:

    xbasic <filename>	--- run Basic-Programm [input.bas]

    -l  		--- load only, don't execute
    -e <kommando>	--- excecute basic command
    --eval <ausdruck>	--- evaluate numerical expression
    --daemon		--- switch off prompting and echoing

    Examples:

    xbasic testme.bas
    xbasic -l dontrunme.bas
    xbasic -e 'alert 1,"Hallo !",1," OK ",b'
    xbasic --eval 1+3-4*3

1.5.1 X11-Basic as daemon:

    The  commandline option --daemon forces the interpreter to run in
    daemon-mode (with no terminal connected). No prompt is given  and
    the input is not echoed back.

    Example:
      To  run  the X11-Basic interpreter on a tcp-socket on port
      1371 create a new user called xbasic and insert
      --- in /etc/inetd.conf: ---
      xbasic stream tcp nowait xbasic /usr/sbin/tcpd /bin/xbasic --daemon
      --- in /etc/services: ---
      xbasic	      1371/tcp
      ---
      Please note that this is not recommended since xbasic would open
      several security holes on your system.

1.5.2 X11-Basic as shell:

	X11-Basic programs can be excecuted like shell scripts.

	Make sure that the very first line of your X11-Basic program 
	starts with the characters '#!' followed by the full pathname 
	of the X11-Basic inperpreter xbasic (e.g. '#!/usr/bin/xbasic'). 
	This she-bang-line ensures, that your Unix will invoke xbasic to 
	execute your program. Moreover, you will need to change the
	permissions of your X11-Basic program, e.g. chmod 755 myprog. 
	After that your program can siply be executed from your shell 
	and the interpreter works in the background like shells do. 

1.5.3 Using Syntax highlighting with nedit

    If  you  like  to use nedit as your faforite editor, a nedit.defs
    file comes with this package. This eanables  syntax  highlighting
    for X11-Basic programs in nedit.
--------------------------------------------------------------------------------

3. The pseudo compiler

  The X11-Basic package is shipped with a pseudo compiler, which
  makes  stand-alone binaries out of Basic source code. Actually this
  "compiler" is not a real compiler, since the source code is still
  interpreted on runtime. But the source code is linked to the
  X11-Basic library so there results one  independant executable.
  Another advantage is that it is quite hard to extract a full
  running *.bas File from this binary since the code is compressd in
  a way. 

  You can find the compiler in examples/compiler/xbc.bas. Yes, the
  compiler compiles itself. Yust make sure you have built the shared
  library  libx11basic.so and the library for static linking before 
  (make lib; make x11basic.a) and moved it to /usr/lib. Then do

  xbasic xbc.bas

  Please note: If you link your programs dynamically, you will
  eventually have to compile them again when the libx11basic.so will
  have changed due to a version update of your X11-Basic package.


--------------------------------------------------------------------------------

4. The WINDOWS Version of X11-Basic

Invocation

   After you have run the setup program, X11-Basic can be invoked in three
   ways:

   1. Choose "X11-Basic" from the start-menu: xbasic.exe will come up with a       
      console window and wait for commands to be typed in right away.
   2. Click with the right mousebutton on your desktop. Choose "new" from the 
      context-menu that appears; this will create a new icon on your desktop. 
      The context-menu of this icon has three entries "Execute", "Edit" and   
      "View docu" (which shows the embedded documentation, if any); a         
      double-click executes the program.                                      
   3. Create a file containing your X11-Basic-program. This file should have    
      the extension ".bas". Double-click on this file then invokes X11-Basic,   
      to execute your program.                                                

--------------------------------------------------------------------------------

5. The ANSI-Basic to X11-Basic converter

You now will find a simple ANSI-Basic to X11-Basic converter (bas2x11basic.bas)
in the /examples/compiler/ directory. It helps convertig old (real) Basic
Programs with line numbers and multiple commands per line to the X11-Basic
structure.  Because there are so many different BASIC Version aroud, in most
cases you will  have to edit these files produced manually. But most of the
work will already  have been done by this converter.

Example:

xbasic bas2x11basic.bas ansibasic.bas -o newname.bas

For further options try xbasic bas2x11basic.bas --help and read the man-page
bas2x11basic(1).
--------------------------------------------------------------------------------

2. Description of the X11-Basic language

2.1 Variables

    The  X11-Basic  interpreter uses 64-bit floating point variables,
    32-bit integer variables, character strings and arrays  of  these
    variables  of arbitrary dimension. A declaration of the variables
    and of their type is not necessary (except for arrays  -->  DIM),
    because  the interpreter recognizes the type of the variable from
    the suffix:  Integer  variables  have  the  suffix  %,  character
    strings a $, arrays a (). Variables without suffix are treated as
    float. Pointers are integers, function calls  are  marked  by  @.
    Logical expressions are also of type integer.

    At the moment, X11-Basic only recognizes 2 kind of vars;  Strings 
    and Doubles.

!!! The integers are not yet fully implemented.  So please do not use 
!!! them at the moment.

    Variable  names  and  commands  are  case  insensitive.  Names of 
    variables  are  limited  of  a  number  of  characters  or digits 
    specified  in  defs.h  (default 64)  and  have  to  begin  with a 
    character. Each name is bound to only one kind of variable; A$ is 
    a whole different variable (value) then A which is different from 
    A(1,1) or A$(1,1).

    Space between commands will be ignored, but note that no space is 
    allowed between the name of a variable or command and  the '(' of 
    its parameter list. So, ASC("A") is good, ASC(    "A"     ) also,
    but ASC ("A") isn't.

  Examples:

 	     integer variables:    i%=25
	     			   a%=varptr(b$)
	     			   b%=malloc(100000)
 	     float variables:	   a=1.2443e17
	     			   b=@f(x)
 	     character strings:    t$="Hello everybody !"
 	     fields and arrays:    i%(),a(),t$(),
	                           a()=[1,2,3,4;6,7,8,9]


Strings

    X11-Basic string variables automatically  resize to hold whatever 
    length  string  is  assigned to them.  A wealth of intrinsics and 
    functions are provided to support efficient string processing.  

Arrays

    X11-Basic   arrays   can  contain  variables  of  any  data type, 
    including strings. All arrays, even multi-dimensional arrays, can 
    be redimensioned without altering the contents. A special feature 
    of X11-Basic is the implicit dimensioning of arrays and the existance of 
    array constants. You may define an array by using the DIM command.
    You might also define the array by an assignment like
    a()=b() if b() already has been DIMed or by
    a()=[1,2,3,4;6,7,8,9] asigning an array constant. (In this
    example a 2 dimensional array will be created and the rows are 
    separated by ';').

Subroutines

    Subroutines are blocks of code that can be called from  elsewhere 
    in  a function.  Subroutines  can take  arguments  but  return no 
    results.  They  can  access  all variables available but also may 
    have local variables (--> LOCAL).

Functions

    X11-Basic  functions  are fully  encapsulated and bullet-proof by 
    default. Variables  are global unless  declared local.  For local 
    variables  changes  outside  a function have no effect within the 
    function.  Functions arguments can be variables and arrays of any 
    data types.  Functions can return variables of any data type.  By 
    default, arguments are passed by value. 

2.2 Operators

    X11-Basic provides operators for numerical expressions, character 
    strings and arrays of either type and any dimension.

-- operators for character strings ---

+	 conjunction
	 links two strings together.

	 Example: suppose a$="X11", b$="-" and c$="BASIC", so 
         d$=a$+b$+c$ results in "X11-BASIC" .

< <= = => >  comparison functions belong to numerical (boolean) functions
	     because the result is a nuber


-- numerical operators --

*	arithmetical operators:  ^ * / + - 
*	comparison operators:  = <> < > <= >=
*	logical operators:     NOT AND OR XOR ...
*	built-in and user defined functions:   ()  @()

-- operators for arrays --

Matritzenoperatoren oder allgemein Feld-Operatoren operieren auf Feldern.
Je nach Feldtyp und Dimension können sie unterschiedliche Bedeutung haben.

	   	   $	F   I	D2 D3 Dn  Sonstige Bemerkungen
	   +	   *	*   *	 *  *  *
	   -	   -	*   *	 *  *  *
	   *	   -	*   *	 *  -  -  M1=N2 , auch skalar
	   INV()   -	*   *	 *  -  -  M=N
	   TRANS() *	*   *	 *  -  -  M=N

Weiterhin gibt es Operatorn/Funktionen, die zwischen verschiedenen
Variablenklassen Operieren: z.B.
a%=INT(b), c=DET(d()), s=SMUL(a(),b()), a()=NULL(2,4,5), ...

Insbesondere sei auf den Reduktionsoperator hingewiesen:
b()=a(:,3) ist ein eindimensionaler Vektor, nämlich die Spalte Nr. 3 der
        Matrix a. 


Rules for comparison of strings: 

*	Two strings are equal if all the characters inside are identical
	(also spaces and punctuation marks).
  Example:
	" 123 v fdh.-," = " 123 v fdh.-,"

*	The comparison of size operates also character by character until one
	of them is smaller or a the strings ends first, this is the smaller
	one.


  Examples:

	"X11">"X11"     result:  0
        "X11"<"x11"     result: -1
        "123"<"abc"     result: -1
        "123">"1234"    result:  0

logical operators: AND OR NAND OR NOT XOR EQV IMP 
=================================================

Mit Hilfe der logischen Operatoren können Ausdrücke oder Beziehungen zwischen
Ausdrücken miteinander verbunden werden.

In der Regel werden mit logischen Operatoren Wahrheitswerte verknüpft und als
Ergebnis wiederum Wahrheitswerte ausgegeben.
Dabei wird jedem numerischen Ausdruck ungleich 0 der Wahrheitswert >wahr< und jedem
Ausdruck, dessen Wert gleich 0 ist, der Wahrheitswert >falsch< zugeordnet.
Die von den logischen Operatoren erzeugten Wahrheitswerte ergeben sich aus
der Bit-weisen Operation, wenn die Operanden als 32-Bit Integerwerte
angesehen werden. Deshalb gehört zum Wahrheitswert 0 (falsch) der
Wahrheitswert -1 (wahr). Hierfür gibt es auch die Systemvariablen TRUE=-1
und FALSE=0. Dies kann man auch in numerischen Ausdrücken Verwenden, z.B.:
a=ABS(x=0)*100+ABS(x=1)*200   je nach dem Wert von x erhält die Variable a die
Werte 100 oder 200.

Die logischen Operatoren werden hauptsächlich dazu benutzt, um abhängig vom
Wahrheitswert verbundener Ausdrücke verschiedene Programmabläufe zu ermöglichen
(z.B. über die Befehle IF, WHILE, EXIT IF ...)
Logische Operatoren können aber auch dazu benutzt werden, um Bitfolgen zu
verknüpfen.

      Example:
      PRINT 9 AND 5      Result:   1




1.1 Math Functions

1.1.1 Introduction

  The math function library contains a comprehensive set of mathematics
  functions, including:

	trigonometric
	arc-trigonometric
	hyperbolic
	arc-hyperbolic
	logarithmic  ( base e and base 10 )
	exponential  ( base e and base 10 )
	miscellaneous  ( square root, power, etc. )

  Some math functions are defined on Vectors and Matrices.


1.1.2 Angles

  Angles are always radians, for both arguments and return values.

  To convert degrees to radians, use RAD().
  To convert radians to degrees, use DEG().

2.3 Strukturiertes Programmieren

  Even if the interpreter is BASIC, there are restraints and extansions to it
  for a structured programming with a better overall view. There are no line
  numbers and every line holds only one instruction. Jumps with GOTO are
  possible but not necessary. All the well-known loops are available including
  an additional command for discontinuation (--> EXIT IF). Procedures and
  functions with return values of any type can be defined. So a program can
  contain a main part to call the subfunctions, for example in side of a loop.
  Whole libraries can be added with the merge command (--> MERGE).


------ general syntax  ------------------
link two lines together (with '\' at end of line): 
PRINT "Hello,";   \
      " thats it"
will be treated as:
PRINT "Hello,";" thats it"


------ end of line comments -------------


After the instructions comments are allowed that are prefaced with '!'.

Examples:
DO    ! endless loop
LOOP  ! with nothing inside

This comments can not be used after DATA (and REM).


------ the &-operator -------------------

The &-operator followed by a string evaluates it for program code.


Example:

REM generate ten times the command 'print a$'
clr i
a$="print a$"
label1:
inc i
if i>10 
  b$="label2"
else
  b$="label1"
endif
&a$
goto &b$
label2:
end

To act like this can create an unreadable code but this is BASIC.


String Variables

  String variables are sequences of characters.  Strings generally
  contain ASCII text, but can hold arbitrary byte sequences.  Strings
  are automatically elastic, meaning they automatically resize to
  contain whatever number of bytes are put into them.  When a string
  resizes, its location in memory may change, as when a longer string
  is assigned and there is insufficient room after the string to
  store the extra bytes.  

   Shortcuts

       '    -- REM
       ?    -- PRINT
       @    -- GOSUB
       ~    -- VOID
       !    -- comment at the end of a line
       &    -- indirect command


   Numbers
       Numbers may preceed 0x to represent hex values.

Adress spaces:

  The full accessible Program memory can be accessed by PEEK/POKE,
  LPEEK/LPOKE, DPEEK/DPOKE. Be careful. You can manipulate all
  symbols of the interpreter and or dynamically linked libraries and
  your program. Adress spaces belonging to other programs which are
  not shared memory blocks can not be accessed. You will get a
  segmentation fault on trying this.


The very basic commands: print, input and others

   The print-command is used to put text on the text screen. Here, the term
   text screen stands for your terminal (under Unix) or the console window
   (under Windows).

   At the bottom line, print simply outputs its argument to the text window.
   However, you may use advanced features
   like printing colors.

   You may ask the user for input with the input-command; use inkey$ to get
   each key as soon as it is pressed.

Control statements: loops, if and switch

   Of course, X11-Basic has the goto- and gosub-statements; you may go to a
   label. goto,
   despite its bad reputation ([goto considered harmful]), has still its good
   uses; however in many cases you are probably better off with loops like
   repeat-until, while-wend or do-loop; you may leave any of these loops with
   the break- or exit if-statement.

   Decisions can be made with the if-statement. It extends up to the final
   endif and may use some of the keywords else or else if.

   If you want to test the result of an expression against many different
   values, you should probably use the switch-statement.

Graphics: Drawing and painting

   A Graphics window will be automatically opened by using the first graphic
   command in your program. Witout using any graphic commands no X11-Server is
   needed at all and your programs also run under a text console or as a daemon
   or as CGI scripts. But if you want to draw anything  with e.g. line, circle 
   or box, control the MOUSE pointer, the keyboard or use the graphical user
   interface with e.g. ALERT or MENU. All graphic output can be done in fill
   color which can be set with the get_color() and the color statements. 
   Moreover, there can be up to 16 different graphic windows opened at a time.
   Please Note that all graphics is displaied after a SHOWPAGE command only.
   This allows fast animations.

   To allow for some animated bitmap graphics, X11-Basic
   offers the commands get and put, which retrieve rectangular regions
   from the graphics-window into a string or vice versa.


Reading from and writing to files

   Before you may read or write a file, you need to open it; once you are
   done, you should close it. Each open file is designated by a simple
   number, which might be stored within a variable and must be supplied if
   you want to access the file. This is simply done by putting a hash ('#')
   followd by the number of the file after the keyword input (for reading
   from) or print (for writing to a file) respectively.

   If you need more control, you may consider reading and writing one byte at
   a time, using the multi-purpose commands INP() and OUT.

The internet connection: Special Files and Sockets

   With the OPEN command it is also possible to open a pipe or a real internet 
   connection. Please refer to the example programs.

String processing

   X11-Basic has the usual functions to extract parts from a string: LEFT$,
   MID$ and RIGHT$. 
   
   If you want to split a string into tokens you should use the functions
   WORT_SEP or SPLIT.

   There is quite a bunch of other string-processing functions like UPPER$()
   (converting to upper case), INSTR() (finding one string within the other),
   CHR$() (converting an ascii-code into a character), GLOB (testing a string
   against a pattern) and more. 

Arithmetic

   X11-Basic handles numbers and arithmetic: You may calculate trigonometric
   functions like sin or atan, or logarithms (with LOG). Bitwise operations,
   like and or or are available as well MIN() or MAX() (calculate the minimum or
   maximum of its argument) or MOD or INT() (reminder of a division or integer
   part or a number).

Data and such

   You may store data within your program within data-statements; during
   execution you will probably want to read it into arrays.
   Also the assignment of constant to arrays may be used to store data in
   your program and last but not least the INLINE$() Function may be used to store
   huge binary data segments.

Other interesting commands.

     * X11-Basic programs may start other programs with the commands system and
       system$().

     * The ENV$() function allows access to environment variables.

     * The current time or date can be retrieved with (guess what !) time$
       and date$.


 BASIC Operators

    X11-BAsic recognizes the following operators, in order of  falling
    precedence  (the  precedence  of  BASIC  operators  affects  the  order of
    expression evaluation):

           Operator      Description                    
           ---------------------------------------------
           ( )        |  Parenthetical expression       
           ^          |  Exponent                       
           -          |  Sign (negation)                
           +          |  Sign                           
           NOT        |  Bitwise not                    
           /          |  Divide                         
           *          |  Multiply                       
           \          |  Integer division               
           MOD        |  Modulus (rest of division)     
           +          |  Add                            
           -          |  Subtract                       
           <<         |  Bitwise shift to the left      
           >>         |  Bitwise shift to the right     
           =          |  Logical "equals"               
           <>         |  Logical "not equal"            
           <          |  Logical "less than"            
           >          |  Logical "Greater than"         
           <=         |  Logical "less than or equal"   
           >=         |  Logical "greater than or equal"
           AND        |  Bitwise and                    
           OR         |  Bitwise or                     
           XOR        |  Bitwise xor                    
           IMP        |  Implies                        
           EQV        |  Equivalence                    
	    =         |  assignment


\section{Expressions and Conditions}
\begin{description}
\item[Expressions] are needed 
to  calculate  values. The simplest expression  is  a numerical or string 
constant.  More  complex  expressions  may  contain constants, variables, 
operators, function
calls and possibly parentheses. The expression format   used   by
X11-Basic  is  identical  with that of many other BASIC packages:
The operators have precedence of the usual order and you can  alter  the   
order   of   operator  evaluation  using  parentheses.
Here is an example numeric expression  following  after  a  PRINT
statement:

\begin{verbatim}
PRINT (X-1)*10+SIN(x)
\end{verbatim}

\item[Conditions] and  expression are the same in X11-Basic, FALSE is defined
       as 0 and TRUE as -1.  Those  definitions  are  defined  in
       defs.h  and could be changed, but that is not recommended.
       Because BASIC doesn't have seperate  boolean  operators
       for  conditions and expressions, using an boolean operator
       (AND,OR,XOR,NOT) may give spurious results. When  on  each
       site  a  value  of  an 0 or -1 is used, it's assumed as an
       condition, if it's not, it considered an expression. Problems  
       could occure if you use boolean operators with negative 
       numbers, but that is also unrecommended  because  the
       outcome of such an expression is highly platform depended.
\end{description}

\section{General Syntax}
\subsection*{Appending lines}
Since for a structured programming language like X11-Basic each line must not contain more than 
a single command, some restrictions apply for the program code.

With many editors a limitation on the maximal line length applies  (e.g. 4096
characters/line). In X11-Basic a single command may in very rare cases consist
of more than 4096 characters (e.g. by assigning an array constant to an array).
Therfor a possibility of plitting lines into two (or more) has been
implemented. If the last character of a line is a \verb|'\'| (it must be really
the last character of the line and may not be followed by a space character!),
the following line will be appended to this line by replacing the 
\verb|'\'| and the following newline character by spaces.\\
{\bf Example:}
\begin{verbatim}
PRINT "Hello,";   \
      " thats it"
\end{verbatim}
will be treated as:
\begin{verbatim}
PRINT "Hello,";" thats it"
\end{verbatim}

Please note: The \verb|'\'| character must be placed at a position within the command where
a space would be allowed, too.

\subsection*{Comments}

A comment can be inserted into your program code with the REM command or the abbreviation 
\verb|'|. Also the \verb|'#'| as a first character of the program line
reserves the rest of the line for a comment.
If you want to place comments at the end of a line, they have to be
prefaced with \verb|'!'|.\\
{\bf Example:}
\begin{verbatim}
' This is a demonstration of comments
DO    ! endless loop
LOOP  ! with nothing inside
\end{verbatim}
These end of line comments can not be used after DATA (and REM).


\section{The very BASIC commands: PRINT, INPUT, IF and GOTO}

The {\bf PRINT}-command is used to put text on the text screen. Text screen
means  your terminal (under Unix) or the console window (under Windows). PRINT
is used to generate basic output, e.g. text, strings,  numbers, e.g. the result
of a calculation. Some basic formatting is possible.

   With the {\bf INPUT} command you let the user input data, p.ex. numbers or text.

The {\bf IF} command let the program do different things depending on the result of
a calculation. 

With {\bf GOTO} you can branch to a different part of your program. 
GOTO, despite its bad reputation ([goto considered harmful]), has still its 
good uses.

Besides these four very basic commands (which are really standard basic
commands,  and you can already write very handy calculations with only these
four commands) X11-Basic has many more features which make life easier and your
programs more user friendly.

\section{Graphics: Drawing and painting}

A graphics window will be automatically opened when the first graphic
command appears in your program. Without using any graphic commands no X11-Server is
needed at all and your programs also runs under a text console or as a daemon
or as CGI scripts. But if you want to draw anything  with e.g. LINE, CIRCLE  or
BOX, control the MOUSE pointer, the keyboard or use the graphical user
interface with e.g. ALERT or MENU, a graphic window will open with the default 
geometry \verb|640x400|. All graphic output can be done in full color which can
be set with the GET\_COLOR() and the COLOR statements.  Moreover, there can be
up to 16 different graphic windows opened at a time. Please Note that all
graphics is displaied after a SHOWPAGE command only. This allows fast
animations.

   To allow for some animated bitmap graphics, X11-Basic
   offers the commands GET and PUT, which retrieve rectangular regions
   from the graphics-window into a string or vice versa.


\section{Reading from and writing to files}

Before you may read from or write to a file, you need to open it; once you are
done, you should close it. Each open file is designated by a simple number,
which might be stored within a variable and must be supplied to the PRINT and
INPUT commands if you want to access the file. 

If you need more control, you may consider reading and writing one byte at
a time, using the multi-purpose commands INP() and OUT, or reading the whole file
as a binary block with BLOAD.

\section{Internet connections, special files and sockets}

   With the OPEN command it is also possible to open a pipe or a real internet 
   connection. Please refer to the example programs.

\section{String processing}

   X11-Basic has the usual functions to extract parts from a string: LEFT\$,
   MID\$ and RIGHT\$. 
   
   If you want to split a string into tokens you should use the functions
   WORT\_SEP or SPLIT.

   There is quite a bunch of other string-processing functions like UPPER\$
   (converting to upper case), INSTR() (finding one string within the other),
   CHR\$ (converting an ascii-code into a character), GLOB() (testing a string
   against a pattern) and more. 

\section{Arithmetic}

   X11-Basic handles numbers and arithmetic: You may calculate trigonometric
   functions like SIN() or ATAN(), or logarithms (with LOG()). Bitwise operations,
   like AND or OR are available as well MIN() or MAX() (calculate the minimum or
   maximum of its argument) or MOD or INT() (reminder of a division or integer
   part or a number). Many other statements give a complete set of math functions.

\section{Data within the program}

   You may store data within your program within DATA-statements; during
   execution you will probably want to READ it into variables or arrays.
   Also the assignment of constant to arrays may be used to store data in
   your program and last but not least the INLINE\$() function may be used to store
   huge binary data segments.

\section{Other features}
\begin{itemize}
     \item X11-Basic programs may start other programs with the commands 
     SYSTEM and SYSTEM\$().

     \item The ENV\$() function allows access to environment variables.

     \item The current time or date can be retrieved with (guess what !) TIME\$
       and DATE\$.
       
     \item The interpreter allows self modifying code.  
\end{itemize}

  reserved variable names

       There are some reserved variables. Some Keywords  may  not
       work as varable names as well. Although there is no check­
       ing done, parsing errors could  occure.   Please  try  the
       command  LET in such cases. In general, as long as an end­
       ing of an variable name is different then any  command  or
       keyword, it's usable as name.

    Reserved and system variables are:

       TRUE          -1
       FALSE         0
       PI            3.141592...
       TIMER         unix system timer, float, seconts
       STIMER        integer system timer
       CTIMER        system timer in units of CPU-time
       PC            line number of next line to be processed
       SP            internal stack pointer
       CRSCOL			n.n.
       CRSLIN			n.n.
       ERR           error number of last error

       MOUSEX        x coordinate of mouse position relative to origin of 
                     the graphics window
       MOUSEY        y coordinate of mouse position
       MOUSEK        mouse button state
                     Button 1=Bit 0,Button 2=Bit 1 etc.
       MOUSES        state of the shift,alt,ctrl,caps keys

       INKEY$        content of the keyboard-buffer
       TERMINALNAME$ device name of the standard terminal
       TIME$         current time
       DATE$         todays date

commands

       AFTER n,procedure       -- execute procedure after n seconds
       ARRAYFILL a(),b         -- fills array with value
       ARRAYCOPY dest(),souce() -- copies array including Dimensionierung

       BEEP                    -- Beep (on TTY/console)
       BELL                    -- same as BEEP
       BGET #f,a,n             -- read n bytes from file #f to adress a
       BLOAD f$,a%[,l%]        -- reads entire file (given by name) to adress a
       BMOVE q,z,n             -- copies a block of n bytes from adress q to z
       BPUT #f,a,n             -- writes n bytes from adress a to file/channel f
       BREAK                   -- entspricht EXIT IF true
       BSAVE f$,a,l            -- saves l bytes in memory at adress a to file f$

       CALL adr%[,par,...]     -- see EXEC
       CASE const              -- see SELECT * CASE * DEFAULT * ENDSELECT
       CHAIN bas$              -- executes another basic program
       CLEAR                   -- clear and remove all variables
       CLOSE  [[#]n%]          -- close file, I/O channel or link
       CLR a,b%,c(),f$         -- clear variables
       CLS                     -- clear (text)screen
       CONT                    -- continue (after STOP)

       DATA 1,"Hallo",...      -- define constants
       DEFAULT                 -- see SELECT * CASE * DEFAULT * ENDSELECT
       DIM                     -- Declarate array
       DO * LOOP               -- Loop
       DPOKE adr,word          -- write short int word to adr
       DUMP                    -- lists all used variable names
       DUMP "@"                -- list of Funktionen und Prozeduren
       DUMP ":"                -- list of all labels
       DUMP "#"                -- list of open Files
       DUMP "K"                -- list of implementierten Kommandos
       DUMP "F"                -- list of internal functions

       ECHO {ON|OFF}           -- same as TRON * TROFF
       EDIT                    -- call default editor to edit program
       ELSE                    -- see IF * ELSE * ENDIF
       END                     -- program end, enter interactive mode
       ENDFUNCTION             -- see FUNCTION * ENDFUNCTION
       ENDIF                   -- see IF * ELSE * ENDIF
       ENDSELECT               -- see SELECT * CASE * DEFAULT * ENDSELECT
       ERASE a()[,b$(),...]    -- erase arrays
       ERROR n                 -- execute error number n
       EVERY n,procedure       -- invokes procedure every n seconds
       EXEC adr[,var[,...]]    -- call a C subroutine at pointer adr.
       EXIT IF a               -- exit loop if condition a is TRUE

       FLUSH [#n]              -- flush output
       FOR * NEXT              -- For Next loop
       FORM_INPUT t$           -- input string with default value
       FUNCTION * ENDFUNC      -- define function

       GOSUB procedure(varliste) -- call subroutine
       GOTO label              -- goto label

       HELP <expr>             -- prints short help on expr
       HOME                    -- Textcursor home

       IF * ELSE IF * ELSE * ENDIF -- conditions
       INC a%                  -- increments a%
       INPUT [#unit,]["text";] varlist -- read values for variables

       LET a=b                 -- enforces assignment
       LINEINPUT [#unit,]t$    -- read entire line from channel/file/console
       LINK #n,t$              -- load shared object file t$
       LIST [s,e]              -- List programm code (from line s to e)
       LLIST [s,e]             -- writes the BASIC-program-listing from line s to
                                  line e with linenumbers into the file
                                  "<programname>.prme" and prints it on demand
       LOAD a$                 -- load Programm
       LOCAL var[,var2,...]    -- specifies a list of vars to be local in Procedure
                                  or function
       LOCATE column,row       -- Place cursor on column and row
       LOOP                    -- see DO * LOOP
       LPOKE adr,long          -- writes long int value to pointer adr
       LSET t$=a$

       ON MENU GOSUB p1        -- define PROCEDURE p1 to handle an action
                                  if a menue-point was selected
       MERGE f$                -- Merges bas-file to actual program code
       MID$(t$,i,j)=b$
       MUL a,b                 -- same as a=a*b

       NEW                     -- clear and erase all variables and stop.
       NEXT                    -- see FOR * NEXT
       NOP                     -- do nothing
       NOOP                    -- do nothing

       ON * GOSUB proc1[,proc2,...]
       ON BREAK GOSUB proc
       ON ERROR GOSUB proc
       OPEN mode$,#n,filename$  -- open a file or socket for input and/or output
       OUT #n,a                -- out byte a to channel n

       PAUSE sec               -- pauses sec seconds
       PLIST                   -- formatted listing
       POKE adr,byte           -- write byte to pointer adr
       PRINT a;b$              -- console output
       PRINT #n;               -- output to channel/file
       PRINT AT(x,y);          -- locate textcursor at row y and column x
       PRINT a USING f$        -- print number with formatter
       PROCEDURE procname [(p1 [,p2] ... )]  * RETURN
       PSAVE a$                -- writes the reformatted BASIC-program into file
 				  with the name a$
       PUTBACK [#n,]a%         -- put back a char to channel/file/console
       QUIT                    -- quits the X11-BASIC-Interpreter

       RANDOMIZE [seed%]       -- Sets seed for random generator, normally TIMER
 				  is used for this
       READ var                -- reads constant from DATA statement
       RELSEEK #n,d            -- Place filepointer on new relative position d
       REM comment             -- comment
       REPEAT                  -- see REPEAT * UNTIL
       RESTORE [label]         -- (re)sets pointer for READ-statement to "label"
       RESUME
       RETURN                  -- define the end of a PROCEDURE
       RETURN expr             -- return value from FUNCTION
       RSRC_LOAD filename$     -- loads GEM rsc-File (ATARI ST)
       RSRC_FREE               -- frees GEM rsc-File (ATARI ST)
       RUN                     -- start program

       SAVE [a$]               -- writes the BASIC-program into file with the name a$
       SEEK #n,d               -- Place filepointer on new absolute position d
       SETENV t$=a$            -- Sets environmentvar t$ using value a$
       SORT a(),n[,b()]        -- Sort array
       SOUND freq              -- Sound the internal speaker with frequency [Hz]
       SWAP
       SYSTEM t$               -- excecute shell with command t$
       TROFF                   -- Trace mode off
       TRON                    -- Trace mode on  (for debugging)
       UNLINK #n               -- unlinks shared object #n
       UNTIL exp               -- if exp is false goto REPEAT
       VERSION                 -- shows X11-Basic version number and date
       VOID a                  -- claculates expresion a and discard result

       WORT_SEP t$,d$,mode,a$,b$ -- separates string t$ by deliminator d$ in
                                  a$ and b$

   Graphic commands

       ALERT a,b$,c,d$,var[,ret$] -- Infobox
       BOX x1,y1,x2,y2         -- draw a frame
       CIRCLE x,y,r            -- draw a circle
       CLEARW [[#]n%]          -- clear graphic window
       CLOSEW [[#]n%]          -- close graphic window
       COLOR f[,b]             -- Set foreground color (and background color)
       DEFFILL c,a,b           -- set fill style and pattern
       DEFLINE a,b             -- set line width and type
       DEFMARK c,a,g           -- define: colour, size, type (POLYMARK)
       DEFMOUSE i              -- set mouse cursor type
       DEFTEXT c,s,r,g         -- set text properties for ltext
       DRAW [[x1,y1] TO] x2,y2 -- draw line
       ELLIPSE x,y,a,b[,a1,a2] -- draw an ellipse
       FILESELECT titel$,pfad$,default$,f$  --     display a fileselector-box
       GET x,y,w,h,g$          -- Grafik-Ausschnitt in g$ speichern
       GPRINT                  -- like PRINT, but the output goes to the graphic
 				  window
       GRAPHMODE mode          -- set graphic-mode
       KEYEVENT a,b            -- Waits until key is pressed
       LINE x1,y1,x2,y2        -- draw a line
       LTEXT x,y,t$            -- Linegraphic-Text

       MENUDEF array$(),proc   -- read text for menu-header from array$()
       MENUSET n,x             -- change menu-point #n with value x
       MENU STOP               -- switch off the menu
       ON MENU GOSUB p1        -- define PROCEDURE p1 to handle an action
       ONMENU                  -- execute the menu and
       MENU                    -- wait for menue-events

       MOUSE x,y,k             -- gets position and state of mouse
       MOUSEEVENT              -- wait for mouse event
       MOTIONEVENT             -- wait for mouse movement

       MOVEW n,x,y             -- move window
       OPENW n                 -- open window
       PBOX  x1,y1,x2,y2       -- draw filled box
       PCIRCLE x,y,r[,a1,a2]   -- draw filled cirle
       PELLIPSE x,y,a,b[,a1,a2]-- draw filled ellipse
       PLOT x,y                -- draw point
       POLYLINE n,x(),y()      -- draw polygon in (x(),y())
       POLYFILL n,x(),y()      -- draw filled polygon
       POLYMARK n,x(),y()      -- draw polygon points
       PRBOX x1,y1,x2,y2       -- draw filled rounded box
       PUT x,y,g$              -- map graphic at position
       PUT_BITMAP t$,i,i,i,i   -- map bitmap
       RBOX x1,y1,x2,y2        -- draws a rounded box
       SCOPE a(),typ,yscale,yoffset   -- fast plot a()
       SCOPE y(),x(),typ,yscale,yoffset,xscale,xoffset   -- fast 2D plot
       SGET screen$            -- capture graphic and store it in screen$
       SHOWPAGE                -- maps all graphic to window
       SPUT screen$            -- maps (xwd-)graphic to window
       TEXT x,y,t$             -- draw text
       TITLEW n,t$             -- set window title
       VSYNC                   -- same as SHOWPAGE
       XLOAD                   -- load a program, with FILESELECTOR
       XRUN                    -- load and run a program, with FILESELECTOR


   Math commands

       ADD a,b                 -- same as a=a+b but faster
       DEC var                 -- same as var=var-1 but faster
       DIV a,b                 -- same as a=a/b but faster
       FFT a(),i               -- fast fourier transformation on 1D array.
       FIT x(),y()[,yerr()],n,func(x,a,b,c,...) -- fits function to data
       FIT_LINEAR x(),y()[,[xerr(),]yerr()],n,a,b[,siga,sigb,chi2,q]
                               -- linear regression with errors
       INC var                 -- same as var=var+1 but faster
       MUL a,b                 -- same as a=a*b but faster
       SORT a(),n[,b()]        -- sorts n values of a() to incrementing order
       SUB a,b                 -- same as a=a-b but faster

   Math functions

       b=ABS(a)                -- absolut value
       c=ADD(a,b)              -- add
       a=CINT(b)               -- truncate number (NOTE: differs from INT!)
       a=RND(dummy)            -- random number between 0 and 1
       a=GASDEV(dummy)         -- random number Gauss distribution
       a=RAND(dummy)           -- random integer number between 0 and a large number
       a=RANDOM(n)             -- random integer number between 0 and n
       i=SGN(a)                -- sign of a (-1,0,1)
       b=SQR(a)                -- square root
       b=SQRT(a)               -- square root
       b=TRUNC(a)              -- round a to the nearest integer not larger in
                                  absolute value
       b=FRAC(a)               -- fractional (non integer) part of a
       b=INT(a)                -- convert to integer
       b=LN(a)                 -- base e logarithm (natural log)
       b=LOG(a)                -- base e logarithm (natural log)
       b=LOG10(a)              -- base 10 logarithm
       b=EXP(a)                -- base e "anti-log"  (e to the x)
       b=FAK(a)                -- factorial (Fakultaet)

     Angles

       Angles are always radians, for both arguments  and  return
       values.

       b=RAD(a)                -- convert degrees to radians
       b=DEG(a)                -- convert radians to degrees

     trigonometric functions

       b=SIN(a)                -- sine
       b=COS(a)                -- cosine
       b=TAN(a)                -- tangent
       b=COT(a)                -- cotangent
       b=SEC(a)                -- secant
       b=CSC(a)                -- cosecant

       b=ASIN(a)               -- arc-sine
       b=ACOS(a)               -- arc-cosine
       b=ATAN(a)               -- arc-tangent
       b=ATAN2(a,c)            -- extended arc-tangent
       b=ACOT(a)               -- arc-cotangent
       b=ASEC(a)               -- arc-secant
       b=ACSC(a)               -- arc-cosecant

       b=SINH(a)               -- hyperbolic sine
       b=COSH(a)               -- hyperbolic cosine
       b=TANH(a)               -- hyperbolic tangent
       b=COTH(a)               -- hyperbolic cotangent
       b=SECH(a)               -- hyperbolic secant
       b=CSCH(a)               -- hyperbolic cosecant

       b=ASINH(a)              -- hyperbolic arc-sine
       b=ACOSH(a)              -- hyperbolic arc-cosine
       b=ATANH(a)              -- hyperbolic arc-tangent
       b=ACOTH(a)              -- hyperbolic arc-cotangent
       b=ASECH(a)              -- hyperbolic arc-secant
       b=ACSCH(a)              -- hyperbolic arc-cosecant

     Boolean functions

       a=EVEN(d)               -- TRUE if d is even number
       a=ODD(d)                -- TRUE if d is odd number

   String functions

       u$=LCASE$(t$)       -- converts t$ to lower case
       u$=LOWER$(t$)       -- converts t$ to lower case
       t$=RIGHT$(a$[,n])   -- returns right n characters of a$
       t$=SPACE$(i)        -- returns string consisting of i spaces
       t$=STRING$(w$,i)    -- returns string consisting of i copys of w$
       u$=UCASE$(t$)       -- converts t$ to upper case
       u$=UPPER$(t$)       -- converts t$ to upper case


   Graphic functions

       a=FORM_ALERT(n,t$)      -- message box with default button n
       a=FORM_DIAL(i,i,i,i,i,i,i,i,i) -- complex function
       a=FORM_DO(i)            -- do dialog
       c=GET_COLOR(r,g,b)      -- allocate color by rgb value
       dummy=OBJC_DRAW(i,i,i,i,i) -- draw object tree
       ob=OBJC_FIND(tree,x,y)  -- return object number by coordinates
       c=POINT(x,y)            -- returns color of pixel of graphic in window
       a=RSRC_GADDR(typ,nr)    -- get pointer to object tree

XXXX \=     X11-Basic Error messages:           \kill    \\
0 \> Divide by zero\\
1 \> Overflow\\
2 \> Value not integer $-2147483648 \dots 2147483647$\\
3 \> Value not byte $0 \dots 255$\\
4 \> Value not short $-32768 \dots 32767$\\
5 \> Square root: only positive numbers\\
6 \> Logarithmen nur für Zahlen größer Null\\
7 \> Unknown Error \\
8 \> Out of Memory\\
9 \> Function or command  not yet implemented\\
10 \> String too long\\

12 \> Program too long, buffer size exeeded --> NEW\\

14 \> Array () already dimensioned\\
15 \> Array () not dimensioned\\
16 \> Field index too large\\
17 \> Dim too large\\
18 \> Wrong number of indicies\\
19 \> Procedure  not found\\
20 \> Label  not found\\
21 \> Open only "I"nput  "O"utput "A"ppend "U"pdate\\
22 \> File already opened\\
23 \> Wrong file \#\\
24 \> File not opened\\
25 \> Wrong input, no number\\
26 \> EOF - reached end of file\\
27 \> Too many points for Polyline/Polyfill\\
28 \> Array must be one dimensional\\

30 \> Merge - no ASCII file\\
31 \> Merge - line too long - CANCEL\\
32 \> ==> Syntax error \\
33 \> Marke nicht definiert\\
34 \> Zu wenig Data\\
35 \> Data nicht numerisch\\
36 \> Programmstruktur Fehlerhaft \\
37 \> Diskette voll\\
38 \> Befehl  im Direktmodus nicht möglich\\
39 \> Programmfehler Kein Gosub möglich\\
40 \> Clear nicht möglich in For-Next-Schleifen oder Proceduren\\
41 \> Cont nicht möglich\\
42 \> Zu wenig Parameter \\
43 \> Ausdruck zu komplex\\
44 \> Funktion  nicht definiert\\
45 \> Zu viele Parameter\\
46 \> Parameter  falsch, keine Zahl\\
47 \> Parameter  falsch, kein String\\
48 \> Open "R" - Satzlänge falsch\\
49 \> Zu viele "R"-Files (max. 31)\\
50 \> Kein "R"-File\\
51 \> Parser: Syntax Error <>\\
52 \> Fields größer als Satzlänge\\

54 \> GET/PUT Field-String Länge falsch\\
55 \> GET/PUT Satznummer falsch\\
56 \> Falsche Anzahl Parameter\\
57 \> Variable  noch nicht initialisiert\\
58 \> Variable  ist vom falschen Typ\\

60 \> Sprite-String-Länge falsch\\
61 \> Fehler bei RESERVE\\
62 \> Menu falsch\\
63 \> Reserve falsch\\
64 \> Pointer falsch\\
65 \> Feldgröße < 256\\
66 \> Kein VAR-Array\\
67 \> ASIN/ACOS falsch\\
68 \> Falsche VAR-Type\\
69 \> ENDFUNC ohne RETURN\\
70 \> Unbekannter Fehler 70\\
71 \> Index zu groß\\

80 \> Matrizenoperationen nur für ein- oder zweidimensionale Felder\\
81 \> Matrizen haben nicht die gleiche Ordnung\\
82 \> Vektorprodukt nicht definiert\\
83 \> Matrizenprodukt nicht definiert\\
84 \> Scalarprodukt nicht definiert\\
85 \> Transposition nur für zweidimensionale Matrizen\\
86 \> Matrix nicht quadratisch\\
87 \> Transposition nicht definiert\\
88 \> FACT/COMBIN/VARIAT nicht definiert\\

90 \> Fehler bei Local\\
91 \> Fehler bei For\\
92 \> Resume (next) nicht möglich   Fatal, For oder Local\\
93 \> Stapel-Fehler\\

100 \> X11BASIC Version 1.10  Copyright (c) 1997-2004 Markus Hoffmann\\
101 \> ** 1 - Segmentation fault : Speicherschutzverletzung\\
102 \> ** 2 - Bus Error Peek/Poke falsch?\\
103 \> ** 3 - Adress error Ungerade Wort-Adresse! Dpoke/Dpeek, Lpoke/Lpeek?\\
104 \> ** 4 - Illegal Instruction : ungültiger Maschinenbefehl\\
105 \> ** 5 - Divide by Zero : Division durch Null\\
106 \> ** 6 - CHK exeption : CHK-Befehl\\
107 \> ** 7 - TRAPV exeption : TRAPV-Befehl\\
108 \> ** 8 - Privilege Violation : Privilegverletzung\\
109 \> ** 9 - Trace exeption : Trace ohne Monitor\\
110 \> ** 10 - Broken pipe : Ausgabeweitergabe abgebrochen\\

131 \> * Number of hash collisons exceeds maximum generation counter value.\\
132 \> * Wrong medium type : Andere Diskette einlegen\\
133 \> * No medium found : Bitte Disk einlegen\\
134 \> * Quota exceeded\\
135 \> * Remote I/O error\\
136 \> * Is a named type file\\
137 \> * No XENIX semaphores available\\
138 \> * Not a XENIX named type file\\
139 \> * Structure needs cleaning\\
140 \> * Stale NFS file handle\\
141 \> * Operation now in progress\\
142 \> * Operation already in progress\\
143 \> * No route to host\\
144 \> * Host is down\\
145 \> * Connection refused : Verbindungsaufbau verweigert\\
146 \> * Connection timed out : Zeitüberschreitung bei Verbindung\\
147 \> * Too many references: cannot splice\\
148 \> * Cannot send after transport endpoint shutdown\\
149 \> * Transport endpoint is not connected : Keine Verbindung, Verbindung unterbrochen ?\\
150 \> * Transport endpoint is already connected : Verbindung schon geöffnet \\
151 \> * No buffer space available : Speicher voll\\
152 \> * Connection reset by peer\\
153 \> * Software caused connection abort : Verbindungsabbruch durch Anwender\\
154 \> * Network dropped connection because of reset\\
155 \> * Network is unreachable\\
156 \> * Network is down\\
157 \> * Cannot assign requested address  : Verbindungsaufbau nicht möglich\\
158 \> * Address  already in use : Besetzt, Verbindung nicht möglich\\
159 \> * Address family not supported by protocol\\
160 \> * Protocol family not supported\\
161 \> * Operation not supported on transport endpoint\\
162 \> * Socket type not supported\\
163 \> * Protocol not supported\\
164 \> * Protocol not available\\
165 \> * Protocol wrong type for socket\\
166 \> * Message too long\\
167 \> * Destination address required\\
168 \> * Socket operation on non-socket : Operation nur mit Sockets erlaubt\\
169 \> * Too many users\\
170 \> * Streams pipe error\\
171 \> * Interrupted system call should be restarted\\
172 \> * Illegal byte sequence\\
173 \> * Cannot exec a shared library directly\\
174 \> * Attempting to link in too many shared libraries\\
175 \> * .lib section in a.out corrupted\\
176 \> * Accessing a corrupted shared library\\
177 \> * Can not access a needed shared library\\
178 \> * Remote address changed\\
179 \> * File descriptor in bad state\\
180 \> * Name not unique on network\\
181 \> * Value too large for defined data type\\
182 \> * Not a data message\\
183 \> * RFS specific error\\
184 \> * Try again : Operation zur Zeit nicht möglich\\
185 \> * Too many symbolic links encountered\\
186 \> * File name too long : Dateiname zu lang\\
187 \> * Resource deadlock would occur\\
188 \> * Advertise error\\
189 \> * Speicherblockfehler\\
190 \> * Kein Binärprogramm\\
191 \> * Link has been severed\\
192 \> * Object is remote\\
193 \> * Math result not representable\\
194 \> * Math arg out of domain of func\\
195 \> * Cross-device link\\
196 \> * Device not a stream\\
197 \> * Mount device busy\\
198 \> * Block device required\\
199 \> * Bad address\\
200 \> * No more processes\\
201 \> * No children\\
202 \> * Exchange full\\
203 \> * Interrupted system call\\
204 \> * Invalid exchange\\
205 \> * Permission denied, you must be super-user\\
206 \> * Operation auf diesem Kanal nicht (mehr) möglich\\
207 \> * Keine weiteren Dateien\\
208 \> * Link number out of range\\
209 \> * Level 3 reset\\
210 \> * Ungültige Laufwerksbezeichnung\\
211 \> * Level 2 not synchronized\\
212 \> * Channel number out of range\\
213 \> * Identifier removed\\
214 \> * No message of desired type\\
215 \> * Operation  would block\\
216 \> * Ungültige Speicherblockadresse\\
217 \> * Directory  not empty : Das Verzeichnis ist nicht leer\\
218 \> * Function  not implemented : Unbekannter Befehl\\
219 \> * Ungültiges Handle \\
220 \> * Zugriff nicht möglich\\
221 \> * Zu viele Dateien offen\\
222 \> * Pfadname nicht gefunden\\
223 \> * Datei nicht gefunden\\
224 \> * Broken pipe : Verbindung wurde unterbrochen\\
225 \> * Too many links : Zu viele Links\\
226 \> * Read-Only File-System : File-System ist Schreibgeschützt\\
227 \> * Illegal seek : Seek falsch\\
228 \> * No space left on device  : File-System ist voll\\
229 \> * File too large : File  ist zu gross für diese Operation\\
230 \> * Text file  busy\\
231 \> *  Not a typewriter\\
232 \> * Too many open files\\
233 \> * File table overflow : Zur Zeit sind keine weiteren offenen Files möglich\\
234 \> * Invalid argument \\
235 \> *  Is a directory\\
236 \> *  Not a directory\\
237 \> * No such device \\
238 \> * Cross-device link\\
239 \> * File exists\\
240 \> * Bad Sektor (Verify)\\
241 \> * Unbekanntes Gerät\\
242 \> * Diskette wurde gewechselt\\
243 \> * Permission denied : Die Erlaubnis wurde verweigert\\
244 \> * Not enough core : Speicher voll\\
245 \> * Lesefehler\\
246 \> * Schreibfehler\\
247 \> * Kein Papier\\
248 \> * Sektor nicht gefunden\\
249 \> * Arg list too long : Zu viele Parameter\\
250 \> * Seek Error Spur nicht gefunden\\
251 \> * Bad Request Ungültiger Befehl\\
252 \> * CRC Fehler Disk-Prüfsumme falsch\\
253 \> * No such process\\
254 \> * Timeout\\
255 \> * IO-Error : Allgemeiner IO-Fehler \\

\chapter{Compatibility}

\section{General remarks}

    X11-Basic deviates in numerous aspects from ANSI BASIC. It in event is 
    also different from Gfa-Basic (Atari ST) all though it really looks similar:

\subsection*{ELSE IF vs. ELSEIF}

        This interpreter uses the ELSE IF form of the "else if" statement with
        a  space  between  ELSE and IF. In contrast, ANSI BASIC uses ELSEIF and END IF.  Other
        interpreters may also use the combination ELSEIF and END IF.


\subsection*{Local variables}

	Local variables must be declared local in the procedure/function. Any 
	other variables are treated as global.

\subsection*{Call By-Value vs. By-Reference}

	Variables  in  a GOSUB statement as in "GOSUB test(a)" are passed
	"by-value" to the PROCEDURE: the subroutine gets  the  value  but
	can not change the variable. To pass the variable "by-reference",
	use the VAR keyword as in "GOSUB  test(VAR  a)":  the  subroutine
	then  not  only  gets  the  value but the variable itself and can
	change it (for more information, see the documentation of the GO­
	SUB  statement). The same rules apply to FUNCTION: VAR in the pa­
	rameter list of a function call allows a FUNCTION to get a  vari­
	able parameter "by-reference". In contrast, traditional BASIC in­
	terpreters always pass variables in  parameter  lists  "by-refer­
	ence".  The  problem  with  "by-reference" parameters is that you
	must be fully aware of what happens inside  the  subroutine:  as­
	signments  to  parameter  variables  inside  the subroutine might
	change the values of variables in the calling line.



\subsection*{Assignment operator}

        X11-BASIC does not have an assignment operator but  overloads  the
        equal sign to act as the assignment operator or as comparison operator
        depending on context: In a regular expression,  all  equal  signs  are
        considered  to  be  the  comparison  operator,  as in "IF (a=2) THEN".
        However, in an "assignment-style" expression (as in  "LET  a=1"),  the
        first  equal sign is considered to be the assignment operator. Here is
        an example which assigns the result of a comparison (TRUE or FALSE) to
        the variable <a> and thus shows both forms of usage of the equal sign:

\begin{verbatim}
a=(b=c)
\end{verbatim}


\subsection*{Assignments to modifiable lvalue}

        Some implementations of BASIC allow the use of functions on  the  left
        side of assignments as in \verb|MID$(a$,5,1)="a"|. X11-Basic does not
        support this syntax but requires a variable (a "modifiable lvalue") on
        the left side of such expressions.

\subsection*{TOS/GEM implementation}

	Because Gfa-Basic on ATARI-ST makes much use of the built in GUI 
	functions of the ATARI ST, the X11-Basic interpreter can only have 
	limited compatibility. GEM style (and compatible) ALERT boxes, menus 
	and object trees are included in the interpreter and can be used in a 
	similar way. Even ATARI ST *.rsc files can be loaded. But Other
	functions  like LINEA functions, the VDISYS, GEMSYS, BIOS, XBIOS and
	GEMDOS calls  are (of course) not possible. Also many other commands
	are not implemented  because the author thinks that they have no useful
	effect on UNIX platforms. Some might be included in a later Version of
	X11-Basic (see the list below). Since many Gfa-basic programs make use
	of  more or less of these functions, they will have to be modified
	before they can be run with X11-Basic.

\subsection*{The INLINE statement}
       
       The INLINE statement is not supported, because the source code of
       X11-Basic  programs is pure ASCII text. But an alternative has been
       implemented. (see \verb|INLINE$()|).

\section{GFA-Basic compatibility}
    
	Following GFA-Basic Commands and functions are not supported and 
	probably never will be. When porting from GFA-Basic to X11-Basic 
	they have to be removed or replaced by an alternative routine:

\begin{tabbing}
XXXXXXXXXXXXXXXXX\=XXXXXXXXXXXXXXXXXX\=\kill\\
\verb|==|\>		Comparison operator for approximately equal  --> =\\
\verb|ACHAR, ACLIP|\>	LINE-A function\\
\verb|ADDRIN, ADDROUT|\> address of the AES Address Input/Output blocks\\
\verb|ALINE, APOLY TO|\> LINE-A function\\
\verb|APPL_EXIT()|\>	Declare program has finished\\
\verb|APPL_INIT()|\>	Announce the program as an application.\\
\verb|APPL_READ()|\>	read from the event buffer.\\
\verb|APPL_TPLAY()|\>	Plays back a record of user activities\\
\verb|APPL_TRECORD()|\>	makes a record of user activities\\
\verb|APPL_WRITE()|\>	write to the event buffer.\\
\verb|ARECT, ATEXT|\>	LINE-A function\\
\verb|BASEPAGE|\>	address of the basepage\\
\verb|BIOS()|\>		call BIOS routinen.\\
\verb|BITBLT|\>		Raster copying command\\
\verb|CFLOAT()|\>	Changes integer into a floating point number.\\
\verb|CHDRIVE|\>		Sets the default disk drive\\
\verb|CONTRL|\>		Address of the VDI control table.\\
\verb|COSQ()|\>		cosine of value from an internal table\\
\verb|DEFBIT, DEFBYT, DEFWRD, DEFFLT, DEFSTR |\>  \>      sets the varaible  type\\
\verb|DFREE()|\>		free space on a disc\\
\verb|DIR|\>		Lists the files on a disc.  --> system "ls"\\
\verb|DIR$()|\>		Names the active directory  --> env\$("PWD")\\
\verb|DMACONTROL, DMASOUND|\>     Controls the DMA sound\\
\verb|FGETDTA()|\>	Returns the DTA (Disk Transfer Address).\\
\verb|FILES|\>		Lists the files on a disk.  --> system "ls -l"\\
\verb|FSETDTA|\> 	Sets the address of the DTA\\
\verb|GB, GCONTRL |\>    Address of the AES Parameter/control Block\\
\verb|GDOS?|\>		Returns  TRUE  (-1)  if GDOS is  resident\\
\verb|GEMDOS()|\>	call the GEMDOS routines.\\
\verb|GEMSYS|\>		call the AES routinen\\
\verb|GETSIZE()|\>	return the number of Bytes required by a screen area\\
\verb|GINTIN, GINTOUT|\> Address of the AES Integer input/output block.\\
\verb|HARDCOPY|\>       	Prints the screen          --> savescreen\\
\verb|HIMEM |\>         	address of the area of memory which is not allocated by interpreter\\
\verb|HLINE|\>	       	LINE-A function\\
\verb|INPAUX$|\>        	read data from the serial port\\
\verb|INPMID$|\>        	read data from the MIDI port\\
\verb|INTIN, INTOUT|\>   Address of the VDI integer Input/output block.\\
\verb|KEYDEF |\>        	Assign a string to a Function Key.\\
\verb|LLIST |\>         	Prints out the listing of the current program.\\
\verb|LPENX, LPENY |\>   Returns the coordinates of a light pen.\\
\verb|LPOS()|\>         	column in which the printer head is located\\
\verb|LPRINT|\>         	prints data on the printer.\\
\verb|L~A |\>           	Returns base address of the LINE-A variables.\\
\verb|MENU_REGISTER()|\> Give a desk accessory a name\\
\verb|MONITOR|\>        	Calls a monitor resident in memory.\\
\verb|MSHRINK()|\>      	Reduces the size of a storage area --> REALLOC()\\
\verb|NAME AS|\>        	Renames an existing file.\\
\verb|PADT(), PADX(), PADY()|\> Reads the paddle on the STE\\
\verb|PSAVE |\>         	save with protection\\
\verb|RCALL |\>    	Calls an assembler routine\\
\verb|RC_COPY|\>   	Copies rectangular screen sections  (--> see copyarea)\\
\verb|RENAME AS |\>     	Rename a file.	\\
\verb|RESERVE|\>      	Increases or decreases the memory used by basic\\
\verb|RMDIR|\>        	Deletes empty directories\\
\verb|SCRP_READ(), SCRP_WRITE()|\>   communication between GEM programs.\\
\verb|SDPOKE, SLPOKE, SPOKE|\>  Supervisor mode memory access\\
\verb|SETCOLOR i,r,g,b|\>  set rgb value of color cell (-->GET\_COLOR())\\
\verb|SETTIME|\>		Sets the time and the date.\\
\verb|SHEL_ENVRN()|\>	--> ENV\$()\\
\verb|SHEL_FIND()|\>     --> system "find ..."\\
\verb|SHEL_GET, SHEL_PUT|\>  	obsolete\\
\verb|SHEL_READ |\> 	obsolete  --> PARAM\$()\\
\verb|SHEL_WRITE|\>	obsolete\\
\verb|SINQ()|\>		Returns the extrapolated sine\\
\verb|STICK|\>		control the joystick\\
\verb|SYSTEM |\> 	obsolete  --> QUIT\\
\verb|THEN|\>            keyword in If statements (obsolete)\\
\verb|VDIBASE, VDISYS|\> VDI  functions\\
\verb|VQT_EXTENT|\>     	coordinates of a rectangle  which surround the text\\
\verb|VQT_NAME()|\>     	VDI  function\\
\verb|VSETCOLOR |\>     	TOS specific\\
\verb|VST_LOAD_FONTS(), VST_UNLOAD_FONTS()|\> VDI  function\\
\verb|V_CLRWK(), V_CLSVWK(), V_CLSWK(), V_OPNVWK()|	\\
\verb|V_OPNWK(), V_UPDWK()|\> VDI-GDOS functions\\
\verb|V~H|\>	       	Returns the internal VDI handle\\
\verb|WAVE  |\>         	Produces noises from the sound channels.\\
\verb|WINDTAB|\>	       	Gives the address of the Window Parameter Table.\\
\verb|WIND_CALC(), WIND_CLOSE(), WIND_CREATE(), WIND_DELETE(), WIND_FIND(),| \\
\verb|WIND_GET(), WIND_OPEN(), WIND_SET(), WIND_UPDATE()|\> \> GEM-Wondow-Function\\
\verb|WORK_OUT() |\>    	Determines the values from OPEN_WORKSTATION.\\
\verb|W_HAND(#n) |\>    	Returns the GEM handle of the window\\
\verb|W_INDEX()  |\>    	Returns the window number of the specified GEM handle.\\
\verb|XBIOS()|\>	       	call XBIOS system routines.\\
\verb|_DATA|\>	       	Specifies the position of the DATA pointer.\\
\end{tabbing}
\\[3ex]

{\bf These GFA-Basic commands may be supported in a later versions of 
X11-Basic:}

\begin{tabbing}
XXXXXXXXXXXXXXXXX\=XXXXXXXXXXXXXXXXXX\=\kill\\
\verb|ABSOLUTE x,y|\>	Assigns the address y to the variable x.\\
\verb|APPL_FIND(fname$)|\> Returns the ID of the sought after application.\\
\verb|BYTE{x}|\>		read the contents of the address x\\
\verb|C:|\>	      Calls a C or assembler program with parameters as in C\\
\verb|CARD{x}|\>	      Reads/writes a 2-byte unsigned integer\\
\verb|CHAR{x}|\>	      Reads a string of bytes until a null byte is  encountered\\
\verb|CHDIR|\>	      Changes the current directory.\\
\verb|CLIP|\>	      set clipping area\\
\verb|CRSCOL  CRSLIN|\>   Returns current cursor line and column.\\
\verb|CURVE x0,y0,x1,y1,x2,y2,x3,y3|\>   The  BEZIER-Curve\\
\verb|DEFLIST x|\>       Defines the program listing format.\\
\verb|DEFMARK [C],[A],[G]|\>  Sets colour, type and size of the corner points\\
\verb|DEFNUM n|\>        Affects  output  of numbers by the PRINT  command\\
\verb|DELETE x(i)|\>     Removes  the ith element of array x.\\
\verb|DO UNTIL |\>      extention\\
\verb|DO WHILE |\>      extention\\
\verb|DOUBLE{x}|\>       reads/writes  an  8-byte floating point  variable\\
\verb|DRAW|\>	      Draws points and lines\\
\verb|EVNT_BUTTON()|\>   Waits for one or more mouse clicks\\
\verb|EVNT_DCLICK()|\>   Sets the speed for double-clicks of a mouse button.\\
\verb|EVNT_KEYBD()|\>    Waits for  a key to be pressed and  returns  a  word\\
\verb|EVNT_MESAG()|\>    Waits for the arrival of a message in the event buffer.\\
\verb|EVNT_MOUSE()|\>    Waits for  the  mouse pointer to  be  located  inside \\
\verb|EVNT_MULTI()|\>    Waits for the occurence of selected  events.\\
\verb|EVNT_TIMER() |\>   waits for a period  of  time\\
\verb|FATAL|\>	      Returns the value 0 or -1 according to the type of error\\
\verb|FIELD|\>	      Divides records into fields.\\
\verb|FILL|\>	      Fills a bordered area with a pattern\\
\verb|FORM INPUT|\>      Enables the insertion of a character string\\
\verb|FORM INPUT AS|\>   the current value of a\$ is displayed, and can be edited.\\
\verb|FORM_BUTTON()|\>   Make inputs in a form possible using the mouse.\\
\verb|FORM_CENTER()|\>   Centers the tree, and returns its coordinates.\\
\verb|FORM_ERROR()|\>    Displays the ALERT associated with the error numbered\\
\verb|FORM_KEYBD()|\>    Allows a form to be edited via the keyboard.\\
\verb|FRE()|\>	      Returns the amount of memory free (in bytes).\\
\verb|FSEL_INPUT()|\>    Calls the AES fileselect library\\
\verb|FSFIRST()|\>       Searches for the first file to fulfill the criteria \\
\verb|FSNEXT()|\>        Search for the next file which fulfills the conditions\\
\verb|FULLW|\>	      Enlarges window to full screen size.\\
\verb|GET #|\>	      Reads a record from a random access file.\\
\verb|GRAF_DRAGBOX()|\>  a rectangle to be moved about the screen\\
\verb|GRAF_GROWBOX()|\>  Draws an expanding rectangle.\\
\verb|GRAF_HANDLE() |\>  supplies the size of a character from the system set\\
\verb|GRAF_MKSTATE()|\>  supplies the current mouse  coordinates\\
\verb|GRAF_MOUSE)   |\>  allows  the  mouse  shape  to  be  changed.\\
\verb|GRAF_MOVEBOX()|\>  a moving rectangle with constant size\\
\verb|GRAF_RUBBERBOX()|\> draws an outline of a rectangle\\
\verb|GRAF_SHRINKBOX()|\> Draws an shrinking rectangle.\\
\verb|GRAF_SLIDEBOX()|\>  moves one rectangular object within another\\
\verb|GRAF_WATCHBOX()|\>  monitors  an object tree while a mouse button  is  pressed\\
\verb|HIDEM|\>	       Switches off the mouse pointer.\\
\verb|HTAB|\>	       Positions  the cursor to the  specified  column. \\  
\verb|INFOW|\>	       information line to the window\\
\verb|OUT, OUT #n, OUT?()|\>  output to device\\
\verb|INSERT|\>	       Inserts  an  element  into  an  array.\\
\verb|INT{x}|\>	       Reads/writes a 2 byte signed integer from/to address x.\\
\verb|KEYGET n |\>        similar to INKEY\$  but wait\\
\verb|KEYLOOK n |\>       similar to INKEY\$  but putback chars\\
\verb|KEYTEST n |\>       similar to INKEY\$\\
\verb|KEYPAD n  |\>       Sets  the  usage of the  numerical  keypad.\\
\verb|KEYPRESS n|\>       This  simulates the pressing of a key.\\
\verb|KILL|\>	       Deletes a file\\
\verb|LOCATE|\>	       Positions the cursor to the specified location.\\
\verb|LONG{x}|\>	       Reads/writes a 4 byte integer from/to address x. Abbrev {}\\
\verb|LOOP UNTIL condition|\>     extention\\
\verb|LOOP WHILE condition|\>     extention\\
\verb|LSET var=string|\>  Puts the 'string' in the string variable 'var' lefft justified\\
\verb|MAT ADD a(),b()|\>\\
\verb|MAT ADD a(),x|\>\\
\verb|MAT CLR a()|\>\\
\verb|MAT CPY a([i,j])=b([k,l])[,h,w]|\>\\
\verb|MAT DET x=a([i,j])[,n]|\>\\
\verb|MAT INPUT #i,a()|\>\\
\verb|MAT INV a()=b()|\>\\
\verb|MAT MUL|\>\\
\verb|MAT MUL a(),x|\>\\
\verb|a()=b()*c()|\>\\
\verb|MAT MUL x=a()*b()|\>\\
\verb|MAT MUL x=a()*b()*c()|\>\\
\verb|MAT NORM a(),{0/1}|\>\\
\verb|MAT ONE a()|\>\\
\verb|MAT PRINT [#i]a[,g,n]|\>\\
\verb|MAT QDET x=a([i,j])[,n]|\>\\
\verb|MAT RANG x=a([i,j])[,n]|\>\\
\verb|MAT READ a()|\>\\
\verb|MAT SET a()=x|\>\\
\verb|MAT SUB a(),b()|\>\\
\verb|MAT SUB a(),x|\>\\
\verb|MAT TRANS a()[=b()]|\>\\
\verb|MAT XCPY a([i,j])=b([k,l])[,h,w]|\>\\
\verb|MAT BASE {0/1}|\>\\
\verb|MAX(x [,y,z,...])  or  MAX(a$[,y$,z$....])|\>  Returns the greatest value (or largest string)\\
\verb|MENU(x)|\>	      Returns the information about an event in the variable \\
\verb|MENU OFF|\>        Returns a menu title to 'normal' display.\\
\verb|MENU_BAR()|\>      Displays/erases a menu bar (from a resource file)\\
\verb|MENU_ICHECK()|\>   Deletes/displays a tick against a menu item.\\
\verb|MENU_IENABLE()|\>  Enables/disables a menu entry.\\
\verb|MENU_TEXT()|\>     Changes the text of a menu item.\\
\verb|MENU_TNORMAL()|\>  Switches the menu title to normal/inverse video.\\
\verb|MFREE()|\>	      Releases the storage  location  reserved with MALLOC\\
\verb|MID$(a$,x[,y])|\> (as a command)\\
\verb|MIN(expression [ ,expression... ])|\> Returns the smallest value (or smallest string)\\
\verb|MKDIR|\>	      Creates a new directory.\\
\verb|MODE|\>	      representation of decimal point, date and files\\
\verb|OBJC_ADD()|\>	      Adds an object to a given tree\\
\verb|OBJC_CHANGE()|\>        Changes the status of an object.\\
\verb|OBJC-DELETE()|\>        object is deleted from an object tree\\
\verb|OBJC_EDIT()|\>	      Allows input and editing\\
\verb|OBJC_FIND()|\>	      Determines the object, which is at the coordinate\\
\verb|OBJC_OFFSET()|\>        Calculates the absolute screen  coordinates\\
\verb|OBJC_ORDER()|\>	      re-positions an object within a tree.\\
\verb|OB_ADR()|\>	      Gets the address of an individual object.\\
\verb|OB_FLAGS()|\>	      Gets the status of the flags for an object.\\
\verb|OB_H()|\> 	      Returns the height of an object\\
\verb|OB_HEAD()|\>	      Points to the object's first child\\
\verb|OB_NEXT()|\>	      Points to the following object on the same level\\
\verb|OB_SPEC()|\>	      Returns the address of the the data structure\\
\verb|OB_STATE()|\>	      returns the status of an object\\
\verb|OB_TAIL()|\>	      Points to the objects last child\\
\verb|OB_TYPE()|\>	      Returns the type of object specified.\\
\verb|OB_W()|\> 	      Returns the width of an object\\
\verb|OB_X(), OB_Y()|\>       relative  coordinates  of  the   object\\
\verb|OCT$()|\> 	      value in octal form \\
\verb|ON BREAK|\>	      influence behavior of CTRL-C\\
\verb|OPTION BASE|\>	      determine whether an  array  is  to contain a zero element\\
\verb|PTST()|\> 	      same as point()\\
\verb|QSORT|\>  	      Sorts  the elements of an array.\\
\verb|RCALL|\>        Calls  an assembler routine\\
\verb|RC_INTERSECT()|\>  Detects whether two rectangles overlap.\\
\verb|RECALL|\>       Inputs n lines from a text file\\
\verb|RECORD |\>	      Sets the number of the next record (GET#, PUT#)\\
\verb|RND as a sysvar|\>  see RND()\\
\verb|ROL(), ROL&(), ROL%()|\>  Rotates a bit pattern left.\\
\verb|ROR(), ROR&(), ROR%()|\>  Rotates a bit pattern right.\\
\verb|RSET a$=b$|\>   Moves a string expression, right justified to a string.\\
\verb|RSRC_OBFIX()|\> converts the coordinates of an object\\
\verb|RSRC_SADDR()|\> sets the address of an object.\\
\verb|RUN <filname>|\>   see RUN\\
\verb|SETDRAW|\>      see DRAW\\
\verb|SHL(), SHL&(), SHL%()|\>  Shifts a bit pattern left\\
\verb|SHOWM |\> 	      Makes the mouse pointer appear.\\
\verb|SHR(), SHR&(), SHR%()|\>  Shifts a bit pattern left\\
\verb|SINGLE{x}|\>    Reads/writes  a  4  byte floating point\\
\verb|SPRITE|\> 	      Puts a sprite\\
\verb|SSORT|\>  	      Sorts using the Shell-Metzner method.\\
\verb|STORE|\>  	      Fast save of a string array as a text file.\\
\verb|TOPW|\>	      Activates the window\\
\verb|TOUCH|\>  	      Updates the date and time stamps od a file.\\
\verb|TRON# |\> 	      Tron to file\\
\verb|TRONproc |\>    procedure is called  before  the execution of each command\\
\verb|VARIAT()|\>     Returns the number of permutations of n elements to the kth order\\
\verb|VTAB|\>		      positions the cursor to the specified line number\\
\verb|WRITE|\>  	      Stores data in a sequential file\\
\end{tabbing}

Following commands have a different meaning and/or syntax in Gfa-Basic:

\begin{verbatim}
	GFA-BASIC           X11-Basic
	--------------------------------
	SYSTEM              QUIT
	LINE INPUT          LINEINPUT
	SOUND		     -
	VSYNC                -
	ON MENU		    MENU
	ON MENU GOSUB ...   MENUDEF
	MENU a$()           MENUDEF
	MENU OFF             -
	MENU KILL           MENUKILL
	MENU()               -
	MONITOR	            SYSTEM
\end{verbatim}

\section{Ideas for future releases of X11-Basic}

\begin{verbatim}

ENCLOSE$(str[, pair])   
	       
Encloses a string.     
The default pair is "" 
	       
Example:	       
? enclose$("abc","()")  
	       
Result: 	       
(abc)		       
========================	
 LEFTOF$(s1,s2), 	      
 RIGHTOF$(s1,s2) 	      
			      
 	Returns the left/right part  
 	of s1 at the position of the 
 	first occurrence of the      
 	string s2 into string s1     
========================
SPRINT var$;[USING...;]...			    
 PRINT anweisung, aber in var$ (Statt Print #1,...) 
 		        
\end{verbatim}
\chapter{X11-Basic command reference}

\section{Syntax templates}

    This manual describes the syntax of BASIC commands and BASIC functions  in
    a generalized form. Here is an example:

\begin{verbatim}
PRINT [#<device-number>,] <expression> [<,>|<;> [...]]
\end{verbatim}

    Those parts of the command that must appear literally in the  source  code
    (like PRINT in the example above) are all uppercase. Descriptions in angle
    brackets ("<>") are not meant to appear literally in the source  code  but
    are  descriptive  references to the element that is supposed to be used in
    the source code at this place, like a variable, a numeric expression  etc.
    Optional elements are listed inside square brackets ("[]").  They  may  be
    omitted  from  the  command  line.  Mutually  exclusive  alternatives  are
    separated by the "|" character. Exactly  one  of  these  alternatives must
    appear  in  the  command  line. Finally, repetitive syntax is indicated by
    three dots "...". Here are some BASIC command lines  that  all  match  the
    syntax template above:

\begin{verbatim}
PRINT x
PRINT #1,2*y
PRINT "result = ";result
\end{verbatim}

##############################################################################

Function:   ABS()
Syntax:     <num-result>=ABS(<num-expression>)
DESCRIPTION:

	Returns the absolute value of an expression. The absolute value is the
	value without regard to the sign (negative, zero or positive). The
	result of ABS will always be a positive number or zero.

SEE ALSO:  SGN()
EXAMPLE:   
	PRINT ABS(-34.5),ABS(34)
      	Result: 34.5     34
	
##############################################################################

Function:   ACOS()
Syntax:     <num-result>=ACOS(<num-expression>)
DESCRIPTION:

	The acos() is the arcus cosine-function, i.e. the inverse of the
	cos()-function.  It returns the angle (in radian), 
	which, fed to the cosine-function will produce the
	argument passed to the acos()-function.

EXAMPLE:   

PRINT ACOS(0.5),ACOS(COS(PI))
Result: 1.047197551197  3.14159265359

SEE ALSO:  COS(), ASIN()
*##############################################################################

Function:   ACOSH()
Syntax:     <num-result>=ACOSH(<num-expression>)
DESCRIPTION:

	The acosh() is the inverse hyperbolic cosine function.

SEE ALSO:  COS(), ASINH()

##############################################################################

Command:   ADD
Syntax:    ADD <num-variable>,<num-expression>

DESCRIPTION:

	Increase value of variable by result of <num-expression>.

EXAMPLE:
a=0
ADD a,5

SEE ALSO: SUB, MUL, DIV
*##############################################################################
Function:   ADD()
Syntax:     <num-result>=ADD(<num-expression>,<num-expression>)

DESCRIPTION:

	(Integer) addition.

EXAMPLE:
b=ADD(a,5)

SEE ALSO: SUB(), MUL(), DIV()
##############################################################################

Command:   AFTER
Syntax:    AFTER <num-variable>, <procedure-name>
	   AFTER STOP
	   AFTER CONT
	   
DESCRIPTION:

	Procedures can be called after the expiry of a set time. Time in
	seconds. To continue the process, use CONT, and to stop use STOP.

EXAMPLE:
PRINT "You have 10 seconds to enter your name: "
AFTER 10,alarm
INPUT name$
END
PROCEDURE alarm
  PRINT "Time out !"
  QUIT
RETURN

SEE ALSO: EVERY
##############################################################################

Command:   ALERT
Syntax:    ALERT <type>,<message-string>,<default-button>,
                 <button-string>,<num-var>[,<string-var>]
	   
DESCRIPTION:

	Creates an alert box and asks for user input.
	
 <type>          chooses type of alert symbol, 0=none, 1="!", 2="?", 3="stop"
<message-string> Contains main text. 
                 Lines are separated by the '|' symbol.
		 Editable fields are started with a chr$(27) followed by the 
		 default text to be edited (until "|"). 
<button-string>  Contains text for the buttons (separated by '|').
<default-button> is the button to be highlighted (0=none,1,2,...) 
		 to be selected by just pressing return.
<num-var>        This variable is set to the number of the button selected.
<string-var>	 This is a string variable which holds any text-input
		 the user made. It holds the contents of the editable fields 
		 separated by a CHR$(13).

EXAMPLES:

ALERT 1,"Pick a|button",1,"Left|Right",a
ALERT 0,"You pressed|Button"+STR$(a),0,"OK",a

' Example of editable fields
i=1
name$="TEST01"
posx$="N54°50'32.3"
t$="Edit waypoint:||Name:   "+chr$(27)+name$+"|"
t$=t$+"Position: "+chr$(27)+posx$+"|"
ALERT 0,t$,1,"OK|UPDATE|DELETE|CANCEL",a,f$
WHILE LEN(f$)
  WORT_SEP f$,CHR$(13),0,a$,f$
  PRINT "Field";i;": ",a$
  INC i
WEND

SEE ALSO: FORM_ALERT(), WORT_SEP, CHR$()

##############################################################################

Operator:   AND
Syntax:     <num-expression1> AND <num-expression2>
DESCRIPTION:

	Used to determine if BOTH conditions are true. If both expression1 AND
	expression2 are true (non-zero), the result is true. Returns -1 for
	true, 0 for false.

	Also used to compare bits in binary number operations. 1 AND 1 return a
	1, all other combinations of 0's and 1's produce 0. 

EXAMPLES:

Print 3=3 AND 4>2        Result:  -1 (true)
Print 3>3 AND 5>3        Result:   0 (false)

PRINT (30>20 AND 20<30)  Result:  -1 (true)
PRINT (4 AND 255)        Result:   4

SEE ALSO:   NAND, OR, NOT, XOR
*##############################################################################

Function:   AND()
Syntax:     <num-result>=AND(<num-expression>,<num-expression2>)

DESCRIPTION:

	   Returns <num-expression> AND <num-expression2>

SEE ALSO: OR(), AND

##############################################################################

Command:     ARRAYCOPY
Syntax:      ARRAYCOPY d(),s() 

DESCRIPTION:

	Copys the contents of array s() to d() (including dimensions).
	This is the same as the statement:
	\verb|d()=s()|.

SEE ALSO: DIM
*##############################################################################

Command:     ARRAYFILL
Syntax:      ARRAYFILL x(),n   
             ARRAYFILL x$(),t$ 

DESCRIPTION:

	Assigns the value to all elements of an array or matrix.

EXAMPLE:
DIM a(100)
ARRAYFILL a(),13
PRINT a(22)       Result: 13

SEE ALSO: DIM
##############################################################################

Function:   ARRPTR()
Syntax:     <int-result>=ARRPTR(<array>())

DESCRIPTION:

	Finds the address of the descriptor of a string or field array.

SEE ALSO: VARPTR()

##############################################################################

Function:   ASC()
Syntax:     <num-result>=ASC(<string-expression>)
DESCRIPTION:
	
	Returns the ASCII code value (a number between 0 and 255) of the first
	character in a string. ASCII stands for American Standard Code for
	Information Interchange. ASC returns 0 if the length of string is zero
	or the ASCII code of the string is zero.

SEE ALSO:  CHR$(), CVI(), CVL(), CVS()
EXAMPLE:       
	PRINT ASC("A"), ASC("T")  Result: 65, 84
	PRINT ASC("TEST")         Result: 84

##############################################################################

Function:   ASIN()
Syntax:     <num-result>=ASIN(<num-expression>)
DESCRIPTION:
	
	The asin() is the arcus sine-function, i.e. the inverse of the
	sin()-function. Or, more elaborate: It Returns the angle (in radian,
	not degree !), which, fed to the sine-function will produce the
	argument passed to the asin()-function.

SEE ALSO:  ACOS(), SIN()
EXAMPLE: 
	PRINT 6*ASIN(0.5)     Result: 3.14159265359

*##############################################################################

Function:   ASINH()
Syntax:     <num-result>=ASINH(<num-expression>)
DESCRIPTION:

	The  asinh()  function  calculates  the inverse hyperbolic sine of x;
	that is the value whose hyperbolic sine is x.

SEE ALSO:  ACOSH(), SIN()

##############################################################################
Keyword:    AT()
Syntax:     PRINT AT(y,x);[...]

DESCRIPTION:

	The AT-statement takes two numeric arguments (e.g. AT(2,3)) and can be
	used in combination with the PRINT- or GPRINT-command. 

	The two numeric arguments of the AT-function may range from 0 to the
	width of your terminal minus 1, and from 0 to the height of your
	terminal minus 1; if any argument exceeds these values, it will be
	truncated accordingly. However, X11-Basic has no influence on the size
	of your terminal (80x25 is a common, but not mandatory), the size of
	your terminal and the maximum values acceptable within the AT-statement
	may vary. To get the size of your terminal you may use the
	CRSLN and CRSCOL variables.


SEE ALSO: PRINT, GPRINT, TAB(), SPC()
##############################################################################
Function:   ATN(), ATAN()
Syntax:     <num-result>=ATN(<num-expression>)
	    <num-result>=ATAN(<num-expression>)
DESCRIPTION:
	
	Returns the angle, in radians, for the inverse tangent of expression.

SEE ALSO:  ACOS(), ASIN()
EXAMPLE: 
	PRINT 4*ATAN(1)     Result: 3.14159265359

*##############################################################################

Function:   ATAN2()
Syntax:     <num-result>=ATAN2(<num-expression>,<num-expression>)
DESCRIPTION:

	The atan()-function has a second form which accepts two arguments:
	atan2(a,b) which is (mostly) equivilantly to atan(a/b) except for the
	fact, that the two-argument-form returns an angle in the range -pi to pi,
	whereas the one-argument-form returns an angle in the range -pi/2 to
	pi/2.

EXAMPLE: 
	 PRINT DEG(ATAN2(0,-1))     Result: 180

SEE ALSO:  ATAN()
*##############################################################################

Function:   ATANH()
Syntax:     <num-result>=ATANH(<num-expression>,<num-expression>)

DESCRIPTION:

	The  atanh()  function  calculates  the inverse hyperbolic tangent of
	x; that is the value whose hyperbolic tangent is  x. If the  absolute
	value of x is greater than 1.0, acosh() returns not-a-number (NaN).

SEE ALSO:  ATAN()

##############################################################################
##############################################################################

Function:   BCHG()
Syntax:     <num-result>=BCHG(<num-expression>,<num-expression>))
DESCRIPTION:

	Allow setting and resetting of bits.

SEE ALSO: BSET(), BCLR()

*##############################################################################

Function:   BCLR()
Syntax:     <num-result>=BCLR(<num-expression-x>,<num-expression-y>))
DESCRIPTION:

	BCLR sets the y-th bit of x to zero.

SEE ALSO: BSET(), BCHG()

##############################################################################

Command:    BEEP, BELL
Syntax:     BEEP
	    BELL
DESCRIPTION:
	
	Sounds the speaker of your terminal. This command is not a
	sound-interface, so you can neither vary the length or the height of
	the sound (technically, it just prints chr$(7)). BELL is exactly the
	same as BEEP.

SEE ALSO: SOUND
##############################################################################

Command:    BGET
Syntax:     BGET #<device-nr>,<adr>,<len> 
	    
DESCRIPTION:
	
	Reads <len> bytes from a data channel into an area of memory 
	starting at address <adr>

        Unlike BLOAD, several different areas of memory can be
        read from a file.

SEE ALSO: BLOAD, BPUT

##############################################################################

Function:   BIN$()
Syntax:     <string-result>=BIN$(<num-expression>[,<num-expression>)])
DESCRIPTION:

	The bin$()-takes a numeric argument an converts it into a string of
	binary digits (i.e. '0' and '1'). The length of the output, number of
	digits can be  specified by the optional second argument.

EXAMPLE: 
        PRINT BIN$(64),BIN$(-2000,16)
	Result: 01000000        1111100000110000

SEE ALSO:  HEX$()
##############################################################################

Command:   BLOAD
Syntax:    BLOAD <filename>,<address> 

DESCRIPTION:

	BLOAD reads the specified file into memory. The adress space <address>
	is pointing to should be allocated before. You  should  check  if  the
	file exists prior to using this function. This command is meant to be
	used for loading binary data. To load a text file, use OPEN and INPUT #
	to remain compatible with other BASIC implementations.

SEE ALSO: MALLOC(), BGET, INPUT, INPUT$(), BSAVE
##############################################################################

Command:   BMOVE
Syntax:    BMOVE <scr>,<dst>,<len>

DESCRIPTION:

	Fast movement of memory blocks.

	<scr> is the address at which the block to be moved begins. 
	<dst> is the address to which the block is to moved. 
	<len> is the length of the block in bytes.

SEE ALSO: PEEK(), POKE, BLOAD, BSAVE

##############################################################################

Command:   BOUNDARY
Syntax:    BOUNDARY <num-expression>

DESCRIPTION:

	Switch off (or on) borders  on filled shapes (PBOX, PCIRCLE ..). 
	If the argument is zero - no border will be drawn.

SEE ALSO: PBOX, PCIRCLE

##############################################################################

Command:   BOX
Syntax:    BOX <x>,<y>,<x2>,<y2>

DESCRIPTION:

	Draws a rectangle with corners at (x,y) and (x2,y2).

SEE ALSO: PBOX

##############################################################################

Command:   BPUT
Syntax:    BPUT #<device-nr>,<adr>,<len>

DESCRIPTION:

	Reads <len> bytes from an area of memory starting at <adr> out to a
	data channel.

SEE ALSO: BGET

##############################################################################

Command:    BREAK
Syntax:     BREAK
DESCRIPTION:

	BREAK transfers control immediately outside the enclosing loop or
	select statement. This is the preferred way of leaving such a
	statement (rather than goto).

SEE ALSO:  EXIT IF

##############################################################################

Command:    BSAVE
Syntax:     <filename>,<adr>,<len>

DESCRIPTION:

	Save <len> bytes in memory from adress <adr> to file.
	This command is meant be be used for saving binary data obtained
        via BLOAD. To save  text  files,  use  OPEN  and  PRINT  #  to  remain
        compatible with other BASIC implementations.


SEE ALSO: BLOAD, BPUT
##############################################################################

Function: BSET()
Syntax:   <num-result>=BSET(<num-expression-x>,<num-expression-y>)

DESCRIPTION:

	Allows setting and resetting of bits. 
	BSET sets the y-th bit of x to 1.

SEE ALSO: BCHG(), BCLR(), BTST()
##############################################################################

Function: BTST()
Syntax:   <bool-result>=BTST(<num-expression-x>,<num-expression-y>)

DESCRIPTION:

	BTST results in -1 (TRUE) if bit y of x is set.
	
SEE ALSO: BCHG(), BCLR(), BSET()

##############################################################################

Function: BYTE()
Syntax:   <num>=BYTE(<num-expression>)
DESCRIPTION:

	Returns lower 8 bits of argument. (same as a=b AND 255)

SEE ALSO: CARD(), WORD(), SWAP()

##############################################################################
#############################################################################

Command: CALL
Syntax:  CALL <adr>[,<parameter-list>]

DESCRIPTION:

	Calls a machine code or C subroutine at address <adr> without return
	value.
	Optinal parameters are passed on the stack. (like in C).
	The default parameter-type is (4-Byte) integer.
	If you want to specify other types, please use prefixes:
	
	D: -- double (8-Bytes)
	F: -- float  (4-Bytes)
	L: -- long int

SEE ALSO: EXEC, EXEC()

EXAMPLE:
	DIM result(100)
	LINK #1,"simlib.so"
	adr=SYM_ADR(#1,"CalcBeta")
	CALL adr,D:1.2,L:0,L:VARPTR(result(0))
	UNLINK #1

#############################################################################

Function: CARD()
Syntax:   <num>=CARD(<num-expression>)

DESCRIPTION:

	Returns lower 16 bits if b. (same as a=b AND (2^16-1))

SEE ALSO: BYTE(), WORD(), SWAP()

#############################################################################

Keyword:  CASE
Syntax:   SELECT ... CASE <num-expression> ... ENDSELECT

DESCRIPTION:

	See SELECT.

SEE ALSO: SELECT, DEFAULT, ENDSELECT

#############################################################################
Function:  CBRT()
Syntax:    a=CBRT(x)

DESCRIPTION:

       The  CBRT()  function  returns  the  cube root of x.  This
       function cannot fail; every representable real value has a
       representable real cube root.

SEE ALSO: SQRT()
#############################################################################

Function: CEIL()
Syntax:   <num-result>=CEIL(<num-expression>)

DESCRIPTION:

	Ceiling function: return smallest integral value not less than
	argument.

SEE ALSO: INT()

#############################################################################

Command: CHAIN
Syntax:  CHAIN <file-name>

DESCRIPTION:

	CHAIN loads and runs another BASIC  program.
        Global variables  will  be available with their current
        value to the new program, all other variables are erased. If you  want
        to  append  another  program  to  the  current  program (as opposed to
        erasing the current program and loading a new program), use the  MERGE
        command instead.
	
SEE ALSO: MERGE, RUN
	
#############################################################################

Function:   CHR$()
Syntax:     <string-result> = CHR$(<num-expression>)
DESCRIPTION:

	CHR$() returns the character associated with a given ASCII code.


Character table

\begin{verbatim}
     032      048  0    064  @   080  P    096  `   112  p
     033  !   049  1    065  A   081  Q    097  a   113  q
     034  "   050  2    066  B   082  R    098  b   114  r
     035  #   051  3    067  C   083  S    099  c   115  s
     036  $   052  4    068  D   084  T    100  d   116  t
     037  %   053  5    069  E   085  U    101  e   117  u
     038  &   054  6    070  F   086  V    102  f   118  v
     039  '   055  7    071  G   087  W    103  g   119  w
     040  (   056  8    072  H   088  X    104  h   120  x
     041  )   057  9    073  I   089  Y    105  i   121  y
     042  *   058  :    074  J   090  Z    106  j   122  z
     043  +   059  ;    075  K   091  [    107  k   123  {
     044  ,   060  <    076  L   092  \    108  l   124  |
     045  -   061  =    077  M   093  ]    109  m   125  }
     046  .   062  >    078  N   094  ^    110  n   126  ~
     047  /   063  ?    079  O   095  _    111  o   127
\end{verbatim}

 Control codes

\begin{verbatim}
     00 NUL	      08 BS   -- Backspace	  16 DLE
     01 SOH	      09 HT   -- horizontal TAB   17 DC1  -- XON
     02 STX	      10 LF   -- Newline	  18 DC2
     03 ETX	      11 VT			  19 DC3  -- XOFF
     04 EOT	      12 FF   -- Form feed	  20 DC4
     05 ENQ	      13 CR   -- Carriage Return  21 NAK
     06 ACK	      14 SO			  22 SYN
     07 BEL  -- Bell  15 SI			  23 ETB
 
     24 CAN	      32 SP  -- Space
     25 EM	     127 DEL -- Delete
     26 SUB
     27 ESC28 FS
     29 GS
     30 RT
     31 US
\end{verbatim}
    
EXAMPLE:
       PRINT CHR$(34);"Hello World !";CHR$(34)
       Result: "Hello World !"

SEE ALSO: ASC()
##############################################################################
Function:   CINT()
Syntax:     <num-result>=CINT(<num-expression>) 
DESCRIPTION:

	CINT() returns the rounded absolute  value of  its argument prefixed
	with the sign of its argument.

EXAMPLE:
	PRINT CINT(1.4), CINT(-1.7)
       	Result: 2, -2

SEE ALSO:   INT(), FRAC(), TRUNC(), ROUND()       
#############################################################################
Command: CIRCLE
Syntax:  CIRCLE <x>,<y>,<r>[,<w1>,<w2>]

DESCRIPTION:

	Draw a circle with actual color (and fillpattern).
	The x- and y-coordinates
	of the center and the radius of the circle in screen coordinates.
	Optionally a starting angle <w1> and stop angle <w2> can be passed
	to draw a circular arc. 

EXAMPLE:
        CIRCLE 100,100,50

SEE ALSO:   ELLIPSE, COLOR, DEFFILL, PCIRCLE
#############################################################################
Command: CLEAR
Syntax:  CLEAR 

DESCRIPTION:

	Clear all variables and arrays as if they were never used before.

SEE ALSO:   NEW	 
#############################################################################
Command: CLEARW
Syntax:  CLEARW [<num>]

DESCRIPTION:

	Clear graphic window. If a number is given, clear window with the number 
	given. The Window is filled with the backgound color given by the X-server.

SEE ALSO:   CLOSEW
#############################################################################

Command: CLOSE
Syntax:  CLOSE [[#]<num-expression>[,[#]<num-expression>,...]]

DESCRIPTION:
	
	This statement is used to CLOSE one or more OPEN files or other
	devices. The parameter expression indicates a device number or file
	number. If no file or device numbers are declared all OPEN devices will
	be closed.
	
COMMENT:

	All files should be closed before leaving a program to insure that data
	will not be lost or destroyed. If a program exit is through END or
	QUIT, all files will be closed. If a program is stopped with the STOP
	command, alle open files remain open.

EXAMPLE:
        CLOSE #1,#2
        CLOSE

SEE ALSO:    OPEN, LINK       
#############################################################################

Command: CLOSEW
Syntax:  CLOSEW [<num>]

DESCRIPTION:

	Close graphic window (make it disappear from the screen). If a number
	is given, closes window with the number  given. The Window will again be
	opened, when the next graphic command is executed.

SEE ALSO:   CLEARW
#############################################################################

Command: CLR
Syntax:  CLR <var>[,<var>,...]

DESCRIPTION:

	Sets specified variables to 0 or "".

#############################################################################

Command: CLS
Syntax:  CLS

DESCRIPTION:
	Clear text screen and move cursor home (upper left corner).

SEE ALSO:   PRINT

#############################################################################

Command: COLOR
Syntax:  COLOR <foreground-color>[,<background-color>]

DESCRIPTION:

	COLOR  sets  the  foreground  color  (and optionally  the  background 
	color)  for graphic output into the  graphic window. The color values are 
	dependant of the color depth of the Screen/X-Server.
	Usually the COLOR statement is used together with the GET_COLOR() function, 
	so arbitrary colors may be used.

EXAMPLE:
	yellow=GET_COLOR(65535,65535,0)
	blue=GET_COLOR(0,0,65535)
	COLOR yellow,blue

SEE ALSO: GET_COLOR, LINE

##############################################################################

Function:   COMBIN()
Syntax:     <num-result>=COMBIN(<n>,<k>)

DESCRIPTION:

	   Calculates the number of combinations of <n> elements to  the 
           <k>th class without repetitions. Defined as z=n!/((n-k)!*k!).
#############################################################################

Command: CONT
Syntax:  CONT

DESCRIPTION:

	Resumes execution of a program.
        Continue the execution of a program after interruption.

##############################################################################
Command: COPYAREA
##############################################################################

Function:   COS()
Syntax:     <num-result>=COS(<num-expression>)

DESCRIPTION:

	Returns the Cosine of the expression in radians.

SEE ALSO:  SIN(), ASIN()
EXAMPLE: 
	PRINT COS(0)     Result: 1

*##############################################################################

Function:   COSH()
Syntax:     <num-result>=COSH(<num-expression>)

DESCRIPTION:

	The  cosh()  function  returns the hyperbolic cosine of x, which is
	defined mathematically as (exp(x)+exp(-x))/2

SEE ALSO:  COS(), ACOSH()

#############################################################################

Variable: CRSCOL,  CRSLIN
Syntax:   CRSCOL
          CRSLIN

DESCRIPTION:

	Returns current cursor line and column.

SEE ALSO:  PRINT AT()
#############################################################################

Variable: CTIMER
Syntax:   CTIMER

DESCRIPTION:

	Returns CPU-Clock in seconds. This timer returns the amount of time
	this application was running. It is most usefull for benchmark 
	applications on multi tasking environments. 

SEE ALSO: TIMER, STIMER
##############################################################################

Function:   CVD()
Syntax:     <num-result>=CVD(<string-expression>)
DESCRIPTION:

	Returns the binary double value of the first 8 characters of string.
	This function is the compliment of MKD$().

SEE ALSO:  ASC(), CVF(), CVL(), MKD$()
*##############################################################################

Function:   CVF()
Syntax:     <num-result>=CVF(<string-expression>)
DESCRIPTION:

	Returns the binary float value of the first 4 characters of string.
	This function is the compliment of MKF$().

SEE ALSO:  ASC(), CVD(), CVL(), MKF$()

*##############################################################################

Function:   CVI()
Syntax:     <num-result>=CVI(<string-expression>)
DESCRIPTION:

	Returns the binary integer value of the first 2 characters of string.
	This function is the compliment of MKI$(). Null string returns 0, 
	One character strings will return the ASCII value.

SEE ALSO:  ASC(), CVF(), CVL(), MKI$()

*##############################################################################

Function:   CVL()
Syntax:     <num-result>=CVL(<string-expression>)
DESCRIPTION:

	Returns the binary long integer value of the first 4 characters of 
	string. This function is the compliment of MKL$(). Null string returns
	0.

SEE ALSO:  ASC(), CVF(), CVI(), MKL$()

*##############################################################################

Function:   CVS()
Syntax:     <num-result>=CVS(<string-expression>)
DESCRIPTION:

	Returns the binary float value of the first 4 characters of string.
	This function is the compliment of MKS$().

SEE ALSO:  CVF(), MKS$()

##############################################################################
##############################################################################

Command:    DATA
Syntax:     DATA [<const>[,<const>, ...]]
DESCRIPTION:

	The DATA statement is used to hold information that may be read into
	variables using the READ statement. DATA items are a list of string or
	numeric constants separated by commas and may appear anywhere in a
	program. No comment statement may follow the DATA statement on the same
	line. Items are read in the order they appear in a program. RESTORE
	will set the pointer back to the beginning of the first DATA statement. 

	Alphanumeric string information in a DATA statement need not be
	enclosed in quotes if the first character is not a number, math sign or
	decimal point. Leading spaces will be ignored (unless in quotes). DATA
	statements can be included anywhere within a program and will be read
	in order.

SEE ALSO:   READ, RESTORE

##############################################################################

Variable:   DATE$
Syntax:     DATE$

DESCRIPTION:

	Returns the system date. The format is DD.MM.YYYY.

SEE ALSO: TIME$

##############################################################################

Command: DEC
Syntax:  DEC <num-variable>
	
DESCRIPTION:

	Decrement Variable a. The result is a=a-1.

SEE ALSO: INC

##############################################################################

Keyword: DEFAULT
Syntax:  SELECT ... DEFAULT ... ENDSELECT
	
DESCRIPTION:

	See SELECT.

SEE ALSO: SELECT

##############################################################################

Command: DEFFILL
Syntax:  DEFFILL <col>,<style>,<pattern>
	
DESCRIPTION:

	Sets fill colour and pattern.
	<col>     - not used at the moment
	<style>   - 0=empty, 1=filled, 2=dots, 3=lines, 4=user (not used)
        <pattern> - 24 dotted patterns and 12 lined can by chosen.

SEE ALSO: DEFLINE, DEFTEXT

##############################################################################

Command:    DEFFN
Syntax:     DEFFN <function-name>[$][(<variable list>)]=<expression>

DESCRIPTION:

	This statement allows the user to define a single line inline function
	that can thereafter be called by FN name or @name. This is a handy way
	of adding functions not provided in the language. The expression may be
	a numeric or string expression and must match the type the function
	name would assume if it was a variable name. The name must adhere to
	variable name syntax.

EXAMPLES: 
	DEFFN av(x,y)=SQR(x^2+y^2)  
	a=@av(b,c)   ! call av       
	DEFFN add$(a$,b$)=a$+b$

SEE ALSO:  FUNCTION, GOSUB
##############################################################################

Command:    DEFLINE
Syntax:     DEFLINE <style>,<thickness>[,<begin_s>,<end_s>]

DESCRIPTION:

	Sets line style, width and type of line start and end.
        <style>            -- determines the style of line:
 			      1 Solid line
 			      2 Long dashed line
 			      3 Dotted
 			      4 Dot-dashed
 			      5 Dashed
 			      6 Dash dot dot ..
 			      7 User defined (not used)
        <thickness>        -- sets line width in pixels.
        <begin_s>,<end_s>  -- The  start  and  end  symbols  are  defined  
	                      by  the   last parameter, and can be:
 			      0 Square
 			      1 Arrow
 			      2 Round

SEE ALSO: LINE, DEFFILL
##############################################################################
DEFMARK c,a,g      -+- define: colour, size, type (POLYMARK)        
                    |  c     colour                         
                    |  a     type of marker                 
                    |        (1=. 2=+ 3=* 4=[] 5=+ 6=#)     
                    +- g     size of marker (0,20,40,60,80,100)                        
##############################################################################

Command:    DEMOUSE
Syntax:     DEMOUSE <style>

DESCRIPTION:

	Chooses a pre-defined mouse form.
        The following mouse forms are available :

           0=arrow             1=expanded (rounded) X
           2=busy bee          3=hand, pointing finger
           4=open hand         5=thin crosswire
           6=thick crosswire   7=bordered crosswire
	   and about 100 other X-Window specific symbols.

SEE ALSO: HIDEM, SHOWM	   
##############################################################################

Command:    DEFTEXT
Syntax:     DEFTEXT <colour>,<attr>,<angle>,<height>,<width>

DESCRIPTION:

	Defines the colour,style,rotation and size of text
        to be printed using the LTEXT command.

        <colour> not used.
        <attr> text style - 0=normal 1=bold 2=light 4=italic
           8=underlined 16=outlined (can be combined).
        <angle>  rotation in degrees 
        <width> and <height> size of text in % 
	         (100% correspondt to 100 Pixel font)

SEE ALSO: LTEXT, TEXT
##############################################################################

Function: DEG()
Syntax:  <num-expression>=DEG(<num-expression_x>)
	
DESCRIPTION:

	Converts x from radians to degrees. 
	
SEE ALSO: RAD()

##############################################################################

Command: DELAY
Syntax:  DELAY <num-of-seconds>	

DESCRIPTION:

	Same as PAUSE. Delays program execution by <num-of-seconds> seconds.	

SEE ALSO: PAUSE
##############################################################################

Command: DIM
Syntax:  DIM <arrayname>(<indices>)[,<arrayname>(<indices>),...]

DESCRIPTION:

	Sets the dimensions of an array or string array.

EXAMPLES:
	DIM a(10)
	DIM b(100,100)
	DIM c$(20,30,405,6)

SEE ALSO: ERASE, DIM?()

*##############################################################################

Function: DIM?()
Syntax:  <num-result>=DIM?(<array-name>())
	
DESCRIPTION:

	Determines the number of elements in an array.
        Note - arrays have an element '0'.
EXAMPLE:
	DIM a(10,10)
	PRINT DIM?(A())     Result: 121
	
SEE ALSO: DIM
##############################################################################

Command: DIV
Syntax:  DIV <num-var>,<num-expression>

DESCRIPTION:

	Divides the value of var by n. As var=var/n but faster.

SEE ALSO: ADD, MUL, SUB
*##############################################################################

Function: DIV()
Syntax:  <num-result>=DIV(<num-expression>,<num-expression>)
	
DESCRIPTION:

	Divides the first value by second. 

SEE ALSO: ADD(), MUL(), SUB()

##############################################################################

Command: DO
Syntax:  DO ... LOOP
	
DESCRIPTION:

	DO implements an unconditional
        loop.  The  lines  between the DO line and the LOOP line form the loop
        body. The unconditional DO...LOOP block  simply  loops
        and the only way out is by EXIT IF or BREAK (or GOTO).

SEE ALSO: LOOP, EXIT IF, BREAK, WHILE
EXAMPLE:
        DO
            INPUT a$
            EXIT IF a$=""
        LOOP


##############################################################################

Keyword:   DOWNTO     
Syntax:    FOR ... DOWNTO ...

DESCRIPTION:

	Used within a FOR..NEXT loop as a counter. Instead of using  STEP -1, 
	the command DOWNTO is used,  however STEP is  not  possible with
	DOWNTO. eg: FOR c=100 DOWNTO 1 is the same as FOR c=100 TO 1 STEP -1

SEE ALSO: FOR, TO, NEXT, STEP
##############################################################################

Function: DPEEK()
Syntax:  <num-result>=DPEEK(<adr>)
	
DESCRIPTION:

	Reads 2 bytes from address <adr> (a word).  

SEE ALSO: PEEK(), LPEEK(), DPOKE

*##############################################################################

Command: DPOKE
Syntax:  DPOKE <adr>,<num-expression>
	
DESCRIPTION:

	Writes <num-expression> as a 2 byte word to address <adr>.

SEE ALSO: PEEK(), LPEEK(), POKE, DPEEK()
##############################################################################

Command: DRAW
Syntax:  DRAW [<x1>,<y1>][TO <x2>,<y2>][TO <x3>,<y3>][TO ...]
	
DESCRIPTION:

	Draws points and connects two or more points with straight lines. DRAW
	x,y is the same as PLOT x,y. DRAW TO x,y connects the point to the last
	set  point (set by PLOT, LINE or DRAW).

SEE ALSO: LINE, PLOT

##############################################################################

Command: DUMP
Syntax:  DUMP	 
         DUMP "@" 
         DUMP ":" 
         DUMP "#" 
         DUMP "K" 
         DUMP "F" 

DESCRIPTION:

	Query Information about stored Variables, names: 

	DUMP                    -- Lists all used variable names
        DUMP "@"                -- list of functions and procedures
        DUMP ":"                -- list of all labels
        DUMP "#"                -- list of open Files
        DUMP "K"                -- list of X11-Basic commands
        DUMP "F"                -- list of X11-Basic functions

SEE ALSO: LIST, PLIST, HELP

##############################################################################
##############################################################################

Command:  ECHO
Syntax:   ECHO {ON|OFF} 

DESCRIPTION:

	Switches the trace function on or off. This causes each command to 
        be listed on the stdout.

SEE ALSO: TRON, TROFF

##############################################################################

Command:  EDIT
Syntax:   EDIT 

DESCRIPTION:

	EDIT invokes the standart editor (given by the environment variable 
	$(EDITOR) to  edit  the  BASIC
        program in memory. 
	The command invokes the following actions:

	- SAVE "name.~~~"   writes the BASIC-program into a temporary file,                     
        - calls the editor '$EDITOR', waits until editor is closed      
        - NEW  clears internal values                
        - LOAD "name.~~~"   reads the BASIC-program  from the temporary file.    
		
	You may want to SAVE the file before using the EDIT
        command if the file has not yet been saved in order to choose  a  name
        at  that  occasion.  The default name is "name.~~~". This command
        requires that the editor installed on  your  system  does  not  detach
        itself from the calling process or EDIT will not recognize any changes
        (in that case, use LOAD to load the modified source code).

SEE ALSO: LOAD, SAVE
##############################################################################

Command:  ELLIPSE
Syntax:   ELLIPSE <x>,<y>,<a>,<b> [,<w0>,<w1>]

DESCRIPTION:

	Draws an ellipse at <x>,<y>, having <a> as  horizontal radius and <b>
	vertical radius The optional angles <w0> and <w1> give start and end
	angles in degrees, to create an elliptical arc.

SEE ALSO: PELLIPSE, CIRCLE

##############################################################################

Command:  ELSE, ELSE IF
Syntax:   ELSE 
	  ELSE IF <expression>
DESCRIPTION:

	ELSE IF  <expression>  introduces another  condition  block  and 
	the  unqualified  ELSE  introduces the default condition block in a
	multi-line IF statement. 
SEE ALSO:  IF, ENDIF
EXAMPLE:       
       IF (N=0)
           PRINT "0"
       ELSE IF (N=1)
           PRINT "1"
       ELSE
           PRINT "Out of range"
       ENDIF

##############################################################################

Command:    END
Syntax:     END

DESCRIPTION:

	END  terminates  program  execution. The interpreter switches to 
	interactive mode.

SEE ALSO:   STOP, QUIT

##############################################################################

Command:    ENDFUNCTION
Syntax:     ENDFUNCTION

DESCRIPTION:

	Terminates a user defined function. The Program must 
	return with a RETURN command.

SEE ALSO:   FUNCTION, RETURN

##############################################################################

Command:    ENDIF
Syntax:     ENDIF

DESCRIPTION:

	ENDIF terminates a multi-line IF block.

SEE ALSO: IF, ELSE, ELSE IF

##############################################################################

Command:    ENDSELECT
Syntax:     ENDSELECT

DESCRIPTION:

	Terminates a SELECT block.

SEE ALSO: SELECT, DEFAULT, CASE

##############################################################################

Command:    ENV$()
Syntax:     <string-result>=ENV$(<env-variable>)

DESCRIPTION:

	ENV$() returns the  current  value of  the  specified  "environment 
	variable". Environment variables are string variables maintained by the
	operating system.  These  variables typically   are  used  to  save 
	configuration  information.   Use the SETENV command to set the values
	of environment variables.

SEE ALSO: SETENV

EXAMPLE:
        PRINT ENV$("USER")
        Result: hoffmann

##############################################################################

Function:    EOF()
Syntax:      <boolean-result>=EOF(#<dev-number>)

DESCRIPTION:

	EOF() checks the end-of-file status of  a file  previously opened for
	reading by the OPEN command. It returns -1 (TRUE) if the end of file
	has been reached, otherwise null (FALSE).

SEE ALSO: OPEN
EXAMPLE:
        OPEN "I",#1,"filename"
        WHILE NOT EOF(#1)
            LINEINPUT #1,a$
        WEND
        CLOSE #1

##############################################################################

Operator:   EQV
Syntax:     <num-result>=<num-expression> EQV <num-expression>

DESCRIPTION:

	The operator EQV (equivalence) produces a TRUE result  only  if  the 
	arguments of both are either TRUE or both  FALSE.  (same as NOT(x XOR
	y)) and ((A IMP B) AND (B IMP A)).
	
	table:      A  |  B  |  A EQV B
 		  -----+-----+-----------
 		   -1  | -1  |   -1
 		   -1  |  0  |    0
 		    0  | -1  |    0
 		    0  |  0  |   -1
 
SEE ALSO: TRUE, FALSE, NOT, XOR, IMP

*##############################################################################

Function:   EQV()
Syntax:     <num-result>=EQV(<num-expression>,<num-expression>)

DESCRIPTION:

	Binary Function of logical operator EQV.

SEE ALSO: EQV
EXAMPLE:
           PRINT BIN$(EQV(15,6),4) 
	   Result:  0110


##############################################################################

Command:    ERASE
Syntax:     ERASE <array>()[,<array>(),...]

DESCRIPTION:

	Deletes an array and releases the dimensioned area.

SEE ALSO:  DIM
##############################################################################

Variable:   ERR
Syntax:     ERR

DESCRIPTION:

	Returns the error code of latest occurred error.

SEE ALSO: ERROR, ERR$()

##############################################################################

Function:   ERR$()
Syntax:     <string-result>=ERR$(<error-nr)

DESCRIPTION:

	Returns, as a string containing the X11-Basic error mesage which
	belongs to the error number. 

EXAMPLE:

PRINT "X11-Basic Error messages:"
FOR i=0 TO 255
  PRINT i,ERR$(i)
NEXT i

SEE ALSO: ERR

##############################################################################

Command:    ERROR
Syntax:     ERROR <error-number>

DESCRIPTION:

       ERROR simulates an error, i.e., displays the
       message  appropriate for a given error code or calls the error handler
       if one was installed via the ON ERROR command. This command is helpful
       in  writing  ON  ERROR  GOSUB  routines  that  can identify errors for
       special treatment and then ERROR ERR (i.e. default handling)  for  all
       others. 

EXAMPLE:

> ERROR 245
Line -1: * Timeout


SEE ALSO:       ON ERROR GOSUB, ERR

##############################################################################
Command:    EVAL
Syntax:     EVAL a$

DESCRIPTION:

	Evaluate or execute X11-Basic command, which is in a$.
	
EXAMPLE:

b$="a=5"
a$="print a"
EVAL a$
EVAL b$
EVAL a$

SEE ALSO: EVAL(), &	
##############################################################################
Function:    EVAL()
Syntax:      a=EVAL(b$)

DESCRIPTION:

	Evaluate expression, which is in b$.
	
EXAMPLE:

b$="sin(0.5*exp(0.001))"
result=EVAL(b$)

SEE ALSO: EVAL, &
##############################################################################

Function:   EVEN()
Syntax:     <bool-result>=EVEN(<num-expression>)

DESCRIPTION:

	Returns true (-1) if the number is even, else false (0).

SEE ALSO: ODD()

##############################################################################
Command:   EVENT
Syntax:    EVENT typ,[x,y,xroot,yroot,s,k,ks,t$]

DESCRIPTION:

	Waits until any of the KEYEVENT, MOUSEEVENT, MOTIONEVENT occurs.

	typ determines whichof the events have occured:
	
	typ=6        --- motionevent
	typ=14       --- MOUSEEVENT
	typ=2        --- keyevent

	x,y          --- Mouse position relative to window
	xroot,yroot  --- Mouse position relative to screen
	s            --- State of the Alt, Caps, Shift keys
	t$           --- Character of pressed key

SEE ALSO: KEYEVENT, MOUSEEVENT, MOTIONEVENT
##############################################################################

Command:    EVERY
Syntax:     EVERY <seconds> GOSUB <procedure>
	    EVERY CONT
	    EVERY STOP

DESCRIPTION:

	The command EVERY causes the procedure to be called every <seconds>
	seconds. Using EVERY STOP, the calling of a procedure can be 
	prevented. With EVERY CONT this is again allowed. 

SEE ALSO: AFTER

##############################################################################

Command: EXEC
Syntax:  EXEC <adr>[,<parameter-list>]

DESCRIPTION:

	Calls a machine code or C subroutine at address <adr> without return
	value.
	Optinal parameters are passed on the stack. (like in C).
	The default parameter-type is (4-Byte) integer.
	If you want to specify other types, please use prefixes:
	
	D: -- double (8-Bytes)
	F: -- float  (4-Bytes)
	L: -- long int

SEE ALSO: CALL, EXEC()

*##############################################################################

Function: EXEC()
Syntax:   <int-return>=EXEC(<adr>[,<parameter-list>])

DESCRIPTION:

	Calls a machine code or C subroutine at address <adr> and returns
	an integer value.
	Optinal parameters are passed on the stack. (like in C).
	The default parameter-type is (4-Byte) integer.
	If you want to specify other types, please use prefixes:
	
	D: -- double (8-Bytes)
	F: -- float  (4-Bytes)
	L: -- long int

SEE ALSO: CALL, EXEC

##############################################################################

Function:   EXIST()
Syntax:     <bool-result>=EXIST(<filename>)

DESCRIPTION:

	Returns TRUE (-1) if the file is present on
        a file system. 
	
	

#############################################################################

Command:    EXIT IF
Syntax:     EXIT IF <expression>

DESCRIPTION:

	The innermost loop will be exited if the expression is true.
	WHILE,  REPEAT,  DO  and  FOR  loops  can  be
        aborted  prematurely  with  the  EXIT command. EXIT leaves the current
        (innermost) loop immediately. EXIT IF leaves the current loop only  if
        the expression after EXIT IF is not FALSE (not null).
	
SEE ALSO:  DO, WHILE, FOR, REPEAT, BREAK, IF	

##############################################################################

Function:   EXP()
Syntax:     <num-result> = EXP(<num-expression>)
DESCRIPTION:

	EXP() returns the exponential value of  its argument  (e  to  the 
	specified  power).

SEE ALSO:    Operator  ^ 
EXAMPLE:
       PRINT EXP(1)
       Result: 2.718281828459
       
##############################################################################

Function:   EXPM1()
Syntax:     <num-result> = EXPM1(<num-expression>)
DESCRIPTION:

	Returns a value equivalent to `exp(x)-1'.  It
        is computed in a way that is accurate even if the value of
        x is near zero--a case where `exp(x)-1' would be  inaccurate  
	due  to subtraction of two numbers that are nearly
        equal.

SEE ALSO: LOG1P(), EXP()
EXAMPLE:
       PRINT EXPM1(1)
       Result: 1.718281828459
       
##############################################################################
##############################################################################
Function:    FACT()
Syntax:      <num-result>=FACT(<num-expression>)

DESCRIPTION:

	Calculates  the factorial (n!)

##############################################################################

Variable:   FALSE 
Syntax:     FALSE
  	  
DESCRIPTION:

	Constant 0. This is simply another way of expressing
        the value of a condition when it is false and is equal
        to zero.

SEE ALSO: TRUE
##############################################################################
FFT a(),i [,...] -- Fouriertransformation. i=-1 Rücktransformation
			   Dim?(a()) muss Zweierpotenz sein.
##############################################################################

Command:  FILESELECT
Syntax:   FILESELECT <title$>,<path$>,<default$>,<string-variable>
  	  
DESCRIPTION:

	Opens a fileselect box.
        <title$> gives a short title to  be placed in the fileselect box.
	
	<path$>  path - if none specified  then  the  default path is assumed.

	<default$>  contains the name of the file to apppear  in  the 
	   selection line. ("" for no default).

	FILESELECT returns the selected filename (including path) in 
	<string-variable>. If CANCEL is selected an empty string is returned.

SEE ALSO: XLOAD, XRUN, FSEL_INPUT()
EXAMPLE:
	FILESELECT "LOAD File",".\*.dat","input.dat",file$
##############################################################################
FIT a(),a(),???,???[,???,???,???,???,???,???]
FIT_LINEAR x(),y()[,[xerr(),]yerr()],n,a,b[,siga,sigb,chi2,q]
			-- Lineare Regression optional mit Fehlerbalken in beide
			   Richtungen. n=Anzahl der Fitpunkte, f(x)=a+b*x

##############################################################################

Function:  FIX()
Syntax:    <num-result>=FIX(<num-expression-x>)
  	  
DESCRIPTION:

	Returns the integer of x after it has been rounded. Same as INT(x)
	for positive numbers but for negative numbers INT(-1.99)=-2 AND
	FIX(-1.99)=1. FIX is identical to the function TRUNC and complements
	FRAC.

SEE ALSO: INT(), TRUNC(), FRAC(), ROUND()
##############################################################################

Function:  FLOOR()
Syntax:    <num-result>=FLOOR(<num-expression-x>)
  	  
DESCRIPTION:

	Round x down to the nearest integer.

SEE ALSO: INT(), FIX()
##############################################################################

Command:   FLUSH
Syntax:    FLUSH [#<device-name>]
  	  
DESCRIPTION:

	Flushes the output to the file or console. Usually a Line is printed
	when the newline character is encountered. To enforce output of
	everything which has been printed so far use FLUSH.

SEE ALSO: PRINT

##############################################################################

Command: FOR 
Syntax: FOR <variable> = <start-expression> TO <target-expression> [STEP <increment-expression>]
        FOR <variable> = <start-expression> DOWNTO <target-expression> [STEP <increment-expression>]
  	  
DESCRIPTION:

	FOR  initiates  a  FOR...NEXT  loop  with  the specified   <variable>  
	initially   set   to  <start-expression>  and incrementing in
	<increment>  steps  (default  is  1).  The  statements between  FOR and
	NEXT are repeated until the variable value reaches or steps  over 
	<target-expression>.  

SEE ALSO:  NEXT
EXAMPLE:         
	FOR n=2 TO 0 STEP -1
          PRINT n,
        NEXT n
        RESULT: 2  1  0 

##############################################################################

Function:   FORK()
Syntax:     <int-result>=FORK()

DESCRIPTION:

	FORK()  creates a child process of the running task (usually the 
	X11-Basic interpreter with the Basic program) that differs from the 
	parent
        process only in its PID and PPID, and  in  the  fact  that
        resource  utilizations are set to 0.
	
	On  success,  the  PID of the child process is returned in
        the parent's thread of execution, and a 0 is  returned  in
        the child's thread of execution.  On failure, a -1 will be
        returned in the parent's context, no child process will be
        created.

EXAMPLE:
	a=FORK()
	IF a=-1
	  PRINT "error"
	  QUIT
	ELSE IF a=0
	  PRINT "I am child"
	ELSE
	  PRINT "I am parent. My child is PID=";a
	ENDIF
	
##############################################################################

Function:   FORM_ALERT()
Syntax:     <num-result>=FORM_ALERT(<default-button>,<string$>)
DESCRIPTION:

	Creates an alert box.
           button  = number of the default button (0= none).
           string$ = string defining the message in the alert.  
	   Note that the square brackets are part  of  the 
           string:
           [i][Message][Buttons]
           where i = the required alert symbol - see ALERT.
	FORM_ALERT returns the number of the selected Button.

SEE ALSO: ALERT           
EXAMPLE:  
	~FORM_ALERT(1,"[0][This is my message!][OK]")
##############################################################################

Function:   FORM_CENTER()
Syntax:     <num-result>=FORM_CENTER(tree,x,y,w,h)

DESCRIPTION:

	Centers the tree, and returns its coordinates.
           INPUT: tree  - address of the object tree.
           OUTPUTS:
           x,y    coordinates of top left corner
           w,h    form width and height.
           returns a reserved value.

##############################################################################

Function:   FORM_DIAL()
Syntax:     <num-result>=FORM_DIAL(flag,x1,y1,w1,h1,x2,y2,w2,h2)

DESCRIPTION:

	Release (or reserve) a rectangular screen area and draw  an 
        expanding/shrinking rectangle.
        Returns 0 if an error occured.
           flag     function
           0         reserve a display area.
           1         draw expanding box.
           2         draw shrinking box.
           3         release reserved display area.
           x1,y1  top left corner of rectangle at min size
           w1,h1  width & height  "    "       "  "    "
           x2,y2  top left corner of rectangle at max size
           w2,h2  width & height   "    "      "  "    "

##############################################################################

Function:   FORM_DO()
Syntax:     <num-result>=FORM_DO(tree,obj)

DESCRIPTION:

	Manages an Object tree, interacts with the user
	until  an  object 
           with EXIT or TOUCH EXIT status is clicked on.
           Returns  the number of the object whose clicking or  double 
           clicking  caused the function to end.  If it was  a  double 
           click, bit 15 will be set.
           tree      = address of the object tree.
           obj       = Number of the first editable field (if there is one). 

##############################################################################

Function:   FRAC()
Syntax:     <num-result> = FRAC(<num-expression>)
DESCRIPTION:

	FRAC() returns the fractional part of  its argument.

SEE ALSO:   INT(), CINT(), TRUNC(), ROUND()
EXAMPLE:
       PRINT FRAC(-1.234)
       Result: -0.234
##############################################################################

Command:   FREE
Syntax:    FREE <adr>

DESCRIPTION:

	Frees a previously allocated Memory block.

SEE ALSO: MALLOC()
##############################################################################
a=FREEFILE()            -- Returns first free filenumber or -1 on error.
##############################################################################
Command:    FUNCTION
Syntax:     FUNCTION <name>[$][(<expression> [, ...])]
DESCRIPTION:

	FUNCTION starts a user-defined multi-line function  that calculates and
	returns a value from an optional list of parameters. The FUNCTION is
	called by using the function name preceeded by a @ in an expression. 
	The  function return type can either be a numerical value or a string.
	In the latter case, the function name must end  with  the "$" 
	precision  qualifier.  A FUNCTION returns a result with the RETURN
	command inside the function. In a function,  RETURN can be  used 
	several  times, with IF or the like. A function cannot be terminated 
	without a RETURN command being before the ENDFUNC  command.  In a
	function name ending with the $ character the function  returns a
	string result.

	All variables declared inside the FUNCTION block are global variables
	unless you declare them as local with the LOCAL command. The FUNCTION
	name may be followed  by  a  list  of  parameter variables 
	representing  the values and variables in the calling line. Variables
	in the calling line reach the FUNCTION "by-value" unless the VAR
	keyword is used in the calling line. In that case, the variable is
	passed "by-reference" to the FUNCTION so that the  FUNCTION  "gets"
	the  variable  and not only its value. Variables passed "by-reference"
	can be changed by the FUNCTION. The FUNCTION  block  is  terminated 
	by  an  ENDFUNCTION statement which resumes execution of the calling
	expression. Unlike a  PROCEDURE-subroutine, a FUNCTION must return a
	value.

SEE ALSO: ENDFUNCTION, RETURN, DEFFN, LOCAL, PROCEDURE
EXAMPLE:
	FUNCTION theta(x,a)
	  if x>a
	    RETURN 0
	  else 
	    RETURN a
	  endif
	ENDFUNCTION
##############################################################################
#############################################################################

Function: GASDEV()
Syntax:   <num-result>=GASDEV(<num-expression>)

DESCRIPTION:

	Returns a random number which is gauss distributed. The numbers range 
	from minus infinity to infinity but values around 0 are much more 
	likely. The argument is taken as a seed for the random generator.
	
SEE ALSO: RND()

##############################################################################

Command: GET
Syntax : GET <x1>,<y1>,<x2>,<y2>,<var$>

DESCRIPTION:

	GET  puts  a section of the graphic window into a  string  variable 
	(x1,y1 and x2,y2 are coordinates of  diagonally  opposite corners). 

SEE ALSO:  PUT
#############################################################################

Function: GET_COLOR()
Syntax:   <num-result>=GET_COLOR(<red-value>,<green-value>,<blue-value)

DESCRIPTION:

	GET_COLOR() returns acolor number for the specified color.
	The rgb-values range from 0 (dark) to 65535 (bright).
	The returned number depends on the screen depth of the X-Server.
	For 8 bit a color cell is allocated or if there is no free cell, a
	color is chosen which is most similar to the specified.
	The color numbers may be passed to the COLOR command.
	
EXAMPLE:   
	yellow=GET_COLOR(65535,65535,0)
	COLOR yellow

SEE ALSO:  COLOR
#############################################################################

Function: GLOB()
Syntax:   <bool>=GLOB(name$,pattern$[,flags])

DESCRIPTION:

GLOB() checks if name$ matches the wildcard pattern pattern$ 
       and gives -1 (TRUE), else 0 (FALSE). The kind of check can be
       secified with the flags parameter.

       flags
         0    -- default, no extras
	 1    -- name$ is treated as a filename
	         (Chars '/' are not matched)
         2    -- Backslashes quote special characters
         4    -- special treatment of '.'
         8    -- just check path of file name name$
        16    -- case insensitive

EXAMPLES:

glob("abcd","abc?")         Result: -1
glob("abcd","*")                    -1
glob("abc","ab??")                   0
glob("*a[0-9]*","sad33333")          0  		     

SEE ALSO: INSTR(), WORT_SEP

##############################################################################
Command: GOSUB      Abbrev.  @
Syntax:  GOSUB <preocedure-name>[(<parameterlist>)]

DESCRIPTION:

	GOSUB initiates a jump to the preocedure
        specified  after  GOSUB.  The  code  reached  that way must end with a
        RETURN statement which returns control to the calling line.

	A procedure name can begin with a digit and contain letters, numbers,
	dots and the underline dash. <parameterlist> contains expressions which
	are passed by value to local variables to the procedure. It is possible
	to call further procedures whilst in a procedure. It is even possible
	to call the procedure one is in at the time (recursive call).

EXAMPLES:
	GOSUB testproc
	@calcvac(12,s,4,t$)

SEE ALSO: RETURN
##############################################################################

Command: GOTO
Syntax:  GOTO <label-name>

DESCRIPTION:

	Allows an unconditional jump to a label.
	A label must be defined at the beginning of a line and must end in a
	colon.

EXAMPLE:
	GOTO here
	PRINT "never"
	here:
	PRINT "ever"

SEE ALSO: GOSUB	
##############################################################################
Command: GPRINT
Syntax:  GPRINT [[AT(),TAB(),SPC()]a$|b|const|USING|...{;',}]

DESCRIPTION:

	The GPRINT-statement writes all its arguments to the graphic window.
	It uses the same sytax as PRINT. Unlike PRINT thoe output goes to 
	the graphic window.

SEE ALSO: PRINT, TEXT
##############################################################################

Command: GRAPHMODE
Syntax:  GRAPHMODE <n>

DESCRIPTION:

	Sets the graphic mode:
	
	<n>=0     default
	<n>=1     replace
	<n>=2     transparent
	<n>=3     xor
	<n>=4     reverse transparent

		
##############################################################################

Function:   GRAY()
Syntax:     <num-result>=GRAY(<num-expression>)
DESCRIPTION:

	This function calculates the Gray-code of a given positive integer
	number. If the number is negative, the inverse Graycode is calculated.
		
EXAMPLE:   
	PRINT GRAY(34)
      	Result: 51

##############################################################################
##############################################################################

Command: HELP
Syntax:  HELP <string-pattern>

DESCRIPTION:

	Gives information of built in commands and functions.

EXAMPLE:
	HELP CL*

	Result:

	CLEAR [,...]
	CLEARW [,i%]
	CLOSE [,...]
	CLOSEW [,i%]
	CLR [,...]
	CLS	 

##############################################################################

Function: HEX$()
Syntax:   <string-result>=HEX$(<x>[,<n>])

DESCRIPTION:

	Changes the value of <x> into a string expression which contains the
	value in hexadecimal form. The optional parameter <n> specifies the
	number of  characters  to be used.

SEE ALSO: STR$(), BIN$()

##############################################################################

Command: HIDEM
Syntax:  HIDEM

DESCRIPTION:

	Switches off the mouse pointer.

SEE ALSO:  SHOWM, DEFMOUSE

##############################################################################

Command: HOME
Syntax:  HOME

DESCRIPTION:

	moves text cursor home. (upper left corner)

SEE ALSO:  PRINT AT()

##############################################################################

Command: HTAB
Syntax:  HTAB <num-expression>

DESCRIPTION:

	Positions  the text cursor to the  specified  column. 

SEE ALSO:  PRINT AT(), VTAB
##############################################################################

Function: HYPOT()
Syntax:  <num-result>=HYPOT(<num-expression:x>,<num-expression:y>)

DESCRIPTION:

	The hypot() function returns the sqrt(x*x+y*y).  This is
        the length of the hypotenuse  of  a  right-angle  triangle
        with sides of length x and y, or the distance of the point
        (x,y) from the origin.
	
SEE ALSO: SQRT()
EXAMPLE: 
	PRINT HYPOT(3,4)    Result: 5
#############################################################################
##############################################################################

Command:    IF
Syntax:     IF <condition>   [...  ELSE [IF <expression> ...] ... ENDIF

DESCRIPTION:

	Divides a program up into different blocks depending
        on how it relates to the 'condition'.

SEE ALSO: ELSE, ENDIF

##############################################################################

Operator:   IMP
Syntax:     <num-result>=<num-expression> IMP <num-expression>

DESCRIPTION:

	The operator IMP (implication) corresponds to a logical  consequence.
	The result is FALSE if a FALSE  expression follows a TRUE one. The
	sequence of the argument is important.

        Table:	      A  |  B  |  A IMP B
             	    -----+-----+-----------
 		     -1  | -1  |   -1
 		     -1  |  0  |    0
 		      0  | -1  |   -1
 		      0  |  0  |   -1
 
 
SEE ALSO: TRUE, FALSE, NOT, XOR, EQV

*##############################################################################

Function:   IMP()
Syntax:     <num-result>=IMP(<num-expression>,<num-expression>)

DESCRIPTION:

	Binary Function of logical operator IMP.

SEE ALSO: IMP


EXAMPLE:
           PRINT BIN$(IMP(13,14),4) 
	   Result:  1110

##############################################################################

Command:    INC
Syntax:     INC <num-variable>
DESCRIPTION:

	INC  increments  a  (numeric)  variable.  This command   is  
	considerably   faster  then  the  equivalent  statement "<variable> =
	<variable> + 1".

SEE ALSO:  ADD, DEC
##############################################################################

Command:    INFOW
Syntax:     INFOW [<window-nr>],<string-expression>

DESCRIPTION:

	Links the (new) information string to the window with the
        number. (This command has still no effect on UNIX).
	   
##############################################################################

Variable:   INKEY$
Syntax:     <string-result>=INKEY$

DESCRIPTION:

	Returns a string containing the ASCII characters of all keys which 
	have been pressed on the keyboard.

EXAMPLE: 
	REPEAT			! Wait until a
	UNTIL LEN(INKEY$)	! Key was pressed

SEE ALSO:  INP(), KEYEVENT
##############################################################################

Function:   INLINE$()
Syntax:     <string-result>=INLINE$(<string-expression>)

DESCRIPTION:

	7Bit-ASCII to Binary conversion.
	This command basically does a RADIX conversion (from 64 to 256) on the
	contents of the  string. This is intended to be used to include binary
	data into the  source code of a basic program.

EXAMPLE:
        sym$=INLINE$("$$$$$$$$0$&Tc_>$QL&ZD3cccccK]UD<*%D$$$$$$$$$") ! Train
	PUT_BITMAP sym$,92,92,16,16

SEE ALSO:  PUT_BITMAP

##############################################################################

Function:   INP(), INP\%(), INP\&()
Syntax:     <num-result>=INP(<channel-nr>) 
     	    <num-result>=INP\&(<channel-nr>) 
            <num-result>=INP\%(<channel-nr>) 

DESCRIPTION:

	Reads one byte from a file previously opened with OPEN (nr>0) or from
	the standart files (-1=stderr, -2=stdin, -4=stdout). INP&() reads a
	word (2 Bytes) and INP%() reads a long word (4 bytes).

EXAMPLE:
	~INP(-2)        ! Waits for a key beeing pressed
	PRINT INP%(#1)  ! reads a long from a previously opened file
	
SEE ALSO: OUT, INPUT$()
##############################################################################

Function:   INP?()
Syntax:     <bool-result>=INP?(<channel-nr>) 

DESCRIPTION:
	Determine the input status of the device.
	TRUE(-1) is device is ready (chars can be read) ortherwise 
	FALSE(0).

SEE ALSO: INP()

##############################################################################

Command: INPUT
Syntax:  INPUT [#<device-number>]|<prompt-expression>], <variable> [, ...]

DESCRIPTION:

	INPUT gets comma-delimited  input  from  the standart input or  from 
	a  previously  opened  file as specified by <device-number> (use the
	LINE INPUT function do  read  complete  lines from  a  file and BLOAD
	to load complete files). Any input is assigned to the variable(s)
	specified. If input  is  expected  from  a  console window,  then 
	<prompt-expression> is printed to the console window to request input
	from the user.

SEE ALSO:  LINEINPUT,  FORM INPUT AS, PRINT

EXAMPLE:
        INPUT #1,a$
        INPUT "Enter your name:",a$

##############################################################################

Function:   INPUT$()
Syntax:     <string-result>=INPUT$(<device-nr>,<len>) 

DESCRIPTION:

	Reads <len> characters from the keyboard and assigns them 
        to  a  string.  Optionally,  if  the device-number is 
        specified,  the  characters are read in from  a  previously 
        OPENed channel.

SEE ALSO: INPUT, INP()
##############################################################################

Function:   INSTR()
Syntax:     <num-result>=INSTR(<a$>,<b$>[,<n>]) 

DESCRIPTION:

	Searches to see if b$ is present in a$ and returns
        its position.
        <n> is a numeric expression indicating the position in a$
        at which the search is to begin (default=1).  If <n> is not given 
        the search begins at the first character of a$.
        If b$ is found in a$ the start position is returned, otherwise 0.
	
SEE ALSO: RINSTR(), GLOB()

##############################################################################

Function:   INT()
Syntax:     <num-result> = INT(<num-expression>) 
DESCRIPTION:

	INT() returns the  largest  integer  number smaller  than  or  equal 
	to its argument.

SEE ALSO:   CINT(), FRAC(), TRUNC(), ROUND()       
EXAMPLE:
	PRINT INT(1.4), INT(-1.7)
       	Result: 1, -2

##############################################################################
##############################################################################
Function:   JULDATE$()
Syntax:     d$=juldate$(a)

DESCRIPTION:

	Returns the date as string (see DATE$) given by the julian day number 
	a.
	
SEE ALSO: JULIAN(), DATE$
##############################################################################

Function:   JULIAN()
Syntax:     a=JULIAN(date$)

DESCRIPTION:

	Returns the julian date corresponding to the date given
	as a string in standart format. The number which is returned is 
	an integer number and has the unit days.

EXAMPLE:

  PRINT "Number of days since Sept. 11 2001: ";julian(date$)-julian("11.09.2001")
	
SEE ALSO: JULDATE$(), DATE$
##############################################################################
##############################################################################
Command:    KEYEVENT
Syntax:     KEYEVENT kc,ks[,t$,k,x,y,xroot,yroot]

DESCRIPTION:

	Waits until Key is pressed. (graphic window)
	After the key event has occured, the variables have
	following meaning:
	
        kc    -- Key-code
	ks    -- state of Shift/Control/Alt etc.
	t$    -- correspondig character
	x     -- x coordinate of mouse pointer relative to window
	y     -- y coordinate
	xroot -- x coordinate of mouse pointer relative to screen
	yroot -- y coordinate
	k     -- mouse button state

SEE ALSO: MOUSEEVENT
##############################################################################
##############################################################################

Function:   LEFT$()
Syntax:     <string-result> = LEFT$(<string-expression> [,<characters>]) 
DESCRIPTION:

	LEFT$() returns the specified  number  of characters  from  its 
	argument,  beginning  at  its left side. If the number of <characters>
	is not specified then LEFT$() returns only  the leftmost character.

SEE ALSO:   RIGHT$(), MID$()
EXAMPLE:
       PRINT LEFT$("Hello",1)
       Result: H
##############################################################################
Function:   LEN()
Syntax:     l=LEN(t$)

DESCRIPTION:

	Returns the length of a string.
EXAMPLE:
       PRINT LEN("Hello")
       Result: 5
	
##############################################################################

Command:  LET 
Syntax:   LET <variable> = <expression>
	  
DESCRIPTION:

	LET  assigns  the  value  of  <expression>  to <variable>.  The 
	interpreter  also supports implicit assignments, ie. the LET keyword
	before  an  assignment  may  be  omitted.  This  works because  the 
	first equal sign is regarded as assignment operator.
EXAMPLE:
       LET N=1

##############################################################################

Command:  LINE
Syntax:   LINE <x1>,<y1>,<x2>,<y2>

DESCRIPTION:

	Draws a straight line from (x1,y1) to (x2,y2).

SEE ALSO: DRAW, PLOT

##############################################################################

Command:  LINEINPUT
Syntax:   LINEINPUT [[#]<device-number>,] <string-variable>

DESCRIPTION:

	LINE INPUT reads an  entire  line  from atandart input  or from a
	previously opened file as specified by <device-number> (to load a 
	complete  file,  use  BLOAD).  Unlike  the regular INPUT command,
	LINEINPUT does not stop at delimiters (commas). 

SEE ALSO: INPUT

##############################################################################

Command:  LINK
Syntax:   LINK #<device-nr>,<string-expression:name>

DESCRIPTION:

	LINK linkes a  shared object file/library (*.so in /var/lib) 
	dynamically. It will from now on be addressed via the device-nr.

	The adresses of he symbols of that library can be read with the
	SYM_ADR() function.

	If the Library is not used any more it can be unlinked with the UNLINK
	command.
	
SEE ALSO:  UNLINK, SYM_ADR(), CALL

##############################################################################

Command:  LIST
Syntax:   LIST [<line-number>[,<line-number>]

DESCRIPTION:

	LIST displays  the  source  code  or  a  code segment.  Note  that the
	line number of the first line in a file is 1, that the second line is
	line 2 etc.
	
SEE ALSO: LLIST, PLIST, PRG$()

EXAMPLE:
       LIST
       LIST 1-10
       LIST 5  

##############################################################################

Command:  LOAD
Syntax:   LOAD <string-expression:name>

DESCRIPTION:

	Loads a program into memory.

SEE ALSO: XLOAD, MERGE, CHAIN

EXAMPLE:
	LOAD "testme.bas"
       
##############################################################################

Function:  LOC()
Syntax:   <int-result>=LOC(#<device-nre>)

DESCRIPTION:

	Returns the location of the file pointer for the file with  the device
	number.  The location is given in number of bytes from the start of 
	the file.

SEE ALSO: LOF()

##############################################################################

Command:  LOCAL
Syntax:   LOCAL <var>[,<var>,...]

DESCRIPTION:

	Declares several variables to be a local variable.

EXAMPLE:
	LOCAL a,b$,s()

##############################################################################

Command:  LOCATE
Syntax:   LOCATE <row>,<column>

DESCRIPTION:

	Positions the cursor to the specified location.

SEE ALSO: PRINT AT(), CRSLIN, CRSCOL

##############################################################################

Function:  LOF()
Syntax:   <int-result>=LOF(#<device-nre>)

DESCRIPTION:

	Returns length of file with device number.

SEE ALSO: LOC()

##############################################################################

Function:  LOG(), LOG10(), LN()
Syntax:   <num-result>=LOG(<num-expression>)
          <num-result>=LOG10(<num-expression>)
          <num-result>=LN(<num-expression>)

DESCRIPTION:

	Returns  the natural logarithm (log, ln) or the logarithm
        base 10 (log10).

SEE ALSO: EXP()

##############################################################################

Function:  LOGB()
Syntax:   <int-result>=LOGB(<num-expression>)

DESCRIPTION:

	Returns  the logarithm base 2 in interger values.

SEE ALSO: LOG()

##############################################################################

Function: LOG1P()
Syntax:   <num-result>=LOG1P(<num-expression>)

DESCRIPTION:

	Returns a value equivalent to log(1+x).  It
        is computed in a way that is accurate even if the value of
        x is near zero.

SEE ALSO: LOG(),EXP(), LN()

##############################################################################

Command:  LOOP
Syntax:   LOOP

DESCRIPTION:

	LOOP terminates a DO loop and can be used  as unqualified  loop
	terminator (such a loop can only be aborted with the EXIT command).
	Execution continues with  the DO line.
	
SEE ALSO: DO, EXIT IF, BREAK
##############################################################################

Function: LPEEK()
Syntax:   <int-result>=LPEEK(<num-expression>)

DESCRIPTION:

	Reads a 4 byte integer from address.

SEE ALSO: PEEK(), POKE 

##############################################################################

Command:  LPOKE
Syntax:   LPOKE <adr>,<num-expression>

DESCRIPTION:

	Writes a 4 byte integer to address <adr>.

SEE ALSO: DPOKE, POKE, PEEK()

##############################################################################
LSET t$=a$
##############################################################################

Command:  LTEXT
Syntax:   LTEXT x,y,t$

DESCRIPTION:

	Draws a Text at position x,y. The LTEXT command uses a 
	Linegraphic-Text, which allows the user to draw very large Fonts 
	and be independant of the system fonts. The Font Style can be influenced
	with the DEFLINE and the DEFTEXT command.

SEE ALSO: DEFTEXT, TEXT, DEFLINE

##############################################################################
##############################################################################

Function: MALLOC()
Syntax:   <int-result:adr>=MALLOC(<num-expression:size>)

DESCRIPTION:

	Allocates size bytes and returns a pointer to the allocated memory. 
	The memory is not cleared.

SEE ALSO: FREE(), MFREE(), REALLOC()
##############################################################################
Function: MAX()
Syntax:   m=MAX(a,b[,c,...])
          m=MAX(f())

DESCRIPTION:

	Returns the largest value out of the list of arguments or
	the largest value of an array.

SEE ALSO: MIN()	  
##############################################################################
Command:  MENU
Syntax:   MENU

DESCRIPTION:

	Performs menu check and action.  
	This  command  handles  EVENTs.   Prior  to  use,  the 
           required  action should be specified with a MENUDEF 
           command. For constant supervision of events, 
           MENU is usually found in a loop.

EXAMPLE:

MENUDEF field$(),menuaction
DO 
  pause 0.05
  MENU 
LOOP
PROCEDURE menuaction(k)
   ...
RETURN
   
SEE ALSO: MENUDEF
##############################################################################
Command:  MENUDEF
Syntax:   MENUDEF array$(),<procname>

DESCRIPTION:

	This command reads text for menu-header from \verb|array$()|  the
	string-array contains the text for menu-titles and menu-entrys

                    - end of row: empty string ""           
                    - end of menu-text: empty string ""
		    
	\verb|<procname>|  The  procedure to which control will be passed on 
		selection of a menu entry is determined. 

	\verb|<procname>| is a procedure with one parameter which is the number
		of the selected item to call when item was selected.

EXAMPLE:

field$()=["INFO","  Menutest  ","","FILE","  new","  open ...","  save","\
save as ...","--------------","  print","--------------","  Quit","",""]
MENUDEF field$(),menuaction
DO 
  pause 0.05
  MENU 
LOOP
PROCEDURE menuaction(k)
  PRINT "MENU selected ";k;" contents: ";field$(k)
  IF field$(k)="  Quit"
    QUIT
  ENDIF  
RETURN

SEE ALSO: MENU, MENUSET, MENUKILL
##############################################################################
Command:  MENUSET
Syntax:   MENUSET n,x

DESCRIPTION:

	Change apperance of menu-entry n with value x.
	       
                    x=0  ' '  normal, reset marker '^'      
                    x=1  '^'  set marker                    
                    x=2  '='  set menu-point non selectable 
                    x=3  ' '  set menue-point selectable  
		    x=4  check the menu entry  
                         '-'  permanent non selectable     

SEE ALSO: MENU			  
##############################################################################
Command: MENUKILL                     
Syntax:  MENUKILL

DESCRIPTION:

	Erases the menu, which prior has been defined with MENUDEF.

SEE ALSO: MENUDEF	
##############################################################################

Command:  MERGE 
Syntax:   MERGE <filename>

DESCRIPTION:

	MERGE appends a BASIC program to the program currently  in  memory. 
	Program  execution  is  not  interrupted. This command  typically  is 
	used  to  append  often-used  subroutines   at run-time.

SEE ALSO:    CHAIN, LOAD

EXAMPLE:
       MERGE "examples/hello.basic"
##############################################################################
Function: MID$()
Syntax:   m$=MID$(t$,s[,l])

DESCRIPTION:

	Returns l characters in a string from the positon s
	of the string t\$.
	If s is larger than the length of 
           t\$,  then an empty string is returned.  If l is omitted, 
           then the function returns only one character of the string from 
           position x.
	
SEE ALSO: LEFT$(), RIGHT$()	
##############################################################################
Function: MIN()
Syntax:   m=MIN(a,b[,c,...])
          m=MIN(f())

DESCRIPTION:

	Returns the smallest value out of the list of arguments or
	the smallest value of an array.

SEE ALSO: MAX()	  
##############################################################################

Function: MKI$(), MKL$(), MKS$(), MKF$(), MKD$()
Syntax:   <string-result>=MKI$(<num-expression>)
          <string-result>=MKL$(<num-expression>)
          <string-result>=MKS$(<num-expression>)
          <string-result>=MKF$(<num-expression>)
          <string-result>=MKD$(<num-expression>)


DESCRIPTION:

	Transforms a number into a character string.    \\
        MKI$ 16-bit number into a 2-byte string.        \\
        MKL$ 32-bit number into a 4-byte string.        \\
        MKS$ a number into a 4-byte float format.       \\
        MKF$ same as MKS$().                            \\
        MKD$ a number into a 8-byte double float format.


SEE ALSO: CVI(), CVF(), CVL()

##############################################################################

Operator:  MOD 
Syntax:    <num-result>=<num-expression:x> MOD <num-expression:y>

DESCRIPTION:

	Produces the remainder of the division of x by y.

SEE ALSO:  DIV, MOD()

*##############################################################################

Function:  MOD() 
Syntax:    <num-result>=MOD(<num-expression:x>,<num-expression:y>)

DESCRIPTION:

	Produces the remainder of the division of x by y.

SEE ALSO:  DIV, MOD

##############################################################################
Command:  MOUSE
Syntax:   MOUSE x,y,k

DESCRIPTION:

	Determines the mouse position (x,y) relative to the origin of the 
	graphics window and the status of the mouse buttons (k).
           k=0 no buttons pressed \\
           k=1 left button     \\
           k=2 middle button   \\
           k=4 right buttons   \\
	or any combinations.
	
SEE ALSO: MOUSEX, MOUSEY, MOUSEK	
##############################################################################
Command:   MOUSEEVENT
Syntax:    MOUSEEVENT x,[y,k,xroot,yroot,s]

DESCRIPTION:

	Waits until a mouse button is pressed (graphic window).
	Returns Mouse coorinate (x,y) relative to window, 
	mouse coorinate (xroot,yroot) relative to screen, mouse button and
	state of the Alt/Shift/Caps keys.
	

SEE ALSO: MOUSE, MOUSEX, MOUSEY, MOUSEK, KEYEVENT
##############################################################################

Variable:  MOUSEX, MOUSEY, MOUSEK, MOUSES 
Syntax:    <int-result:x>=MOUSEX
           <int-result:y>=MOUSEY
           <int-result:k>=MOUSEK
           <int-result:s>=MOUSES

DESCRIPTION:

	Determines the mouse position (x,y), the status of
        the mouse buttons (k) and the status of the Shift and Control keys (s):
           k=0 no buttons pressed \\
           k=1 left button     \\
           k=2 middle button   \\
           k=4 right buttons   \\
	or any combinations.

	s=0  no Keys           \\
	s=1  Shift\\
	s=2  CapsLock          \\
	s=4  Control           \\
	s=8  Alt               \\
	s=16 NumLock           \\
	s=64 Windows-Key       \\
	s=128 ScrollLock       \\
	or any combination.

SEE ALSO:  MOUSE, SETMOUSE, MOUSEEVENT

##############################################################################
Command: MOTIONEVENT
Syntax:  MOTIONEVENT x,y,xrrot,yroot,s

DESCRIPTION:

	Waits until the mouse has been moved. (graphic window).
	Returns new mouse coorinate (x,y) relative to window, 
	mouse coorinate (xroot,yroot) relative to screen and
	state of the Alt/Shift/Caps keys.
	

SEE ALSO: MOUSE, MOUSEX, MOUSEY, MOUSEK, MOUSEEVENT
##############################################################################
Command: MOVEW 
Syntax:  MOVEW n,x,y

DESCRIPTION:

	Moves Wondow n to absolute screen position x,y

SEE ALSO: OPENW, SIZEW, TITLEW
##############################################################################
Command:  MUL 
Syntax:   MUL <num-var>,<num-expression>

DESCRIPTION:

	Same as var=var*n but faster.

SEE ALSO: ADD, SUB, MUL(), DIV
*##############################################################################
Function:  MUL()
Syntax:    <num-result>=MUL(<num-expression>,<num-expression>)

DESCRIPTION:

	Returns product of two numbers.

SEE ALSO: ADD(), SUB(), MUL, DIV()
##############################################################################
##############################################################################

Command:  NEW
Syntax:   NEW

DESCRIPTION:

	NEW erases the program and all variables in memory (and stops execution 
	of program.)

SEE ALSO: CLEAR

##############################################################################

Command:  NEXT
Syntax:   NEXT [<variable>]

DESCRIPTION:

	NEXT terminates a FOR loop. FOR loops must be
        nested  correctly:  The variable name after NEXT is for looks only and
        can not be used to select a FOR statement.  Each  NEXT  jumps  to  the
        matching  FOR statement regardless if and what <variable> is specified
        after NEXT.
	
SEE ALSO: FOR

EXAMPLE:
        FOR n=1 TO 2
            FOR m=10 to 11
                PRINT "n=";n,"m=";m
            NEXT m
        NEXT n

##############################################################################

Command:  NOP, NOOP
Syntax:   NOP
	  NOOP

DESCRIPTION:

	No Operation: do nothing.

##############################################################################
##############################################################################
o$=OCT$(d%,n%)
ON * GOSUB proc1[,proc2,...]
ON BREAK GOSUB proc
##############################################################################

Command:      ON ERROR GOSUB
Syntax:       ON ERROR GOSUB <procedure>

DESCRIPTION:

       ON ERROR installs an error handling
       subroutine  that  gets  called  when  the  next error occurs. 

SEE ALSO:  GOSUB, ERROR

##############################################################################

Command:      OPEN
Syntax:       OPEN <mode>,<device-number>,<filename>[,<port-value>]

DESCRIPTION:

	OPEN opens the specified file for reading  or
        writing  or both. The <device-number> is the number you want to assign
        to the file (functions that read from files or write to  files  expect
        to  be  given this number). The device number must be between 0 and 99
        in the current implementation of X11-Basic. When you  close  a
        file,  the  device  number  is  released  and  can  be  used  again in
        subsequent OPEN statements.

<mode>	is a character string which indicates the way the File should be
	opened. The first character of that String may be "O", "I", "U" or "A".
	These characters correspont to the mode for which the file is opened:
	"I" -- INPUT,   "O" --OUTPUT, "A" -- APPEND and "U" -- UNSPECIFIED. 
	Open a file for INPUT if you want to read data from the file. If you
	open a file for OUTPUT, you can write  to  the  file. However,  all 
	data  that  was stored in the file (if the file already exists) is
	lost. If you want to write new data to a file while keeping the 
	existing  content,  open  the file for appending to it, using the
	APPEND mode. When you open a file using the RANDOM ("U") keyword, you can
	both  read from the file and write to the file at arbitrary positions.
	You can, for example, seek a position in the middle of  the  file  and
	start appending new lines of text. All file modes but INPUT create the
	file if it does not exist. OPEN "I" fails if the file  does  not exist 
	(use the EXIST() function before OPEN to be sure that the file exists).
	
	The second character specifies the type of File which should be opened 
	or created: 
	""   default opens regular file
        "C"  opens a socket connection
        "S"  Socket listen
        "A"  Socket accept connection
        "X"  extra settings for a special device following 
        (e.g. speed and parity of transmission via serial ports)

<port-nr> The portnr is used only by the OPEN "UC" statement. It determines the
	TCP/IP Port of connection (FTP, WWW, TELNET, MAIL etc.).


SEE ALSO: CLOSE, EXIST(), INPUT, LINEINPUT, PRINT, SEEK, LOF(), EOF(),
          LOC(), BLOAD, LINK

EXAMPLES:
	OPEN "I",#1,"data.dat"      ---- opens file "data.dat" for input
	OPEN "UC",#1,"localhost",80 ---- opens port 80 of localhost for read and#
					 write
	OPEN "UX:9600,N,8,1,DS,CS,RS,CD",#1,"/dev/ttyS1"  
                 ---- open COM2 for input and output with 9600:8:N:1

##############################################################################
Command:  OPENW
Syntax:   OPENW n

DESCRIPTION:

	Opens a graphic window. There can be up to 16 graphic windows
	opened. All graphic output goes to the window which was opened latest.
	OPENW can be used to switch between multiple windows. Window 1 os opened
	automatically on default when the first graphic command is executed and
	no other window is already opened.  

SEE ALSO : CLOSEW, MOVEW, SIZEW, TITLEW, ROOTWINDOW
##############################################################################
Command:  OUT
Syntax:   OUT #n,a

DESCRIPTION:

	Writes a byte a to an open channel n.

SEE ALSO: PRINT, INP()
##############################################################################
##############################################################################
Command:  PAUSE
Syntax:   PAUSE <sec>

DESCRIPTION:
	
	pauses <sec> seconds. 
	The resolution of this command is microseconds (in theory).

##############################################################################
Command:  PBOX
Syntax:   PBOX  x1,y1,x2,y2 

DESCRIPTION:

	Draws a filled box.
	
SEE ALSO: BOX, RBOX, DEFFILL, COLOR
##############################################################################
Command:  PCIRCLE	
Syntax:   PCIRCLE x,y,r[,a1,a2]

DESCRIPTION:

	Draws a filled circle (sector).
	
SEE ALSO: CIRCLE, DEFFILL, COLOR
##############################################################################
Function:  PEEK()
Syntax:    <int-result>=PEEK(<address>)

DESCRIPTION:

	PEEK() reads a byte from an address in memory. The following example 
	dumps a section of the internal memory near a string t\$.

EXAMPLE:

t$="Hallo, this is a string..."
i=varptr(t$)-2000
DO
  PRINT "$";HEX$(i,8,8)'
  FOR iu=0 TO 15
    PRINT HEX$(PEEK(i+iu) and 255,2,2)'
  NEXT iu
  PRINT '
  FOR iu=0 TO 15
    a=PEEK(i+iu)
    IF a>31
      PRINT CHR$(a);
    ELSE 
      PRINT ".";
    ENDIF
  NEXT iu
  PRINT
  ADD i,16
LOOP

SEE ALSO: POKE
##############################################################################
Command:  PELLIPSE
Syntax:   PELLIPSE x,y,a,b[,a1,a2]

DESCRIPTION:

	Draws a filled ellipse
	
SEE ALSO: PCIRCLE, ELLIPSE, DEFFILL, COLOR
##############################################################################
Command:  PLIST 
Syntax:   PLIST

DESCRIPTION:

	Outputs a formatted listing of the actual program in memory.
	Alos the internal tokens are printed ans some internal 
	Information. This is intended for internal use only.

EXAMPLE:
	
> PLIST
   0: $00001a |   0,0 |CLS
   1: $000279 |   0,0 |PRINT
   2: $000279 |   0,1 |PRINT " example how to use the ansi color spec."
   3: $000279 |   0,0 |PRINT
   4: $000279 |   0,1 |PRINT "X 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0"
   5: $310240 |  12,1 |FOR U=0 TO 3
   6: $310240 |  11,1 |  FOR J=0 TO 7
   7: $310240 |  10,1 |    FOR I=0 TO 7
   8: $000279 |   0,1 |      PRINT AT(J+6,2*I+2+16*U);CHR$(27)+"["+STR$(U)+";"+STR$(30+I)+";"+STR$(40+J)+"m *";
   9: $320266 |   7,1 |    NEXT I
  10: $320266 |   6,1 |  NEXT J
  11: $320266 |   5,1 |NEXT U
  12: $000279 |   0,0 |PRINT
  13: $00047f |   0,0 |QUIT
  14: $0008ff |   0,0 |=?=> 2303

	
SEE ALSO: LIST
##############################################################################
Command:  PLOT
Syntax:   PLOT x,y

DESCRIPTION:

	draws point at screen coordinate x,y

SEE ALSO: LINE, POINT(), COLOR
##############################################################################
Function:  POINT()
Syntax:    c=POINT(x,y)

DESCRIPTION:

	returns colour of graphic point x,y in current window

SEE ALSO: PLOT
##############################################################################


POKE adr%,byte%         -- writes Byte to address adr%
POLYLINE n,x(),y()      -- draw polygon in (x(),y())        
                    the first point = last point to draw
                      a closed polygon
POLYFILL n,x(),y()  draw filled polygon                
                    connects first point with last point
                      and fills the resulting polygon with
                      pattern defined in DEFFILL
POLYMARK n,x(),y()  draw polygon points                
                    type of points defined in DEFMARK
                    n        # of points
                    x(),y()  arrays with (x,y)-values of points
POS
PRBOX x1,y1,x2,y2       -- filled rounded box
t$=PRG$(i)              -- Programmzeile i (Quelltext)
##############################################################################
Command: PRINT    Abbrev. ?
Syntax:  PRINT [[AT(),TAB(),SPC(),COLOR()]a$|b|const|USING|...{;',}]

DESCRIPTION:

	   The print-statement writes all its arguments to the screen 
	   (standard output); after writing its last argument, print goes to
	   the next line (as in print "Hello ",a$," !"); to avoid this
	   automatic newline, place a semicolon (;) after the last argument (as
	   in print "Please enter your Name:";). To insert a tabulator instead
	   of the automatic newline append a colon (,), e.g. print "Please
	   enter your Name:", . Note that print can be abbreviated with a
	   single question mark (?). 
	   
    Advanced printing: PRINT AT(), PRINT colour and PRINT USING

      PRINT AT
      
	   For interactive programs you might want to print output at specific
	   locations. Try the next example: PRINT AT(4,7);"Test"

      TAB and SPC
	   PRINT "Hallo";TAB(30);"Test"
	   PRINT "Hallo";SPC(30);"Test"
	   
      PRINT COLOR
           PRINT COLOR(32,2);"Hallo"

           The COLOR statement takes up to three arguments. Their meaning is:

           Text Mode:	      	 Text color:	      Backgroud color:

	   0  default setting	 30  black		  40  black
	   1  intensive 	 31  red		  41  red
	   2  dark		 32  green		  42  green
          			 33  yellow		  43  yellow
	   4  underline 	 34  blue		  44  blue
	   5  blink		 35  magenta		  45  magenta
 				 36  cyan		  46  cyan
	   7  reverse		 37  white		  47  white
	
	   
      PRINT USING

	   To control the way numbers are printed, use the print using
	   statement: print 12.34 using "###.####" produces 12.3400. The format
	   string ("###.####") consists of hashes (#) with one optional dot and
	   it pictures the appearance of the number to print. 

SEE ALSO: GPRINT, STR$(), INPUT 	   

##############################################################################
Command:   PROCEDURE
Syntax:    PROCEDURE procname [(p1 [,p2] ... )]  * RETURN

DESCRIPTION:

	PROCEDURE starts a user-defined multi-line subroutine which can be
	executed by the GOSUB command. any number of parameters may be passed
	to the PROCEDURE via the parameter list. The Variables in that list act
	like local variables inside the subroutine.
	
	All variables declared inside the PROCEDURE block are global variables
	unless you declare them as local with the LOCAL command. The PROCEDURE
	name may be followed  by  a  list  of  parameter variables 
	representing  the values and variables in the calling line. Variables
	in the calling line reach the PROCEDURE "by-value" unless the VAR
	keyword is used in the calling line. In that case, the variable is
	passed "by-reference" to the PROCEDURE so that the  PROCEDURE  "gets"
	the  variable  and not only its value. Variables passed "by-reference"
	can be changed by the PROCEDURE. The PROCEDURE  block  is  terminated 
	by the RETURN statement which resumes execution of the calling
	expression. Unlike a FUNCTION-subroutine, a PROCEDURE can not return a
	value.

SEE ALSO: GOSUB, RETURN, LOCAL, FUNCTION
##############################################################################

PSAVE a$                -- writes the reformatted BASIC-program into file with 
                           the name a$      
PUT x,y,g$              -- displays graphic stored in g$ at postion x,y
PUTBACK [#n,]a         -- puts character a back to input channel n
PUT_BITMAP t$,i,i,i,i
##############################################################################
##############################################################################

Command: QUIT
Syntax:  QUIT [<return-code>]

DESCRIPTION:

	QUIT exits the interpreter.  You  may  set  a <return-code>  which 
	will  be  passed  to  the  program  running  the interpreter.
	
SEE ALSO: END
##############################################################################
	
##############################################################################
Function:  RANDOM()
Syntax:    <num-result> = RND(<maximum>)

DESCRIPTION:

	RANDOM()  returns  a  pseudo-random  integer number between  0 
	(inclusive) and <maximum> (exclusive).  The sequence of pseudo-random
	numbers is identical each time you start the interpreter unless the
	RANDOMIZE statement is used prior to  using RANDOM(): RANDOMIZE seeds
	the pseudo-random number generator to get a new sequence of numbers
	from RANDOM().

SEE ALSO: RND(), RANDOMIZE, GASDEV

EXAMPLE:
        PRINT RANDOM(10)
        Result: 8
##############################################################################

Command: RANDOMIZE
Syntax:  RANDOMIZE [<seed-expression>]

DESCRIPTION:

	RANDOMIZE seeds the pseudo-random number generator  to  get  a  new
	sequence of numbers from RND(). Recommended argument to RANDOMIZE is a
	"random" number to randomly  select  a sequence of pseudo-random
	numbers. If RANDOMIZE is not used then the sequence  of  numbers 
	returned  by  RND()  will  be identical each time the interpreter is
	started. If no argument is given, the TIMER value will be used as a
	seed.

SEE ALSO: RND(), TIMER
##############################################################################

Command: RBOX
Syntax:  RBOX x1,y1,x2,y2

DESCRIPTION:


	Draws a rectangle with rounded corners from the two
        diagonally opposite corner points 'x1,y1' and 'x2,y2'

SEE ALSO: BOX, PBOX, PRBOX
##############################################################################

Command: READ
Syntax:  READ var[,var2, ...] 

DESCRIPTION:

	Reads constant values from a DATA command and assigns them to a
        variable 'var'. Reading is taken from the last point a 
        RESTORE was done (if any).
	
SEE ALSO: DATA, RESTORE
	
##############################################################################
Command: RELSEEK
Syntax:  RELSEEK [#]n,d	

DESCRIPTION:

	Place file pointer on new relative position d which means it moves 
	the file pointer forward (d>0) or backwards (d<0) d bytes.

SEE ALSO: SEEK, LOC(), LOF(), EOF()

##############################################################################

Command: REM      Abbrev. '
Syntax:  REM This is a comment
         ' This also is a comment
DESCRIPTION:
	This command reserves the entire line for a comment.

COMMENT:

	Note, that rem is an abbreviation for remark. 

	Do use comments in your programs, the more the better. Yes, the
	program  will become longer, but it's nice to be able to understand a
	well- documented program that you've never seen before. Or one of your
	own  masterpieces that you haven't looked at for a couple of years.
	Don't  worry about the speed of your program, except in loops or often
	called  Procedures/Functions. There a comment-line (beginning with REM
	or ') will  slow the interpreter down. A comment after '!' has no
	influence on the  speed of a program, so you can use these everywhere.

SEE ALSO:  ! 
##############################################################################

Command: REPEAT
Syntax:  REPEAT ... UNTIL <expression>

DESCRIPTION:

	REPEAT initiates a REPEAT...UNTIL loop. The loop  ends  with  UNTIL 
	and  execution  reiterates  until  the  UNTIL <expression> is not FALSE
	(not null). The loop  body  is  executed  at least  once.

SEE ALSO:  DO, LOOP, UNTIL, EXIT IF, BREAK, WHILE
EXAMPLE:
        REPEAT
            INC n
        UNTIL n=10
##############################################################################

Function:   REPLACE$()
Syntax:     <string-result> = REPLACE$(<string-expression>, <search string>, <replace string> ) 
DESCRIPTION:

	REPLACE$() returns  string-expression where all <search string>
	have been replaced by <replace string>.

SEE ALSO:   INSTR(), WORT_SEP
EXAMPLE:
       PRINT REPLACE$("Hello","l","w")
       Result: Hewwo

##############################################################################

Command: RESTORE
Syntax:  RESTORE [<label>]

DESCRIPTION:

	RESTORE sets the  position  DATA  is  read from  to the first DATA line
	of the program (or to the first DATA line after <label> if RESTORE is
	used with an argument).

SEE ALSO: DATA, READ
EXAMPLE:
        READ  a, b, c
        RESTORE
        READ  a, b, c
        DATA  1, 2, 3
##############################################################################

Command: RESUME
Syntax:  RESUME
         RESUME NEXT
	 RESUME <label>

DESCRIPTION:

	 
	The  RESUME command is only meaningful with  error  capture 
        (ON ERROR GOSUB) where it allows a reaction to an error.

        RESUME repeats the erroneous command.  
        RESUME NEXT resumes program execution after an incorrect 
        command.
        RESUME <label> branches to the <label>.
        If a fatal error occurs only RESUME <label> is possible 

SEE ALSO: ON ERROR, GOTO, ERROR

##############################################################################

Command: RETURN
Syntax:  RETURN 
	 RETURN <expression>

DESCRIPTION:

	RETURN terminates  a  PROCEDURE  reached  via  GOSUB and
	resumes execution after the calling line. Note that code reached via ON
	JERROR  GOSUB  should  be  terminated  with  a RESUME NEXT, not with
	RETURN.

	RETURN <expression> states the result of the expression as a result of a
	user defined function. This can not be used in PROCEDURES but in FUNCTIONS.
	The expression must be of the type the function was. 

SEE ALSO: PROCEDURE, FUNCTION, ENDFUNCTION, RESUME, GOSUB, @, ON ERROR
EXAMPLE
        PROCEDURE testroutine
            PRINT "Hello World !"
        RETURN
        FUNCTION givemefive
            RETURN 5
        ENDFUNCTION

##############################################################################

Function:  RINSTR()
Syntax:    <int-result>=RINSTR(s1$,s2$[,n])  

DESCRIPTION:

	Operates in same way as INSTR except that search begins  at 
        the right end of s1$.
	tests if s2$ is contained in s1$, then      
        returns start-position of s2$, else 0.
        start comparison at pos. n (default=1)
        start comparison at right

SEE ALSO: INSTR()

##############################################################################

Function:  RND()
Syntax:    <num-result> = RND(<dummy>)

DESCRIPTION:

	RND()  returns  a  pseudo-random  number between  0  (inclusive) and 1
	(exclusive). The sequence of pseudo-random numbers is identical each
	time you start the interpreter unless the RANDOMIZE statement is used
	prior to  using RND(): RANDOMIZE seeds the pseudo-random number
	generator to get a new sequence of numbers from RND().

SEE ALSO:  RANDOMIZE, GASDEV(), RANDOM()

EXAMPLE:
        PRINT RND(1)
        Result: 0.3352227557149
#############################################################################

Function: ROUND()
Syntax:   <num-result>=ROUND(<num-expression:b>[,n])

DESCRIPTION:

	Rounds off a value to n fractional digits. 
	n<0: round to digits in front of the decimal point.

SEE ALSO: INT(), FIX(), FLOOR(), TRUNC()

##############################################################################
RSRC_FREE               -- frees GEM rsc-File (ATARI ST)
~RSRC_GADDR(type,index,addr)
RSRC_LOAD filename$     -- loads GEM rsc-File (ATARI ST)
##############################################################################

Command: RUN
Syntax:  RUN

DESCRIPTION:

	starts program execution (RUN)

SEE ALSO: STOP, CONT, LOAD
##############################################################################
##############################################################################
Command: SAVE
Syntax:  SAVE [a$]

DESCRIPTION:

	writes the BASIC-program into a file with the name a$      

SEE ALSO: LOAD

##############################################################################
Command: SAVESCREEN
Syntax:  SAVESCREEN t$

DESCRIPTION:
	
	Saves the whole Graphic-Screen (Desktop) into a file with name t$.
	The Graphics format is XWD (X-Window dump). Maybe later this will be
	changed to png (portable network graphic).

SEE ALSO: SAVEWINDOW
##############################################################################
Command: SAVEWINDOW
Syntax:  SAVEWINDOW t$

DESCRIPTION:
	
	Saves the actual X11-Basic Graphic-Window into a file with name t$.
	The Graphics format is XWD (X-Window dump). 

SEE ALSO: SAVESCREEN, SGET
##############################################################################
Command: SCOPE
Syntax:  SCOPE a(),typ,yscale,yoffset   -- Schnelles Plotten des Feldes a()
         SCOPE y(),x(),typ,yscale,yoffset,xscale,xoffset   -- 2D Plot

DESCRIPTION:
	
	
	
SEE ALSO: LINE, POLYLINE
##############################################################################
Command: SEEK
Syntax:  SEEK #n[,d]

DESCRIPTION:
	
	Place file pointer of channel n on new absolute position d (Default on
	Position 0 which is the beginning of File.)

SEE ALSO: RELSEEK, LOC(), EOF(), LOF()
##############################################################################


SELECT ???
SETENV t$=a$   -- Sets environmentvar t$ using value a$
##############################################################################
Command: SETFONT
Syntax:  SETFONT t$

DESCRIPTION:
	
	Loads and sets a X11 Font. t$ may be the fontname or any valid
	Font pattern.
	
SEE ALSO: TEXT
##############################################################################
Command: SETMOUSE 
Syntax:  SETMOUSE x,y[,k]

DESCRIPTION:

	The  SETMOUSE command permits the positioning of the  mouse 
        cursor under program control. Tje optional parameter k can 
        simulate the mouse button being pressed or released.
	
SEE ALSO: MOUSE
##############################################################################
Command: SGET
Syntax:  SGET screen$

DESCRIPTION:

	stores content of actual X11-Basic Graphics window in screen$.

SEE ALSO: SPUT, SAVEWINDOW
##############################################################################
Function: SGN()
Syntax:   a=SGN(b)

DESCRIPTION:

	SGN returns the sign of a number b. It may be
	-1 if b is negative
	 0 if b equals 0
	 1 if b is positive.

SEE ALSO: ABS()
##############################################################################
Function: SHM_ATTACH()
Syntax:   adr=SHM_ATTACH(id)

DESCRIPTION:

	Attach a shared memory segment to programs address space.
	

SEE ALSO: SHM_MALLOC(), SHM_DETACH, SHM_FREE  
##############################################################################
Command:  SHM_DETACH
Syntax:   SHM_DETACH id

DESCRIPTION:

	Detach a shared memory segment.

SEE ALSO: SHM_MALLOC(), SHM_ATTACH()
##############################################################################
Command:  SHM_FREE
Syntax:   SHM_FREE adr

DESCRIPTION:

	Free a shared memory segment.

SEE ALSO: SHM_MALLOC()
##############################################################################
Function: SHM_MALLOC()
Syntax:   adr=SHM_MALLOC(a,b)

DESCRIPTION:

	Allocate a shared memory segment. 

SEE ALSO: SHM_FREE
##############################################################################
Command:  SHOWPAGE
Syntax:   SHOWPAGE

DESCRIPTION:

	refreshes graphic output

SEE ALSO: VSYNC
##############################################################################
Function: SIN()
Syntax:   <num-result>=SIN(<num-expression>)

DESCRIPTION:

	Returns the sinus of the expression in radians.

EXAMPLE: 
	PRINT SIN(PI/2)     Result: 1

SEE ALSO: COS(), TAN(), ACOS()
##############################################################################
Function: SINH()
Syntax:   <num-result>=SINH(<num-expression>)

DESCRIPTION:

	Returns the sinus hyperbolicus of the expression in radians.

SEE ALSO: SIN(), ASINH()
##############################################################################
Command:  SIZEW
Syntax:   SIZEW nr,w,h

DESCRIPTION:

	Resizes the graphic window nr with width w and heigth h.

SEE ALSO: OPENW, MOVEW
##############################################################################

Command: SORT
Syntax:  SORT <array-name>()[,<n>[,<2nd array>()]]

DESCRIPTION:

	SORT  sorts  the  one-dimensional  array specified as argument. Numeric
	arrays and string arrays can be sorted. If <n> is given, only the
	first  <n> values are sorted. If <2nd array> is given, this (numerical)
	array  will also be sorted corresponding to the first. This is useful for
	creating an index table.

##############################################################################

Command: SOUND
Syntax:  SOUND <frequency>

DESCRIPTION:
	SOUND sounds the internal speaker with frequency [Hz]. If frequency=0
	shut up speaker. 

COMMENT:	
	The internal speaker is accessed via a console device. 
	The sound does not work unter xterm.

EXAMPLE:
	SOUND 500
	PAUSE 0.1
	SOUND 0

SEE ALSO:  PAUSE
 
##############################################################################
Variable:  SP
Syntax     <int-value>=SP

DESCRIPTION:

	Variable represents the internal X11-Basic Stack Pointer.

SEE ALSO: PC	
##############################################################################
Function:  SPACE$()
Syntax:    t$=SPACE$(n)

DESCRIPTION:

	Returns a string containing n spaces.
	
SEE ALSO:  STRING$()	
##############################################################################
Command:  SPLIT
Syntax:   SPLIT t$,t$,i%,var$[,var$]

DESCRIPTION:
	Same as WORT\_SEP.
	
SEE ALSO: WORT_SEP
##############################################################################
Command:  SPUT
Syntax:   SPUT screen$
DESCRIPTION:
	(xwd) Grafik in screen$ auf Window
SEE ALSO: SGET, PUT_BITMAP
##############################################################################
Function: SQR(), SQRT()
Syntax:   <num-result> = SQR(<num-expression>)
	  <num-result> = SQRT(<num-expression>)
DESCRIPTION:

	SQR() and SQRT()  return  the  square  root  of  its argument.  

EXAMPLES:
PRINT SQR(25)
Result: 5

PRINT "Calculate square root of a number."
INPUT "Number=",z
r124=1
105:
r123=r124
r124=(r123^2+z)/(2*r123)
IF ABS(r124-r123)-0.00001>0
  PRINT r124
  GOTO 105
ENDIF
PRINT "Result of this algorithm:"'r124
PRINT "Compare with: sqrt(";z;")=";SQRT(z)
PRINT "Deviation:"'ABS(SQRT(z)-r124)

SEE ALSO: Operator  ^ 
##############################################################################
Function:  SRAND()
Syntax:    VOID SRAND(b)

DESCRIPTION:

       The SRAND() function sets its argument as the seed  for  a
       new  sequence  of pseudo-random integers to be returned by
       RAND(), RANDOM() or RND().  These sequences are repeatable 
       by calling SRAND()
       with the same seed value.

SEE ALSO: RANDOMIZE, RANDOM(), RND(), RAND()
##############################################################################
Variable:  STIMER
Syntax:    <int-result>=STIMER

DESCRIPTION:

	Integer part of TIMER

SEE ALSO: TIMER, CTIMER
##############################################################################

Command: STOP
Syntax:  STOP
DESCRIPTION:

	STOP halts program  execution and sets the interpreter to interactive
	mode. The  execution can be continued with the CONT command.  

SEE ALSO:  CONT, END, QUIT

##############################################################################
STR$(1-4)
       t$=STR$(a[,b,c])        -- convert number to String of length b
                                  with c signifikant digits
STRING$(1-2)
SUB var,num
SUCC(1)
SWAP ???,???
#############################################################################

Function: SWAP()
Syntax:   <num-result>=SWAP(<num-expression:b>)

DESCRIPTION:

	Swaps High and Low words of b and returns the result.

SEE ALSO: BYTE(), CARD(), WORD()
#############################################################################

Function:   SYM_ADR()
Syntax:     adr=SYM_ADR(#n,sym_name$)

DESCRIPTION:

	SYM_ADR() resolves the adress of a symbol name of a given shared
	object  library which has been linked before.

EXAMPLE:

t$="/usr/lib/libreadline.so"    !  If the readline shared object file
IF EXIST(t$)                    !  exist, 
  LINK #1,t$                    !  link it, resolve the symbol "readline"
  DUMP "#"                      !  and execute that subroutine with 
  promt$=">>>"                  !  one string parameter.
  adr=EXEC(SYM_ADR(#1,"readline"),L:VARPTR(promt$))
  r=adr
  WHILE PEEK(r)>0               ! Print the result
    PRINT CHR$(PEEK(r));
    INC r
  wend 
  PRINT
  UNLINK #1			! Unlink the dynamic lib
  FREE adr
ENDIF


SEE ALSO: LINK, UNLINK

#############################################################################
Command: SYSTEM
Syntax:  SYSTEM <string-expression>

DESCRIPTION:

	Passes a command to the shell. Executes shell command. This command 
	provides a way to use alle commands like rm, rmdir, mkdir etc. 
	which are not implemented in X11-Basic.

EXAMPLE:
	SYSTEM "mkdir folder"

SEE ALSO: SYSTEM$()	

#############################################################################

Function: SYSTEM$()
Syntax:   <string-result>=SYSTEM$(<string-expression>)

DESCRIPTION:

	Passes a command to the shell. Executes shell command.
	The function returns a string containing the stdout of the
	command executed. 

EXAMPLE:

d$=SYSTEM$("ls")
PRINT d$

SEE ALSO: SYSTEM
##############################################################################
##############################################################################
Function: TERMINALNAME$()
Syntax:   t$=TERMINALNAME$(#n)

DESCRIPTION:

	returns device name of terminal connected to #n if it is a terminal
	device.

##############################################################################
Command:  TEXT
Syntax:   TEXT x,y,t$ 

DESCRIPTION:

	Draws Text t$ in graphics window at position x,y.

EXAMPLE:
' Show the complete ASCII Font
SETFONT "*writer*18*"
COLOR GET_COLOR(65535,10000,10000)
FOR x=0 to 15
  FOR y=0 to 15
    TEXT 320+16*y,20+24*x,CHR$(y+16*x)
  NEXT y
NEXT x
SHOWPAGE

SEE ALSO: SETFONT
##############################################################################
Variable: TIMER
Syntax:   TIMER

DESCRIPTION:

	Returns actual time in number of seconds since 01.01.1970.  

SEE ALSO: STIMER, CTIMER, TIME$, DATE$, UNIXTIME$(), UNIXDATE$()
##############################################################################

Command:  TROFF 
Syntax:   TROFF 
DESCRIPTION: 

	TROFF disables  tracing  output. This command is meant to be used
	during program development.

SEE ALSO: TRON, ECHO

##############################################################################

Command:  TRON
Syntax:   TRON
DESCRIPTION:
	TRON enables  tracing  output:  each  program
       line  is  displayed  on the console before it is executed. This
       command is meant to be used during program development.

SEE ALSO: TROFF, ECHO

##############################################################################
##############################################################################

Function: UCASE$()    
Syntax:   <string-result>=UCASE$(<string-expression>) 

DESCRIPTION:

	Transforms all lower case letters of a string to upper
        case. Any non letter characters are left unchanged.

SEE ALSO: UPPER$(), LOWER$()

##############################################################################

Variable: UNIX?  
Syntax:   <bool-result>=UNIX? 

DESCRIPTION:

	Returns TRUE (-1) If the program is running under a UNIX evironment.

SEE ALSO: WIN32?, TT?
##############################################################################
Function: UNIXTIME$(), UNIXDATE$()
Syntax:   t$=UNIXTIME$(i)
          d$=UNIXDATE$(i)

DESCRIPTION:
	  
	These functions return the date and time as a string which has the 
	same format as DATE$ and TIME$ given by a TIMER value.	  

EXAMPLE:
	PRINT UNIXDATE$(1045390004.431), UNIXTIME$(1045390004.431)
	Result:   16.02.2003   11:06:44

SEE ALSO:   DATE$, TIME$, TIMER	 
##############################################################################

Command: UNLINK
Syntax:  UNLINK #n     

DESCRIPTION:

	unlinks shared object file which has been linked before and
	occupies channel nr #n.

SEE ALSO: LINK, CLOSE

##############################################################################

Command:  UNTIL   
Syntax:   UNTIL <expression>  

DESCRIPTION:

	UNTIL terminates a REPEAT...UNTIL loop.

SEE ALSO:  REPEAT, DO

EXAMPLE:
       REPEAT
           N=N+1
       UNTIL (N=10)   
##############################################################################

Function: UPPER$()    
Syntax:   <string-result>=UPPER$(<string-expression>) 

DESCRIPTION:

	Transforms all lower case letters of a string to upper
        case. Any non letter characters are left unchanged.

SEE ALSO: UCASE$(), LOWER$()

##############################################################################
##############################################################################

Function: VAL()
Syntax:   <num-result> = VAL(<string-expression>)

DESCRIPTION:

	   VAL() converts String/ASCII to a numeric value.

SEE ALSO:  VAL?(),STR$()
EXAMPLE:
        a=VAL("3.1415926")

##############################################################################

Function: VAL?()
Syntax:   a=val?(t$)

DESCRIPTION:
	Returns number of characters forim string which can be converted to 
	a number.
EXAMPLE:
	print val?("12345.67e12Hallo")  Result: 11
SEE ALSO:  VAL()
##############################################################################
Function:   VARPTR()
Syntax:     <adr>=VARPTR(<variable>)        

DESCRIPTION:

	Determines the address of a variable and returns a pointer.
	VARPTR() can also be used to determin the adress of an 
	array index.

EXAMPLE:
	PRINT VARPTR(t$), VARPTR(a(2,4))

SEE ALSO: ARRPTR()

##############################################################################
Command:    VERSION
Syntax:     VERSION        

DESCRIPTION:

	Shows X11-Basic version number and date.

EXAMPLE:
	VERSION   
	Result: X11-BASIC Version: 1.08 vom Sat Feb 15 12:00:38 CET 2003 	

##############################################################################

Command:  VOID        Abbrev.   ~
Syntax:   VOID <expression>

DESCRIPTION:

	This command performs a calculation and forgets the
        result. Sounds silly but there are occasions when this
        command is required, eg. when you want to execute a function
	but you are not really interested in the return value.
        e.g. waiting for a keystroke (inp(-2)).

SEE ALSO:  GOSUB, @
EXAMPLE:
	~INP(-2)
	VOID FORM_ALERT(1,"[1][Hello][OK]")

##############################################################################

Command:  VSYNC
Syntax:   VSYNC

DESCRIPTION:

	Enables synchronization with the screen. Actually this is a synonyme for
	SHOWPAGE. Graphic output will not be shown in the window until SHOWPAGE
	(or VSYNC).
	
SEE ALSO:  SHOWPAGE

##############################################################################
##############################################################################

Command:  WHILE
Syntax:   WHILE <num-expression>
DESCRIPTION:

	WHILE initiates  a  WHILE...WEND  loop.  The loop   ends  with  WEND 
	and  execution  reiterates  while  the  WHILE <num-expression> is not
	FALSE  (not  null).  Unlike  a  REPEAT...UNTIL loop,  the  loop  body 
	is  not  necessarily executed at least once. 

SEE ALSO:    WEND, DO
EXAMPLE:
       WHILE NOT EOF(#1)
           LINEINPUT #1,a$
       WEND  
	
##############################################################################

Command:  WEND
Syntax:   WEND
DESCRIPTION:

	WEND terminates a WHILE...WEND loop.
SEE ALSO: WHILE, DO
EXAMPLE:
       WHILE NOT EOF(#1)
           LINEINPUT #1,a$
       WEND  

#############################################################################

Function: WORD()
Syntax: a=WORD(b)
DESCRIPTION:

	Returns lower 16 bits of b and expands sign.

SEE ALSO: BYTE(), CARD(), SWAP()

#############################################################################
Command:  WORT_SEP
Syntax:   WORT_SEP t$,d$,mode,a$,b$ 

DESCRIPTION:

	Splits up string t$ into two parts a$ and b$ concerning a delimiter 
	string d$. So that t$=a$+d$+b$. 
	mode can be: 0   --   default
		     1   --   do not serch parts of t$ which are in brackets.

	Quoted parts of the string are not spit up.

EXAMPLE:
	WORT_SEP "Hallo, this is a string."," ",0,a$,b$

SEE ALSO: SPLIT, WORT_SEP()
#############################################################################
Function:  WORT_SEP()
Syntax:    <num-result>=WORT_SEP(t$,d$,mode,a$,b$) 

DESCRIPTION:

	Splits up string t$ into two parts a$ and b$ concerning a delimiter 
	string d$. So that t$=a$+d$+b$. 
	mode can be: 0   --   default
		     1   --   do not serch parts of t$ which are in brackets.

	Quoted parts of the string are not spit up.

	The return value can be:
		2  -- The string has been split up.
		1  -- The string did not contain d$, a$=t$, b$=""
		0  -- The string was empty. a$="",b$=""

SEE ALSO: SPLIT
#############################################################################
##############################################################################

Command: XLOAD
Syntax:  XLOAD

DESCRIPTION:

	Opens a fileselector where the user can select a basic source file which
	then will be load into memory.

SEE ALSO:   XRUN, LOAD

##############################################################################

Operator: XOR
Syntax:     <num-expression1> XOR <num-expression2>

DESCRIPTION:

	Logical exclusive OR operator. XOR returns fale (0) if both
	arguments have the same logical value.
	
	Table: \hspace{2cm} \begin{tabular}{|c|c|c|}\hline	    
	 A  &  B  &  A XOR B\\
	   	   \hline
		    -1  & -1  &    0	      \\
		    -1  &  0  &   -1	      \\
		     0  & -1  &   -1	      \\
		     0  &  0  &    0	      \\\hline
        \end{tabular}

SEE ALSO:   NAND, OR, NOT, AND
EXAMPLE:       
	Print 3=3 XOR 4>2        Result:   0 (flase)
      	Print 3>3 XOR 5>3        Result:  -1 (true)
 
	PRINT (4 XOR 255)        Result:   251

##############################################################################

Function:   XOR()
Syntax:     <num-result>=XOR(<num-expression>,<num-expression2>)

DESCRIPTION:

	   Returns <num-expression> XOR <num-expression2>
	
	Table: \hspace{2cm} \begin{tabular}{|c|c|c|}\hline	    
	 a  &  b  &  XOR(a,b)\\
	   	   \hline
		    -1  & -1  &    0	      \\
		    -1  &  0  &   -1	      \\
		     0  & -1  &   -1	      \\
		     0  &  0  &    0	      \\\hline
        \end{tabular}

SEE ALSO: OR(), AND

##############################################################################

Command: XRUN
Syntax:  XRUN

DESCRIPTION:

	Opens a fileselector where the user can select a basic source file which
	then will be load into memory and executed.

SEE ALSO:   XLOAD, RUN

##############################################################################
4. FAQ frequently asked questions
=================================

Q: Why can't I compile X11Basic on my Computer with Zintorola 86060 processor 
   and Sluggix 0.8 Beta O.S.?
A: If you have GNU-C and X11R5/6 for this system, and X11Basic still won't 
   compile, please let me know as soon as possible, I will try to fix it.

Q: How do I leave the interpreter `gently'?
A: type quit or press ctrl-c (twice)

Q: What do all the warnings mean?
A: Well, isn't proper ported to your (any?) system. 

Q: Why do the graphics look funny?
A: Some X-Servers do not clean newly allocated Pixmaps. So rubbish is displayed 
   if the window is maped. Please do a clearw 1 as a first command.

Q: Is there a GUI-Designer for the graphical user unterface functions 
   of X11Basic ?
A: Well, so far nobody has made a real efford to write a real graphical 
   GUI_designer. But the program gui2bas may help creating GUI forms. The input
   is a very siple ASCII-File (*.gui) which defines the interface. So far 
   many GEM object types are supportet (and even Atart ST *.rsc-files may
   be converted to *.gui files with the rsc2gui program.) but support for 
   listboxes, popup-menues and Tooltips may be included in future.

Q: My old ANSI Basic Programs (with line-Numbers) produce lots of errors in the
   interpreter. How can I run classic (ANSI) Basic programs?
A: Classic Basic programs have to be converted before they can be run with 
   X11-Basic. With the bas2x11basic converter program most of this convertion
   will be done automatically. 

F: Kann ich meine alten Atari Programme "einfach" rüberziehen oder müssen
   die noch irgendwie ( speziell Gem Programme ) angepasst werden?
A: Die müssen noch angepasst werden. Es gibt kleinere Unterschiede in der
   Syntax, Systemaufrufe (XBIOS,BIOS,VDISYS etc), Inline-Blöcke gehen
   natürlich nicht, short int
   Variablen gibt es nicht etc. Also man muss nochmal mit der Hand
   drübergehen. Aber es gibt nichts, was nicht irgendwie auch geht.
   Bei kleinen Programmen (ca. 100 Zeilen) ist es ein Kinderspiel. Bei
   größeren (mehere 1000 Zeilen) ist es schon was arbeit. 10000-Zeilen
   Programme habe ich noch nicht portiert. Es lohnt wahrscheinlich nicht.
   Für Programme, an denen man nichts mehr machen will, empfehle ich dann
   doch lieber STonX oder sowas.

Q: Program XXX doesn't run, what should I do?
A: Well this question is too difficult to answer. 

Q: Can I use X11-Basic as a shell ? 
A: Yes, simply copy the xbasic executable to /usr/bin .
   The basic programs then should have in their first line
   #!/usr/bin/xbasic 

Q: Can I use X11-Basic as an internet daemon ? 
A: Yes, start xbasic with the option -daemon .
   This feature is still experimental. So use it on your own risk since this 
   opens several security holes to your system.

Q: Can X11-Basic generate stand-alone programs, which may run 
   without the xbasic executable ?
A: Yes and No. X11-Basic does not translate its input into assembly, you 
   always need the xbasic executable. On the other hand: the xbasic 
   executable is rather small (< 200 kB), so you might spread it around 
   with your X11-Basic programs. If you really need stand alone programs 
   try the pseudo-compiler (xbc). It can link the x11basic-library to your 
   programs. The result is a stand alone binary.
   
Q: May I charge for my X11-Basic programs ?
A: Yes, you may. But you should state clearly, that xbasic itself is available 
   free of charge. Refer to the File COPYING for details.

Q: Where can I get the newest version of X11-Basic? 
A: Probably at 
   http://x11-basic.sourceforge.net/
   Don't bet on it though! :-) 

Q: What can I do to speed up the development of X11-Basic?
A: You can try to bribe me with any amount of money, any type of hardware or
   software (no pirated stuff please).
   A nice postcard might suffice too. :-)
   If you like to implement some new features and/or commands to x11basic,
   please send me your new sources with description. But I only will implement
   this stuff if I like it .-)

--------------------------------------------------------------------------------



Things left to do:
==================
- Speed up the interpretation  with precompiled tokens
- Optimize a bit more
- The WIndows-Version needs more work
- Fix the bugs
- documentation needs more work
(etc. etc.)

BUGS:	- Integer-Artmetrik sehr(!) unvollständig
=====	- still some bugs


Version history of X11-Basic
============================

In the beginning there were absurd plans, long sleepless nights, and incredible
boredom.

Very First Version (1990)
--------------------------
It was a Mailbox-Program with Basic features (only character-Graphics with
Vt100EMU) on my ATARI ST (!).

Version 0.1 First version with a version number    (1997)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Mailbox-Program was rewritten in c on my Linux-PC
- first X11-Commands

Version 0.2 Alpha (1998)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- improved X11-Basic for use at the physics institute in Bonn
- Fixed last Problems of the Parser (didn't like -1*(4-3) )
- Added more X-features (redraw)
- First portation to a HP-Workstation
- Readline library in use

Version 1.00 Beta (Mar 1999)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Makefile and configure script adapted from STonX
- True-color Displays
- X rootwindow, multiple windows
- INKEY$
- First GPL-Distribution
- FILESELECT,ALERT

Version 1.01 (Jun 1999)
~~~~~~~~~~~~~~~~~~~~~~
- POINT()

Version 1.02 (Jun 2000)
~~~~~~~~~~~~~~~~~~~~~~
- rsrc_load
- shell, daemon

Version 1.03 (Mar 2001)
~~~~~~~~~~~~~~~~~~~~~~~
- copyarea, sget, sput, get,put
- fill-Patterns
- drop down menues
- String-Variables may now contain nul-characters.
- POKE,DPOKE,LPOKE,EVEN(),ODD()
- LINK,UNLINK
- CVI(),CVD(),CVF(),CVL()
- MKI$(),MKD$(),MKL$(),MKF$()
- ON x GOSUB proc1,proc2,...
- ON x GOTO label1,label2,...
- INSTR(),RINSTR()

Version 1.04 (Apr. 2001)
~~~~~~~~~~~~~~~~~~~~~~~~
- splitted off shared library libx11basic.so (300kB)
- bug fixed which caused print a,b to segmentation fault
- DUMP "#"
- SYM_ADR()
- CALL, EXEC, EXEC()  with parameter list
- DUMP "K" DUMP "F"

Version 1.05 (Aug. 2001)
~~~~~~~~~~~~~~~~~~~~~~~~
- PRINT USING
- SYSTEM$()
- GLOB()
- RBOX, PRBOX
- EDIT, SAVE
- HELP
- new system errors
- started to translate everything into english

Version 1.06 (Jan. 2002)
~~~~~~~~~~~~~~~~~~~~~~~~

- included serial device support
- improved FILESELECT
- modified ALERT
- improved COLOR
- FORM_DIAL(), FORM_DO(), OBJC_DRAW()
- GPRINT

Version 1.07 (Aug. 2002)
~~~~~~~~~~~~~~~~~~~~~~~~
- Fehler mit Exponentialdarstellungen von Zahlen mit negativem Exponent
  ist nun endlich behoben !!!
- Anbindung an tine-Bibliothek und Kontrollsystem ist nun moeglich

Version 1.08 (Jan. 2003)
~~~~~~~~~~~~~~~~~~~~~~~~
- Support for tine-library
- a first MS-WINDOWS version is now available
- some new functions
- FIT and FIT_LINEAR
- SORT command
There was a bug introduced in the MENU command. Fixed it in release 1.08-4.

Version 1.09 (June 2003)
~~~~~~~~~~~~~~~~~~~~~~~~
- ANSI-Basic to X11-Basic converter included
- New example programs
- updated man-page and documentation
- new SOUND command
- EVAL, EVAL()
- modified serial line support
- modified the configure procedure
- some modifications for portability
- will now compile on FreeBSD and CYGWIN

Version 1.10 (Feb 2004)
~~~~~~~~~~~~~~~~~~~~~~~~
- new REPLACE$() function 
- improved speed 
- bug fixed in ROUND() function


--------------------------------------------------------------------------------
*Acknowlegements

I would like to thank all people, which helped me to realize this
package.


Many  thanks  to  the developers of GFA-Basic. This basic made me
start programming in the 1980s. Many ideas and most of  the  command 
syntax has been taken from the ATARI ST implementation.

Thanks to sourceforge.net for hosting this project on the web.

Unfortuantely  derivates  of the routines of the famous book 
"numerical recepies in C" are not allowed to be distributed as  part
of  the  X11-Basic program. So I have not included all of the 
mathematics features of X11-Basic in this  distribution.      (see 
mathemat_dummy.c).  If you own the book and have a licence 
you may ask me for the sources of the routines.


