
#######                         ##########
####### THIS FILE IS STILL STUB ##########
#######                         ##########

////// Versuch einer Uebersetzung des Handbuchs nach Deutsch ///////

***************************************************************
*             x11basic                 V. 1.01                *
*                   von Markus Hoffmann 1997                  *
*                                                             *
*                                                             *
* Programmversion vom 01.02.1999                              *
*                                                             *
***************************************************************


 Bedienungsanleitung: 
 -------------------- 

Das Programm kann mit folgenden Parametern aufgerufen werden:  

xbasic <filename>   --- Basic-Programm ausfuehren  [input.bas]

-l                  --- Programm nur laden 
-e <kommando>       --- Basic Kommando ausfuehren 
--eval <ausdruck>   --- Num. Ausdruck auswerten  

Beispiel:

xbasic testme.bas
xbasic -e 'alert 1,"Hallo !",1," OK ",b'
xbasic --eval 1+3-4*3


Kurzanleitung zu X11BASIC:
===========================

Variablenkonzept:
-----------------

Der interpreter kennt 64-Bit Floatingpoint Variablen, 32-Bit Integervariablen,
Zeichenketten und beliebigdimensionale Felder obengenannter Typen.
Eine Deklaration der Variablen ist nicht noetig (Ausser bei Feldern --> DIM),
da der Interpreter den Typ an der Endung der Variable erkennt:
Integervariablen tragen die Endung %, Zeichenketten ein $, felder ein ().
Variablen ohne Endung werden als float interpretiert.
Pointer sind Integer, Funktionsergebnisse werden durch @ gekennzeichnet
Logische Ausdruecke soind ebenfalls vom Typ Interger.

Die Variablen werden dynamisch verwaltet, so sind beliebig grosse Zeichenketten
und Felder moeglich. Die Grenze ist hier nur der maximal allozierbare Speicher
und max. 31 Bit fuer die Indizierung. Das sollte vorerst ausreichen.


Beispiele:

Integer-Variablen:      i%=25
			a%=varptr(b$)
			b%=malloc(100000)
Float-Variablen:        a=1.2443e17
			b=@f(x)
Zeichenkettenvariablen: t$="Das ist ein Text"
Felder/Arrays:          i%(),a(),t$()

Logische Ausdruecke:    (a=2 AND b=5) sind vom Typ Integer (TRUE=-1, FALSE=0)


OPERATOREN
##########

Man unterscheidet zwischen numerischen, Zeichenketten- und Feld- bzw.
Matritzenoperatoren, je nachdem, ob das ergebnis der Operation eine Zahl oder
eine Zeichenkette ist.
 
-- Zeichenkettenoperatoren ---

+	Dier Verkettung von Zeichenketten.
	Dabei werden die durch + verbundenen Strings lückenlos
	aneinandergefügt.

	Beispiel: a$="X11", b$="-" und c$="BASIC", dann ergibt sich 
        d$=a$+b$+c$ die Zeichenkette "X11-BASIC" 

$()     Zeichenkettenfunktionen:
	z.B. LEFT$, RIGHT$, MID$, SPACE$, STRING$, STR$ ...

-- Numerische Operatoren --

Die numerischen Operatoen können in vier Kategorien gegliedert werden:

*	Arithmetische Operatoren

*	Vergleichsoperatoren

*	Logische Operatoren

*	Numerische Funktionen

-- Matritzenoperatoren --

Matritzenoperatoren oder allgemein Feld-Operatoren operieren auf Feldern.
Je nach Feldtyp und Dimension koennen sie unterschiedliche Bedeuting haben.

        $    F   I   D2 D3 Dn Sonstige Bemerkungen
+       *    *   *    *  *  *
-       -    *   *    *  *  *
*       -    *   *    *  -  -  M1=N2 , auch skalar
INV()   -    *   *    *  -  -  M=N
TRANS() *    *   *    *  -  -  M=N

Weiterhin gibt es Operatorn/Funktionen, die zwischen verschiedenen
Variablenklassen Operieren: z.B.
a%=INT(b), c=DET(d()), s=SMUL(a(),b()), a=NULL(2,4,5), ...

Insbesondere sei auf den Reduktionsoperator hingewiesen:
a(:,3) ist ein eindimensionaler Vektor, naemlich die Spalte Nr. 3 der
        Matrix a. 


-- Integer und Float-Variablen ---
()           Klammerung
+ - * /      Grundrechenarten
^            Potenz

MOD          Modulo
DIV          Ganzzahliger Teiler


Vergleichsoperatoren: = <> < > <= >=
====================================

Vergleichsoperatoren können zwischen zwei Ausdrüchen gleichen Typs stehen, also
zwischen Zeichenkettenausdruecken, numerischen Ausdruecken oder Feld-Ausdruecken.
Abhängig vom Wahrheitswert (wahr oder falsch) wird ein dem Vergleich entweder der
Wert -1 (wahr) oder 0 (falsch) zugeordnet.
(Da sich in jedem Fall eine Zahl ergibt, zählt auch der Vergleich von
Zeichenketten zu den numerischen Operatoren.)

Folgende Vergleichsoperatoren sind verfügbar:

	=	gleich
	>	größer als
	<	kleiner als
	<>	ungleich
	>=	größer oder gleich
	<=	kleiner oder gleich

Zum Vergleich von numerischen Ausdrücken sollen hier nur einige Beispiele
aufgeführt werden:

PRINT 3=1.5*2  übergibt den Wert  -1   (wahr)
PRINT 5>5      übergibt den Wert   0   (falsch)

Der Vergleich von Zeichenketten vollzieht sich nach folgenden Regeln: 

*	Zwei Zeichenketten sind gleich, wenn sie vollständig übereinstimmen.
	(Dabei werden alle Zeichen der Strings, auch Leerzeichen und Satzzeichen,
	verglichen. So gilt z.B. " 123 v fdh.-," = " 123 v fdh.-,")

*	Bein Größenvergleich zweier Strings wird folgendermaßen verfahren:
	Die Zeichenketten werden Zeichenweise verglichen, solange, bis der
	ASCII-Code des Zeichens des einen Strings kleiner ist als der des
	Zeichens  des anderen Strings, oder das Zeichenkettenende eines Strings
	erreicht wird. Dieser Ist dann kleiner als der andere.

	Beispiele:
	"X11">"X11"     ergibt  0
        "X11"<"x11"     ergibt -1
        "123"<"abc"     ergibt -1
        "123">"1234"    ergibt  0

Logische Operatoren: AND OR NAND OR NOT XOR EQV IMP 
====================================================

Mit Hilfe der logischen Operatoren können Ausdrücke oder Beziehungen zwischen
Ausdrücken miteinander verbunden werden.

In der Regel werden mit logischen Operatoren Wahrheitswerte verknüpft und als
Ergebnis wiederum Wahrheitswerte ausgegeben.
Dabei wird jedem numerischen Ausdruck ungleich 0 der Wahrheitswert 0 und jedem
Ausdruck, dessen Wert gleich 0 ist, der Wahrheitswert falsch zugeordnet.
Die von den Logischen Operatoren erzeugten Wahrheitswerte ergeben sich aus
der Bit-weisen Operation, wenn die Operanden als 32-Bit Integerwerte
angesehen werden. Deshalb gehoert zum Wahrheitswert 0 (falsch) der
Wahrheitswert -1 (wahr). Hierfür gibt es auch die Systemvariablen TRUE=-1
und FALSE=0. Dies kann man auch in numerischen Ausdrücken Verwenden, z.B.:
a=ABS(x=0)*100+ABS(x=1)*200   je nach dem Wert von x erhaelt die Variable a die
Werte 100 oder 200.

AND   Konjunktion
      Das Ergebnis von AND ist nur dann w, wenn beide Argumente w sind:

      A  |  B  |  A AND B
    -----+-----+-----------
      w  |  w  |    w
      w  |  f  |    f
      f  |  w  |    f
      f  |  f  |    f

      Beispiele:
      Print 3=3 AND 4>2        ergibt  -1 (w)
      Print 3>3 AND 5>3        ergibt   0 (f)

OR   Disjunktion
     Das Ergebnis von OR ist nur dann f, wenn beide Argumente f sind:

      A  |  B  |  A OR B
    -----+-----+-----------
      w  |  w  |    w  
      w  |  f  |    w
      f  |  w  |    w
      f  |  f  |    f
      
      Beispiele:
      Print "A"<"a" OR 3=5     ergibt  -1 (w)
      Print 2>7 OR 10=20       ergibt   0 (f)

XOR  Exclusives (oder ausschließendes) Oder
     Das Ergebnis von XOR ist  f, wenn die Argumente gleiche Wahrheitswerte
     haben:
      
      A  |  B  |  A XOR B   
    -----+-----+-----------
      w  |  w  |    f
      w  |  f  |    w
      f  |  w  |    w
      f  |  f  |    f

      Beispiele:
      Print 3=3 XOR 6=6     ergibt   0 (f)
      Print 3>5 XOR 3<5     ergibt  -1 (w)

NOT   Die Negation vertauscht Wahrheitswerte in ihr Gegenteil.

      A  |  NOT A
    -----+----------
      w  |   f 
      f  |   w  

      Beispiel:
      Print NOT 3=3      ergibt   0 (f)

IMP  Implikation
     Das Resultat der Operation ist dann falsch, wenn falsch auf wahr folgt. 
      
      A  |  B  |  A IMP B
    -----+-----+-----------
      w  |  w  |    w
      w  |  f  |    f
      f  |  w  |    w
      f  |  f  |    w

EQV  Äquivalenz 
     Dier Operation ist identisch mit (A IMP B) AND (B IMP A)
                                                                           
      A  |  B  |  A EQV B
    -----+-----+-----------
      w  |  w  |    w
      w  |  f  |    f
      f  |  w  |    f
      f  |  f  |    w

Die logischen Operatoren werden hauptsächlich dazu benutzt, um abhängig vom
Wahrheitswert verbundener Ausdrücke verschiedene Programmabläufe zu ermöglichen
(z.B. über die Befehle IF, WHILE, EXIT IF ...)
Logische Operatoren können aber auch dazu benutzt werden, um Bitfolgen zu
verknüpfen.






------ Anweisungen -------------
Allgemeines:

Nach Befehlen sind Kommentare erlaubt, die mit einem "!" vom Befehl abzusetzen
sind.
DO    ! Endlosschleife
LOOP  ! und nix drin

Diese Kommentare sind natuerlich nicht erlaubt nach DATA (und REM).

Der &-Operator gefolgt von einem Zeichenkettenausdruck evaluiert deren inhalt 
als Programm-Code.

Beispiel:

clr i
a$="print a$"
label1:
inc i
if i>10 
  b$="label2"
else
  b$="label1"
endif
&a$
goto &b$
label2:
end

erzeugt 10x die Ausgabe "print a$".
Dies fuehrt leicht zu unuebersichtlichem Code, aber schliesslich schmpft sich
der Interpreter ja Basic.



'                     -- Abkuerzung fuer REM
?                     -- Abkuerzung fuer PRINT
@                     -- Abkuerzung fuer GOSUB, bzw Funktionsaufruf
~                     -- Abkuerzung fuer VOID
!                     -- Kommentar hinter einer Zeile
&                     -- Indirektes Kommando


------ Systemvariablen ----------

TRUE                  -1
FALSE                 0
CRSCOL			n.n.
CRSLIN			n.n.
PI                    3.141592...
TIMER                 Systemtimer, float, erhoet sich mehr oder weniger 
                      kontinuierlich mit der Zeit, pro Sekunde um eins
STIMER                Dasselbe nur ganzzahlig
CTIMER                Dasselbe nur in Einheiten der CPU-Zeit
PC                    Zeilennr der naechsten auszufuehrenden Zeile
SP                    interner Stackpointer (Verschachtelungstiefe)
ERR                   Fehlernr des letzten Fehlers


MOUSEX                X-Koordinate der Mausposition relativ zum Fensterursprung
MOUSEY                Y-Koordinate der Mausposition
MOUSEK                Bitrepresentation der gedrueckten Maustasten, 
                      Button 1=Bit 0,Button 2=Bit 1 usw.
MOUSES                Status der Umschalttasten 

ENV$(n$)              Inhalt der Environmentvariable mit Namen n$
INKEY$                Inhalt des Tastaturpuffers
PRG$(i)               Programmzeile i
TERMINALNAME$         Devicename des Terminals
TIME$                 Aktuelle Zeit 
DATE$                 Aktuelles Datum

==================== Befehle ==============================

ADD a,b			-- gleiche Wirkung wie a=a+b
ALERT a%,b$,c%,d$,e%	-- Warn- und Infobox

BELL			-- Warnton
BGET #n,a%,n%
BLOAD f$,a%[,l%]	-- Laed File an Adresse
BMOVE q%,z%,n%
BOX x1%,y1%,x2%,y2%	-- Rechteck zeichenen
BPUT
BREAK                   -- entspricht EXIT IF true
BSAVE f$,a%,l%		-- Speichert l% Bytes ab Adresse a% in File f$

CLR a,b%,c(),f$		-- Löscht Variableninhalte
color n%		-- Farbe auswählen

DATA 1,"Hallo",...	-- Definiert Konstanten im Programmcode
DEFMOUSE i%		-- aendert das Erscheinungsbild des Mauscursors.
DO * LOOP		-- Endlosschleife
DUMP			-- Variablenliste
DUMP "@"                -- Liste der Funktionen und Prozeduren
DUMP ":"                -- Liste der Labels

END			-- Programmende, kehrt zurueck in den Direktmodus
EXIT IF a		-- Verlaesst Schleife wenn Bedingung a erfuellt ist

FILESELECT titel$,pfad$,default$,f$  --
FOR * NEXT		-- For Next Schleife
FFT a(),i		-- Fouriertransformation. i=-1 Ruecktransformation
			   Dim?(a()) muss Zweierpotenz sein.
FLUSH [#n]              -- Output flushen
FORM_INPUT t$
FUNCTION * ENDFUNC

IF * ELSE IF * ELSE * ENDIF 
i%=INT(a)		-- rundet auf naechste ganze Zahl ab

LIST			-- Listet Programmcode
LOAD a$			-- Laed Programm (Dateiname in a$)
LTEXT x%,y%,t$          -- Line-Text

MUL a,b			-- a=a*b

NEW			-- Loescht alle Variablen und haelt Programmausfuehrung an.

ON * GOSUB     
ON BREAK GOSUB
ON ERROR GOSUB
OPEN mode$,#n,filename$	-- Oeffnet ein file
OPENW n
OUT #n,a

PAUSE sec		-- Haelt Programmausfuehrung fuer sec Sekunden an
PBOX  x1,y1,x2,y2
PCIRCLE x,y,r
PELLIPSE 
PLIST                   -- Formatiertes Listing
PLOT x,y                -- Punkt an Bildschirmkoordinate x,y zeichnen 
POKE a%,d
PRINT a;b$     -- Ausgewachsener BASIC-Standard-Befehl
PROCEDURE * RETURN
PUTBACK [#n,]a%   -- Zeichen mit ASCII-Code a% an inputkanal zurueckgeben

QUIT           -- Verlaesst den XBASIC-Interpreter

RELSEEK #n,d
REM Kommentar  -- Kommentarzeile
REPEAT * UNTIL
RESTORE
RESUME
RUN            -- Startet die Programmausfuehrung

SCOPE a(),typ,yscale,yoffset   -- Schnelles Plotten des Feldes a()
SCOPE y(),x(),typ,yscale,yoffset,xscale,xoffset   -- 2D Plot
SEEK
SHOWPAGE       -- Aktualisiert die Grafikausgabe
SUB
SWAP
SYSTEM t$      -- Führt Shell-Kommando aus

TEXT x,y,t$
TROFF
TRON
a=TRUE         -- TRUE hat immer den Wahrheitswert -1



VOID a         -- Berechnet Ausdruck a und vergisst Ergebnis
VSYNC          -- Aktualisiert die Grafikausgabe

WORT_SEP t$,d$,mode,var1$,var2$

XLOAD          -- wie load, mit FILESELECTOR
XRUN           -- load und run, mit FILESELECTOR

=============== Funktionen  =========================
b=ABS(a)               -- Absolutbetrag
c=ADD(a,b)             -- Addiere, binaer
a%=ARRPTR(b())         -- Adresse des Array-Descriptors
a%=ASC(t$)             -- ASCII-Wert des ersten Zeichens von t$
b=ATN(a)               -- Arcustangens
b=ATAN(a)              -- Arcustangens

b$=BIN$(a%[,n%])

t$=CHR$(a%)
b=COS(a)
CVI * CVL * CVS * CVF * CVD

DFREE
DEG
DIM?
DPEEK

EOF(#n)
EXIST(fname$)
b=EXP(a)		-- Exponentialfuntion

b=FRAC(a)		-- Liefert den nichtganzzahligen Anteil an a
FRE(n)			-- Keine Funtion, nur aus Kompatibilitaetsgruenden da.
a%=FORM_ALERT(n%,t$)

c%=GET_COLOR(r%,g%,b%) -- Alloziert eine Farbe in der Farbtabelle und gibt die
                          Nummer zurueck. Ist in der Farbtabelle kein Platz
			  mehr, so wird die Nummer derjenigen Farbe
			  zurueckgegeben, die der angeforderten am naechsten
			  kommt.

t$=HEX$(a[,n])

c%=INP(#n)		-- Liest ein Zeichen (Byte) vom Kanal. Kanal -2 ist stdin
i%=INP%(#n)
t$=INPUT$(#n,anz%)
INSTR
i=INT(a)		-- Schneidet die Nachkommastellen ab, liefert ganze Zahl

LEFT$
l%=LEN(t$)
b=LN(a)			-- Natuerlicher Logarithmus
p%=LOC(#n)		-- Position des Filepointers (--> SEEK/RELSEEK)
l%=LOF(#n)		-- Laenge des files
a=LOG(b)
a=LOG10(b)
LPEEK
LPOS

m=MAX(a,b,c,...)
m=MAX(f())
MID$
m=MIN(a,b,c,...)
m=MIN(f())

MKI$ * MKL$ * MKS$ * MKF$ * MKD$ 

o$=OCT$(d%,n%)

d%=PEEK(a%)
c%=POINT(x%,y%)         -- Liefert Farbwert des Punkts der Grafik im aktuellen Fenster
POS


RANDOM(n%)
RIGHT$


b=SIN(a)		-- Sinus
i%=SGN(a)		-- Vorzeichen (-1,0,1)
t$=SPACE$(i%)		-- gibt einen String
SPC(i%)
b=SQR(a)		-- Wurzel
b=SQRT(a)		-- Wurzel
t$=STR$(a[,b%,c%])
t$=STRING$(w$,i%)


TAB(i%)
b=TAN(a)		-- Tangens
b=TRUNC(a)

u$=UPPER$(t$)		-- liefert t$ in Grossbuchstaben

a=VAL(t$)		-- Wandelt String in Zahl, falls der String eine
			   Zahlndarstellung enthaelt.
i%=VAL?(t$)		-- Liefert die Anzahl der Umwandelbaren Zeichen
a%=VARPTR(v)		-- Adresse der Variablen v



BUGS:
=====

noch nicht alles implementiert.  Syntax nicht idiotensicher.

